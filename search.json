[{"title":"Palantir Foundry技术演进：从定制代码到AIP智能决策","url":"/2025/10/10/Palantir%20Foundry%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E%E5%AE%9A%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0AIP%E6%99%BA%E8%83%BD%E5%86%B3%E7%AD%96/","content":"TLDR笔者推测Palantir起初以支持定制代码运行为基础，在构筑自己部署平台（Apollo，Palantir GitHub上也有很多开发者构建、Lint工具）的同时，逐渐抽象出Dataset、本体、Function、Action API，打造了坚实的Foundry平台，让应用从定制化开发逐步“长在平台上”。最终，Palantir 推出人工智能平台（AIP），实现数据驱动的智能决策。\n前言近年来，Palantir 无疑成为数据分析领域的焦点之一。作为一家以解决复杂问题为核心的公司，Palantir 为政府、国防和企业客户提供了强大的数据整合与分析能力。Palantir 的核心产品 Foundry 是一个面向数据整合与分析的平台，它如何从最初的定制化开发逐渐演变为如今的通用数据智能平台？笔者尝试基于公开资源推测梳理 Palantir Foundry技术平台的演进路线，分享一些分析与推测。本文仅代表个人观点，欢迎读者交流探讨。\n阶段0 定制代码运行从Palantir的Offering来看，其核心始终是为客户解决复杂问题，拥有大量的FDE。合理推测Palantir最早其实以定制代码运行交付作为基础，通过高度定制化的软件开发满足客户在政府、国防和企业领域的特定需求。阶段0，此时都处于定制开发状态。\n阶段1 从定制代码运行到Palantir平台运行正如《人月神话》中所说，优秀的程序员都会有自己的library库，优秀的定制开发商也倾向于提炼可复用的技术框架。\n对于定制代码来说，我们把定制代码分为编写态和运行态\n\n编写态，对应Palantir Code Repositories，可以看到Palantir的很多东西，其实跟Git很相似，有分支、合并等等。\n运行态，将Palantir Code Repositories的代码构建运行，支持多种触发方式，比如通过API调用来执行，定时执行等。Apollo 平台进一步支持多环境部署（如云和边缘）。\n\n阶段2 数据的平台化存储和管理当开发工作逐渐迁移到 Palantir 平台后，数据的存储和管理成为下一个重点。如果代码已经运行在平台上，那么数据为什么不能也存储在平台中呢？\nPalantir 在这一阶段引入了 Dataset 和本体（Ontology）模型，构建了平台化的数据管理能力。Dataset 作为数据的核心容器，支持结构化和非结构化数据的存储；本体则定义了数据之间的语义关系，为数据提供了更高级的抽象层。此外，Palantir 接入了时序数据库，增加了对时间序列数据的支持，满足了金融、工业等领域对实时数据处理的需求。\n同时，也把数据集的变更增加为一个触发条件。例如，当某个 Dataset 发生变化时，平台可以自动触发预定义的操作，如运行一段代码或更新其他数据集。\n\n阶段3 抽象Action Function在本体已经定义了DataSet以及数据集之间关系的基础上，通过Action、Function的定义，同时Action、Function可以通过拖拉拽简单地生成，无需书写代码。对于难以无码的复杂逻辑，还可以通过定制代码来书写。\n其实Workflow和Pipeline都是在更高层次、更简便地操作代码的手段而存在，底层实现上：\n\nPipeline &#x3D; Datasets+Builds+Schedules\nWorkflow &#x3D; Schedules + Builds + Jobs\n\n\n阶段 4：AIP 的智能决策赋能在Foundry坚实的基础上，Palantir 2023 年推出了 AIP（人工智能平台）整合大语言模型（LLM）与 Foundry 数据，自动化复杂决策。其核心功能包括：\n\n自然语言处理：用户通过对话界面查询数据或生成分析，如“预测下季度库存需求”。\n自动化工作流：基于 Ontology，AIP 驱动智能决策，例如优化供应链或调度资源。\n实时推理：结合时序数据，AIP 支持动态预测，如医疗资源分配或工业故障检测。\n\n总结图：笔者设想的企业使用Foundry路线图\n本文分析了Palantir Foundry的技术实现路径，笔者认为Palantir Foundry 的技术演进展现了一个从“定制”到“平台原生”的清晰路径。应用从分散的定制代码，逐步迁移到平台上运行，扎根于平台的数据和触发机制，最终成为完全依赖平台功能的原生应用。\n","tags":["Palantir"]},{"title":"软件应该以标准的格式来交付","url":"/2025/09/22/%E8%BD%AF%E4%BB%B6%E5%BA%94%E8%AF%A5%E4%BB%A5%E6%A0%87%E5%87%86%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9D%A5%E4%BA%A4%E4%BB%98/","content":"令人深思的经历曾经历过这样的事情，平台侧要求应用提供满足平台特有格式的交付件，经过多次协商，最终还是应用侧与平台侧一起开会，由平台侧帮助应用侧输出。\n另一件事，Kubernetes Yaml以其独特、强大的合并属性能力闻名于江湖。应用侧对Kubernetes Yaml不熟悉，新手想要把环境上的Yaml导出直接作为标准交付件，虽然也行，但是包含了很多噪音，环境上的id、环境上的annotation、时间戳等等。\n私有化格式的交付困境越来越多的软件将自己定位为”平台”，无论是微信、飞书这样的国民应用，还是各类企业级软件。但平台交付的过程中，一个普遍存在的问题是：许多平台要求合作伙伴或第三方开发者使用其私有化的交付格式。这种私有化格式往往存在诸多问题：\n\n学习成本高，难以掌握。\n文档不完善，依赖平台方支持。\n迁移困难，形成供应商锁定。\n最终往往仍需平台方投入人力协助。\n\n软件交付应该标准化软件交付应该使用标准的格式，这有助于降低合作伙伴的接入成本，提高自身的可扩展性，尤其在AI辅助研发的现状下，采用标准的格式更有利于AI理解和生成代码。\n\n\n\n交付件\n标准格式\n使用场景\n\n\n\nJava库\nJar包\n作为依赖库被其他Java项目引用和集成，需要发布到Maven仓库。\n\n\n应用镜像\n标准镜像包\n以容器方式交付，确保运行的一致性。（但如x86、armv8、armv7）的差异依然存在。\n\n\n应用部署（I层资源已具备）\nhelm、docker compose\n商用场景多用Helm包，单机伪集群&#x2F;组合方式多用docker compose。\n\n\n应用部署及I层资源创建\nTerraform\n需要交付底层基础设施或云服务的场景，如整个应用运行环境。\n\n\n如果实在要使用私有的格式，可以对标准格式做一些裁剪&#x2F;扩展（Kubernetes的annotation），将标准格式转化到私有格式。\n"}]