[{"title":"Calcite Parser代码生成详解","url":"/2022/09/26/Calcite%20Parser%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AF%A6%E8%A7%A3/","content":"本文代码均已上传到giteecalcite的parser代码生成分为如下两个步骤  \n  \n生成Parse.jj文件目录如下\n├── pom.xml└── src    ├── main    │   ├── codegen    │   │   ├── config.fmpp    │   │   ├── includes    │   │   │   ├── compoundIdentifier.ftl    │   │   │   └── parserImpls.ftl    │   │   └── templates    │   │       └── Parser.jj\n\n添加calcite dependency\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;    &lt;artifactId&gt;calcite-core&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n配置drill-fmpp-maven-plugin插件如下\n&lt;plugin&gt;    &lt;groupId&gt;org.apache.drill.tools&lt;/groupId&gt;    &lt;artifactId&gt;drill-fmpp-maven-plugin&lt;/artifactId&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;configuration&gt;                &lt;config&gt;src/main/codegen/config.fmpp&lt;/config&gt;                &lt;output&gt;$&#123;project.build.directory&#125;/generated-sources/fmpp&lt;/output&gt;                &lt;templates&gt;src/main/codegen/templates&lt;/templates&gt;            &lt;/configuration&gt;            &lt;id&gt;generate-fmpp-sources&lt;/id&gt;            &lt;phase&gt;validate&lt;/phase&gt;            &lt;goals&gt;                &lt;goal&gt;generate&lt;/goal&gt;            &lt;/goals&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;\n\ncodegen 模块的文件都拷贝自对应版本的calclite core&#x2F;src&#x2F;main&#x2F;codegen路径 https://github.com/apache/calcite/tree/main/core/src/main/codegen\n然后把https://github.com/apache/calcite/blob/main/core/src/main/codegen/default_config.fmpp 中的parser属性与config.fmpp中的parser属性合并。就可以通过mvn package命令生成Parser.jj了。当然，如果有定制化修改的需求，也可以在这个阶段修改config.fmpp  \n  \nParser.jj生成java代码文件目录如下\n├── pom.xml├── src│   ├── main│   │   ├── codegen│   │   │   └── Parser.jj\n\nParser.jj就是我们上一步生成的Parser.jj，如果有什么想要的定制化修改，也可以在这个步骤改入到Parser.jj中。\n添加calcite dependency\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;    &lt;artifactId&gt;calcite-core&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置javacc-maven-plugin如下\n&lt;plugin&gt;    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;    &lt;artifactId&gt;javacc-maven-plugin&lt;/artifactId&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;id&gt;javacc&lt;/id&gt;            &lt;goals&gt;                &lt;goal&gt;javacc&lt;/goal&gt;            &lt;/goals&gt;            &lt;configuration&gt;                &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/codegen&lt;/sourceDirectory&gt;                &lt;includes&gt;                    &lt;include&gt;**/Parser.jj&lt;/include&gt;                &lt;/includes&gt;            &lt;/configuration&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;\n\n生成代码  \n  \n无Parser.jj定制化修改，一步生成无Parser.jj定制化修改，一步生成如果不需要对Parser.jj进行定制化修改，那么可以通过连续运行两个插件来生成代码，这里给出pom文件样例，不再赘述\n&lt;plugin&gt;    &lt;groupId&gt;org.apache.drill.tools&lt;/groupId&gt;    &lt;artifactId&gt;drill-fmpp-maven-plugin&lt;/artifactId&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;configuration&gt;                &lt;config&gt;src/main/codegen/config.fmpp&lt;/config&gt;                &lt;output&gt;$&#123;project.build.directory&#125;/generated-sources/fmpp&lt;/output&gt;                &lt;templates&gt;src/main/codegen/templates&lt;/templates&gt;            &lt;/configuration&gt;            &lt;id&gt;generate-fmpp-sources&lt;/id&gt;            &lt;phase&gt;validate&lt;/phase&gt;            &lt;goals&gt;                &lt;goal&gt;generate&lt;/goal&gt;            &lt;/goals&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt;    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;    &lt;artifactId&gt;javacc-maven-plugin&lt;/artifactId&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;id&gt;javacc&lt;/id&gt;            &lt;goals&gt;                &lt;goal&gt;javacc&lt;/goal&gt;            &lt;/goals&gt;            &lt;configuration&gt;                &lt;sourceDirectory&gt;$&#123;project.build.directory&#125;/generated-sources/fmpp&lt;/sourceDirectory&gt;                &lt;includes&gt;                    &lt;include&gt;**/Parser.jj&lt;/include&gt;                &lt;/includes&gt;                &lt;lookAhead&gt;2&lt;/lookAhead&gt;                &lt;isStatic&gt;false&lt;/isStatic&gt;            &lt;/configuration&gt;        &lt;/execution&gt;        &lt;execution&gt;            &lt;id&gt;javacc-test&lt;/id&gt;            &lt;phase&gt;generate-test-sources&lt;/phase&gt;            &lt;goals&gt;                &lt;goal&gt;javacc&lt;/goal&gt;            &lt;/goals&gt;            &lt;configuration&gt;                &lt;sourceDirectory&gt;$&#123;project.build.directory&#125;/generated-test-sources/fmpp&lt;/sourceDirectory&gt;                &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/generated-test-sources/javacc&lt;/outputDirectory&gt;                &lt;includes&gt;                    &lt;include&gt;**/Parser.jj&lt;/include&gt;                &lt;/includes&gt;                &lt;isStatic&gt;false&lt;/isStatic&gt;                &lt;ignoreCase&gt;true&lt;/ignoreCase&gt;                &lt;unicodeInput&gt;true&lt;/unicodeInput&gt;            &lt;/configuration&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;\n"},{"title":"Palantir Foundry技术演进：从定制代码到AIP智能决策","url":"/2025/10/10/Palantir%20Foundry%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E%E5%AE%9A%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0AIP%E6%99%BA%E8%83%BD%E5%86%B3%E7%AD%96/","content":"TLDR笔者推测Palantir起初以支持定制代码运行为基础，在构筑自己部署平台（Apollo，Palantir GitHub上也有很多开发者构建、Lint工具）的同时，逐渐抽象出Dataset、本体、Function、Action API，打造了坚实的Foundry平台，让应用从定制化开发逐步“长在平台上”。最终，Palantir 推出人工智能平台（AIP），实现数据驱动的智能决策。\n前言近年来，Palantir 无疑成为数据分析领域的焦点之一。作为一家以解决复杂问题为核心的公司，Palantir 为政府、国防和企业客户提供了强大的数据整合与分析能力。Palantir 的核心产品 Foundry 是一个面向数据整合与分析的平台，它如何从最初的定制化开发逐渐演变为如今的通用数据智能平台？笔者尝试基于公开资源推测梳理 Palantir Foundry技术平台的演进路线，分享一些分析与推测。本文仅代表个人观点，欢迎读者交流探讨。\n阶段0 定制代码运行从Palantir的Offering来看，其核心始终是为客户解决复杂问题，拥有大量的FDE。合理推测Palantir最早其实以定制代码运行交付作为基础，通过高度定制化的软件开发满足客户在政府、国防和企业领域的特定需求。阶段0，此时都处于定制开发状态。\n阶段1 从定制代码运行到Palantir平台运行正如《人月神话》中所说，优秀的程序员都会有自己的library库，优秀的定制开发商也倾向于提炼可复用的技术框架。\n对于定制代码来说，我们把定制代码分为编写态和运行态\n\n编写态，对应Palantir Code Repositories，可以看到Palantir的很多东西，其实跟Git很相似，有分支、合并等等。\n运行态，将Palantir Code Repositories的代码构建运行，支持多种触发方式，比如通过API调用来执行，定时执行等。Apollo 平台进一步支持多环境部署（如云和边缘）。\n\n阶段2 数据的平台化存储和管理当开发工作逐渐迁移到 Palantir 平台后，数据的存储和管理成为下一个重点。如果代码已经运行在平台上，那么数据为什么不能也存储在平台中呢？\nPalantir 在这一阶段引入了 Dataset 和本体（Ontology）模型，构建了平台化的数据管理能力。Dataset 作为数据的核心容器，支持结构化和非结构化数据的存储；本体则定义了数据之间的语义关系，为数据提供了更高级的抽象层。此外，Palantir 接入了时序数据库，增加了对时间序列数据的支持，满足了金融、工业等领域对实时数据处理的需求。\n同时，也把数据集的变更增加为一个触发条件。例如，当某个 Dataset 发生变化时，平台可以自动触发预定义的操作，如运行一段代码或更新其他数据集。\n\n阶段3 抽象Action Function在本体已经定义了DataSet以及数据集之间关系的基础上，通过Action、Function的定义，同时Action、Function可以通过拖拉拽简单地生成，无需书写代码。对于难以无码的复杂逻辑，还可以通过定制代码来书写。\n其实Workflow和Pipeline都是在更高层次、更简便地操作代码的手段而存在，底层实现上：\n\nPipeline &#x3D; Datasets+Builds+Schedules\nWorkflow &#x3D; Schedules + Builds + Jobs\n\n\n阶段 4：AIP 的智能决策赋能在Foundry坚实的基础上，Palantir 2023 年推出了 AIP（人工智能平台）整合大语言模型（LLM）与 Foundry 数据，自动化复杂决策。其核心功能包括：\n\n自然语言处理：用户通过对话界面查询数据或生成分析，如“预测下季度库存需求”。\n自动化工作流：基于 Ontology，AIP 驱动智能决策，例如优化供应链或调度资源。\n实时推理：结合时序数据，AIP 支持动态预测，如医疗资源分配或工业故障检测。\n\n总结图：笔者设想的企业使用Foundry路线图\n本文分析了Palantir Foundry的技术实现路径，笔者认为Palantir Foundry 的技术演进展现了一个从“定制”到“平台原生”的清晰路径。应用从分散的定制代码，逐步迁移到平台上运行，扎根于平台的数据和触发机制，最终成为完全依赖平台功能的原生应用。\n","tags":["Palantir"]},{"title":"软件应该以标准的格式来交付","url":"/2025/09/22/%E8%BD%AF%E4%BB%B6%E5%BA%94%E8%AF%A5%E4%BB%A5%E6%A0%87%E5%87%86%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9D%A5%E4%BA%A4%E4%BB%98/","content":"令人深思的经历曾经历过这样的事情，平台侧要求应用提供满足平台特有格式的交付件，经过多次协商，最终还是应用侧与平台侧一起开会，由平台侧帮助应用侧输出。\n另一件事，Kubernetes Yaml以其独特、强大的合并属性能力闻名于江湖。应用侧对Kubernetes Yaml不熟悉，新手想要把环境上的Yaml导出直接作为标准交付件，虽然也行，但是包含了很多噪音，环境上的id、环境上的annotation、时间戳等等。\n私有化格式的交付困境越来越多的软件将自己定位为”平台”，无论是微信、飞书这样的国民应用，还是各类企业级软件。但平台交付的过程中，一个普遍存在的问题是：许多平台要求合作伙伴或第三方开发者使用其私有化的交付格式。这种私有化格式往往存在诸多问题：\n\n学习成本高，难以掌握。\n文档不完善，依赖平台方支持。\n迁移困难，形成供应商锁定。\n最终往往仍需平台方投入人力协助。\n\n软件交付应该标准化软件交付应该使用标准的格式，这有助于降低合作伙伴的接入成本，提高自身的可扩展性，尤其在AI辅助研发的现状下，采用标准的格式更有利于AI理解和生成代码。\n\n\n\n交付件\n标准格式\n使用场景\n\n\n\nJava库\nJar包\n作为依赖库被其他Java项目引用和集成，需要发布到Maven仓库。\n\n\n应用镜像\n标准镜像包\n以容器方式交付，确保运行的一致性。（但如x86、armv8、armv7）的差异依然存在。\n\n\n应用部署（I层资源已具备）\nhelm、docker compose\n商用场景多用Helm包，单机伪集群&#x2F;组合方式多用docker compose。\n\n\n应用部署及I层资源创建\nTerraform\n需要交付底层基础设施或云服务的场景，如整个应用运行环境。\n\n\n如果实在要使用私有的格式，可以对标准格式做一些裁剪&#x2F;扩展（Kubernetes的annotation），将标准格式转化到私有格式。\n"}]