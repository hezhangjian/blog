<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hezhangjian.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"normal"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="张俭的博客">
<meta property="og:url" content="https://hezhangjian.com/page/9/index.html">
<meta property="og:site_name" content="张俭的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhangjian He">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hezhangjian.com/page/9/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>张俭的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">张俭的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangjian He</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hezhangjian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/hezhangjian" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/12/Go%20%E4%BD%BF%E7%94%A8Delve%E5%AF%B9Go%E7%A8%8B%E5%BA%8FCoreDump%E8%BF%9B%E8%A1%8CDebug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/Go%20%E4%BD%BF%E7%94%A8Delve%E5%AF%B9Go%E7%A8%8B%E5%BA%8FCoreDump%E8%BF%9B%E8%A1%8CDebug/" class="post-title-link" itemprop="url">Go 使用Delve对Go程序CoreDump进行Debug</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-12 18:53:37" itemprop="dateCreated datePublished" datetime="2021-07-12T18:53:37+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用Delve对Go程序进行Debug"><a href="#使用Delve对Go程序进行Debug" class="headerlink" title="使用Delve对Go程序进行Debug"></a>使用Delve对Go程序进行Debug</h1><h2 id="翻译自"><a href="#翻译自" class="headerlink" title="翻译自"></a>翻译自</h2><p><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-debugging-with-delve-core-dumps-384145b2e8d9">https://medium.com/a-journey-with-go/go-debugging-with-delve-core-dumps-384145b2e8d9</a></p>
<p>CoreDump是异常退出程序的内存快照。可以用来死后debug来找出crash发生的原因以及牵连的变量。通过<code>GOTRACEBACK</code>，<code>Go</code>提供了控制程序崩溃时的输出。变量还可以强制生成CoreDump，使得debug成为可能。</p>
<h2 id="GOTRACEBACK"><a href="#GOTRACEBACK" class="headerlink" title="GOTRACEBACK"></a>GOTRACEBACK</h2><p><code>GOTRACEBACK</code>控制着程序崩溃时的输出，可以取以下的值</p>
<ul>
<li><code>none</code> 不展示任何协程堆栈追踪</li>
<li><code>single</code> 默认选项，打印当前协程堆栈</li>
<li><code>all</code> 展示所有用户创建的协程堆栈</li>
<li><code>system</code> 展示所有协程堆栈，包括go运行时</li>
<li><code>crash</code> 和<code>system</code>相似，不过同时会生成core dump文件</li>
</ul>
<p>最后一个选项给了我们在crash的时候，debug程序的能力。如果您没有获得足够的日志，或者崩溃不可重现，这可能是一个不错的选择。 让我们以下面的程序为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">		n := rand.Intn(<span class="number">1e6</span>)</span><br><span class="line">		sum += n</span><br><span class="line">		<span class="keyword">if</span> sum % <span class="number">42</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;:(&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将很快<code>crash</code></p>
<p><img src="/Images/delve-debug1.png" alt="image-20210712180555586"></p>
<p>我们不能从堆栈看出来什么值导致了crash。添加日志可能是一个解决方案，但是我们不是所有情况都知道在哪里添加日志。当一个问题无法重现时，添加日志只是一个后知后觉，不断寻找的思路。</p>
<p>让我们加上环境变量<code>GOTRACEBACK=crash</code>。由于所有协程和runtime堆栈都会输出，输出更加详细。并且我们还有了coredump文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=all=<span class="string">&quot;-N -l&quot;</span> .</span><br><span class="line"><span class="built_in">export</span> GOTRACEBACK=crash</span><br><span class="line">./core_dump</span><br><span class="line"><span class="comment"># 如果您的core_dump没有生成，可能是coredump size配置为0，如下命令将coredump配置为1MB大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -c 1048576</span><br></pre></td></tr></table></figure>

<p>我们有</p>
<p><img src="/Images/delve-debug2.png" alt="image-20210712183024428"></p>
<p>Core-dump文件可被Go delve或GDB分析</p>
<h2 id="Delve"><a href="#Delve" class="headerlink" title="Delve"></a>Delve</h2><p>安装Delve</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/go-delve/delve/cmd/dlv@latest</span><br></pre></td></tr></table></figure>

<p>Delve 是用 Go 编写的 Go 程序的调试器。 它允许通过在用户代码和运行时的任何位置添加断点来逐步调试，甚至可以使用将二进制文件和CoreDump作为参数的命令 dlv core 调试CoreDump。</p>
<p>通过<code>dlv core core_dump core.2716</code>来调试coredump。然后通过<code>bt</code>命令打印堆栈，并且展示程序造成的<code>panic</code>。</p>
<p><img src="/Images/delve-debug3.png" alt="image-20210712183456364"></p>
<p>我们看到7发生了panic，然后通过<code>frame 9</code>查看第9个堆栈</p>
<p><img src="/Images/delve-debug4.png" alt="image-20210712185150712"></p>
<p>这展示了panic时的代码，然后通过命令<code>locals</code>打印本地变量，帮助我们搞明白什么变量参与了<code>crash</code></p>
<p><img src="/Images/delve-debug5.png" alt="image-20210712185206700"></p>
<p>随机生成的n的值是203300。sum呢？通过<code>vars main</code>来查看main包里的<code>sum</code>的值</p>
<p><img src="/Images/delve-debug6.png" alt="image-20210712185307402"></p>
<p>通过这个就可以推理出，sum的和刚好整除42，导致程序panic</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/12/Go%20%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/Go%20%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">Go 指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-12 11:38:17" itemprop="dateCreated datePublished" datetime="2021-07-12T11:38:17+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go中的指针"><a href="#Go中的指针" class="headerlink" title="Go中的指针"></a>Go中的指针</h1><h2 id="翻译自"><a href="#翻译自" class="headerlink" title="翻译自"></a>翻译自</h2><p><a target="_blank" rel="noopener" href="https://go101.org/article/pointer.html">https://go101.org/article/pointer.html</a></p>
<p>尽管Go吸收了很多其他语言的特性，但Go总体来说是一个C家族语言。其中一个证据就是Go也支持指针。Go指针和C指针在许多方面非常相似，但其中也有一些不同。本文将会列举Go指针的概念和细节。</p>
<h2 id="Memory-Address-内存地址"><a href="#Memory-Address-内存地址" class="headerlink" title="Memory Address 内存地址"></a>Memory Address 内存地址</h2><p>内存地址指的是整个系统管理（通常由操作系统管理）的内存空间中的偏移量（byte的个数）。</p>
<p>通常，内存地址被存储成一个无符号（整型）字。字长在32位机器上是4字节，在64位机器上是8字节。所以理论最大寻址范围，在32位机器上是<br><code>2^32</code>，也就是4GB。在64位机器上是<code>2^64</code>，也就是16EB（1EB&#x3D;1024PB，1PB&#x3D;1024TB，1TB&#x3D;1024GB）。</p>
<p>内存地址通常用Hex表达模式书写，如<code>0x1234CDEF</code></p>
<h2 id="Value-Address-值地址"><a href="#Value-Address-值地址" class="headerlink" title="Value Address 值地址"></a>Value Address 值地址</h2><p>值的地址代表这个值在内存段中的起始地址</p>
<h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p>指针是Go的一种类型。指针用来存储内存地址。跟C语言不同，为了安全的原因，Go指针上有一些限制。</p>
<h2 id="Go指针类型和值"><a href="#Go指针类型和值" class="headerlink" title="Go指针类型和值"></a>Go指针类型和值</h2><p>在Go中，未定义的指针类型可以被写成<code>*T</code>，<code>T</code>可以是任意类型。<code>T</code>是<code>*T</code>的基础类型。</p>
<p>我们也可以自定义指针类型，通常由于未定义指针类型拥有更好的可读性，不推荐使用自定义指针类型。</p>
<p>如果一个定义的指针类型的底层类型（underlying type）是<code>*T</code>，那么该指针的基础类型是<code>T</code>。这个基础类型相同的指针也是同一种类型。样例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未定义的指针类型，基础类型是int</span></span><br><span class="line">*<span class="type">int</span></span><br><span class="line"><span class="comment">// 未定义的指针类型，基础类型是*int</span></span><br><span class="line">**<span class="type">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Ptr是一个定义指针类型，基础类型是int</span></span><br><span class="line"><span class="keyword">type</span> Ptr *<span class="type">int</span> </span><br><span class="line"><span class="comment">// PP是一个定义指针类型，基础类型是Ptr</span></span><br><span class="line"><span class="keyword">type</span> PP *Ptr</span><br></pre></td></tr></table></figure>

<p>指针的零值是<code>nil</code>，不存储任何地址。</p>
<p>基础类型为<code>T</code>的指针仅能存储<code>T</code>类型值的地址</p>
<h2 id="如何获得指针值、什么是可寻址值"><a href="#如何获得指针值、什么是可寻址值" class="headerlink" title="如何获得指针值、什么是可寻址值"></a>如何获得指针值、什么是可寻址值</h2><p>有两种方式可用于获取非nil的指针值</p>
<ul>
<li>go内置的<code>new</code>函数，可以分配任何类型的内存。<code>new(T)</code>在内存中分配一个<code>T</code>值的空间，然后返回<code>T</code>值的地址。分配的值是<code>T</code><br>类型的零值。返回的地址就是一个<code>T</code>类型的指针</li>
<li>我们还可以直接获取可寻址值的地址。对于一个可寻址类型<code>T</code>的值<code>t</code>，我们可以使用<code>&amp;t</code>来获取<code>t</code>的地址，&#96;&amp;操作符用来获取值地址。</li>
</ul>
<p>通常上来说，可寻址值意味着该值存放在内存中的某处。现在，我们只需要知道任何变量都是可寻址的，同时常数、函数调用和显示转换的结果是不可寻址的。变量声明的时候，Go运行时将会为这个变量分配一片内存，这片内存的开始地址就是这个变量的地址。</p>
<h2 id="Pointer-Derefernece-指针解引用"><a href="#Pointer-Derefernece-指针解引用" class="headerlink" title="Pointer Derefernece 指针解引用"></a>Pointer Derefernece 指针解引用</h2><p>对于一个基础类型为<code>T</code>的指针类型<code>p</code>，你如何获取指针中存储的值（或者说，被指针指向的值）？只需要使用表达式<code>*p</code>，<code>*</code><br>被称为解引用操作符。指针的解引用是取地址的逆运算。<code>*p</code>的返回值是<code>T</code>类型，也就是<code>p</code>的基础类型。</p>
<p>对<code>nil</code>指针进行解引用会导致运行时异常。</p>
<p>这个程序展示了地址获取和解引用的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// p0指向int的零值</span></span><br><span class="line">	p0 := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">	<span class="comment">// hex表达的地址</span></span><br><span class="line">	fmt.Println(p0)</span><br><span class="line">	<span class="comment">// 0</span></span><br><span class="line">	fmt.Println(*p0)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// x是p0指向值的拷贝</span></span><br><span class="line">	x := *p0</span><br><span class="line">	<span class="comment">// 都取得x的地址</span></span><br><span class="line">	<span class="comment">// x, *p1, *p2 的值相同</span></span><br><span class="line">	p1, p2 := &amp;x, &amp;x</span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(p1 == p2)</span><br><span class="line">	<span class="comment">// false</span></span><br><span class="line">	fmt.Println(p0 == p1)</span><br><span class="line">	<span class="comment">// p3 和 p0 也存储相同的地址</span></span><br><span class="line">	p3 := &amp;*p0</span><br><span class="line">	fmt.Println(p0 == p3)</span><br><span class="line">	*p0, *p1 = <span class="number">123</span>, <span class="number">789</span></span><br><span class="line">	<span class="comment">// 789 789 123</span></span><br><span class="line">	fmt.Println(*p2, x, *p3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// int, int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T, %T \n&quot;</span>, *p0, x)</span><br><span class="line">	<span class="comment">// *int, *int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T, %T \n&quot;</span>, p0, p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图揭示了上面程序存储的值间关系</p>
<p><img src="/Images/go-pointer1.png" alt="image-20210712093648121"></p>
<h2 id="为什么我们需要指针"><a href="#为什么我们需要指针" class="headerlink" title="为什么我们需要指针"></a>为什么我们需要指针</h2><p>让我们先来看一个样例程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x += x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">	double(a)</span><br><span class="line">	fmt.Println(a) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中的<code>double</code>函数预期对输入值进行双倍处理。但是它失败了。为什么？因为所有值的分配，包括函数参数的传递，都是值拷贝。<code>double</code><br>函数操作的<code>x</code>只是<code>a</code>变量的拷贝，而不是<code>a</code>变量。</p>
<p>修复上例的一种方式是让double函数返回一个新值。但这并不是所有场景都适用。下例展示了另一种使用指针的方案</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*x += *x</span><br><span class="line">    <span class="comment">// 这行只为了解释用途</span></span><br><span class="line">	x = <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">	double(&amp;a)</span><br><span class="line">	fmt.Println(a) <span class="comment">// 6</span></span><br><span class="line">	p := &amp;a</span><br><span class="line">	double(p)</span><br><span class="line">	fmt.Println(a, p == <span class="literal">nil</span>) <span class="comment">// 12 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，通过将参数改为指针类型，传递的指针参数<code>&amp;a</code>和它的拷贝<code>x</code>都指向相同的值，所以在<code>*x</code>上进行的修改，在<code>a</code><br>上也体现了出来。同时，因为参数传递都是值拷贝，上面将<code>x</code>赋值为nil，在p上也不生效。</p>
<p>简而言之，指针提供了操作值的间接方式。大部分语言没有指针的概念。然而，指针的概念只是隐藏在了语言的其他概念中。</p>
<h2 id="返回局部变量指针在Go是安全的"><a href="#返回局部变量指针在Go是安全的" class="headerlink" title="返回局部变量指针在Go是安全的"></a>返回局部变量指针在Go是安全的</h2><p>和C语言不通，Go支持垃圾回收，所以返回局部变量的指针在Go中是绝对安全的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">	a := <span class="number">3</span></span><br><span class="line">	<span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go指针的限制"><a href="#Go指针的限制" class="headerlink" title="Go指针的限制"></a>Go指针的限制</h2><p>为了安全原因，相比C语言来说，Go在指针上做了一些限制。通过这些限制，Go保持了指针带来的收益，并且避免了危险的指针使用。</p>
<h3 id="Go指针不支持算术操作"><a href="#Go指针不支持算术操作" class="headerlink" title="Go指针不支持算术操作"></a>Go指针不支持算术操作</h3><p>在Go中，指针不能进行算术运算。对于指针<code>p</code>，<code>p++</code>和<code>p-2</code>都是非法的。</p>
<p>如果指针p指向一个数值，编译器会将*p++识别为一个合法的语句，并解析为<code>(*p)++</code>。换句话说，<code>*p</code>操作的优先级高于<code>++</code>、<code>--</code>操作符。样例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="type">int64</span>(<span class="number">5</span>)</span><br><span class="line">	p := &amp;a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面的语句无法编译</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	p++</span></span><br><span class="line"><span class="comment">	p = (&amp;a) + 8</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	*p++</span><br><span class="line">	fmt.Println(*p, a)   <span class="comment">// 6 6</span></span><br><span class="line">	fmt.Println(p == &amp;a) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	*&amp;a++</span><br><span class="line">	*&amp;*&amp;a++</span><br><span class="line">	**&amp;p++</span><br><span class="line">	*&amp;*p++</span><br><span class="line">	fmt.Println(*p, a) <span class="comment">// 10 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针值不能转换为任意的指针类型"><a href="#指针值不能转换为任意的指针类型" class="headerlink" title="指针值不能转换为任意的指针类型"></a>指针值不能转换为任意的指针类型</h3><p>在Go中，<code>T1</code>的指针值可以被隐式或是显示地转换为<code>T2</code>，需要满足如下两个条件</p>
<ul>
<li><code>T1</code>和<code>T2</code>的底层类型相同（忽略结构体Tag）。特别地，如果<code>T1</code>和<code>T2</code>都是未定义类型并且它们的底层类型相同（考虑结构体Tag），可以进行隐式转换。</li>
<li><code>T1</code>和<code>T2</code>都是未定义指针类型，并且它们的基础类型的底层类型相同（忽略结构体Tag）</li>
</ul>
<p>举个例子，有如下类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int64</span></span><br><span class="line"><span class="keyword">type</span> Ta *<span class="type">int64</span></span><br><span class="line"><span class="keyword">type</span> Tb *MyInt</span><br></pre></td></tr></table></figure>

<p>有如下事实</p>
<ul>
<li><code>*int64</code>类型的值可以被隐式转换为<code>Ta</code>类型，反过来也是可以的。因为它们的底层类型都是<code>*int64</code></li>
<li><code>*MyInt</code>类型的值可以被隐式转换为<code>Tb</code>类型，反过来也行。因为它们的底层类型都是<code>*MyInt</code></li>
<li><code>*MyInt</code>类型的值可以被限制转换为<code>*int64</code>，反之亦然。因为它们的基础类型的底层类型都是<code>int64</code></li>
<li>即使是显示转换，<code>Ta</code>类型的值也不能直接转换为<code>Tb</code>。因为<code>Ta</code>和底层类型和<code>Tb</code>不同，并且都是定义指针类型。不过可以进行连续几次转换，将<br><code>Ta</code>类型的<code>pa</code>间接转化为<code>Tb</code>类型。 先将<code>pa</code>转化为<code>*int64</code>类型（因为基础类型的底层类型都是<code>int64</code>），再将<code>*int64</code>类型转换为<br><code>*MyInt</code>类型，再将<code>*MyInt</code>类型转化为<code>*Tb</code>类型。<code>Tb((*MyInt)((*int64)(pa)))</code></li>
</ul>
<p>上面的值通过任何安全的手段，都不能转化为类型<code>*uint64</code></p>
<h3 id="任意两个指针的值不能比较"><a href="#任意两个指针的值不能比较" class="headerlink" title="任意两个指针的值不能比较"></a>任意两个指针的值不能比较</h3><p>在Go中，指针可以通过<code>==</code>和<code>!=</code>符号比较。如果满足如下任意一个条件，那么两个Go指针的值可以进行比较</p>
<ul>
<li>两个Go指针类型一致</li>
<li>指针值可以隐式转换为另一类型</li>
<li>两个指针中的一个且仅一个用无类型 nil 标识符表示。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> MyInt <span class="type">int64</span></span><br><span class="line">	<span class="keyword">type</span> Ta    *<span class="type">int64</span></span><br><span class="line">	<span class="keyword">type</span> Tb    *MyInt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4个不同类型的指针零值</span></span><br><span class="line">	<span class="keyword">var</span> pa0 Ta</span><br><span class="line">	<span class="keyword">var</span> pa1 *<span class="type">int64</span></span><br><span class="line">	<span class="keyword">var</span> pb0 Tb</span><br><span class="line">	<span class="keyword">var</span> pb1 *MyInt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这6行都可以正常编译</span></span><br><span class="line">	<span class="comment">// 比较结果都为true</span></span><br><span class="line">    <span class="comment">// 指针可以隐式转换</span></span><br><span class="line">	_ = pa0 == pa1</span><br><span class="line">    <span class="comment">// 指针类型一致</span></span><br><span class="line">	_ = pb0 == pb1</span><br><span class="line">	_ = pa0 == <span class="literal">nil</span></span><br><span class="line">	_ = pa1 == <span class="literal">nil</span></span><br><span class="line">	_ = pb0 == <span class="literal">nil</span></span><br><span class="line">	_ = pb1 == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这三行都不能正常编译</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	_ = pa0 == pb0</span></span><br><span class="line"><span class="comment">	_ = pa1 == pb1</span></span><br><span class="line"><span class="comment">	_ = pa0 == Tb(nil)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针值不能赋值给其他指针类型"><a href="#指针值不能赋值给其他指针类型" class="headerlink" title="指针值不能赋值给其他指针类型"></a>指针值不能赋值给其他指针类型</h3><p>指针值互相赋值的条件和比较的条件一样</p>
<h2 id="有手段打破Go对指针的限制"><a href="#有手段打破Go对指针的限制" class="headerlink" title="有手段打破Go对指针的限制"></a>有手段打破Go对指针的限制</h2><p>unsafe 标准包提供的机制（特别是 unsafe.Pointer 类型）可以用来打破 Go 中对指针的限制。 unsafe.Pointer 类型类似于 C 中的<br>void*。一般不推荐使用<code>unsafe</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/09/Go%20Unsafe%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/09/Go%20Unsafe%E5%8C%85/" class="post-title-link" itemprop="url">Go Unsafe包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-09 22:46:32" itemprop="dateCreated datePublished" datetime="2021-07-09T22:46:32+08:00">2021-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="翻译自"><a href="#翻译自" class="headerlink" title="翻译自"></a>翻译自</h2><p><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-what-is-the-unsafe-package-d2443da36350">https://medium.com/a-journey-with-go/go-what-is-the-unsafe-package-d2443da36350</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>包的名称指引着我们的使用。了解此包可能不安全的原因，让我们首先查看如下文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsafe包包含可以绕过Go程序类型安全的操作</span><br><span class="line">引用了unsafe的包，可能会无法跨平台、跨设备，并且Go1 兼容性指南不保证这些包的兼容</span><br></pre></td></tr></table></figure>

<p>因此，该名称被用作对为 Go 提供类型的安全性的反面。 现在让我们深入研究文档中提到的这两点。</p>
<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>在Go中，每个变量都拥有一个类型，在赋值给另外一个变量之前，可以转换为另外的类型。在此转换期间，Go 执行此数据的转换以适应所请求的类型。 这是一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// -1 二进制表达 11111111</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int8</span> = <span class="number">-1</span></span><br><span class="line">	<span class="comment">// -1 二进制表达 11111111 11111111</span></span><br><span class="line">	<span class="keyword">var</span> j = <span class="type">int16</span>(i)</span><br><span class="line">	<span class="built_in">println</span>(i, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<p><code>unsafe</code>包让我们直接操作这个变量的内存地址，直接获取里面的二进制值。在绕过类型约束时，我们可以随意使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> k <span class="type">uint8</span> = *(*<span class="type">uint8</span>)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="built_in">println</span>(k)</span><br><span class="line"><span class="comment">// 255 is the uint8 value for the binary 11111111</span></span><br></pre></td></tr></table></figure>

<h2 id="Go1-兼容性指南"><a href="#Go1-兼容性指南" class="headerlink" title="Go1 兼容性指南"></a>Go1 兼容性指南</h2><p>unsafe包可能会依赖于Go的底层实现。Go可能会做出破坏性的改动。</p>
<h2 id="Go-反射包中使用Unsafe"><a href="#Go-反射包中使用Unsafe" class="headerlink" title="Go 反射包中使用Unsafe"></a>Go 反射包中使用Unsafe</h2><p><code>reflect</code>包是使用最多的一个包。反射基于空interface包含的数据。为了读取数据，Go只是将我们的变量转化为一个空接口，并通过映射一个结构体来读取它们，该结构体匹配空接口的内部表示与指针地址处的内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unpackEface converts the empty interface i to a Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">   e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">   [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 e 现在包含有关该值的所有信息，例如类型或该值是否已导出。 反射还使用 unsafe 包通过直接在内存中更新值来修改反射变量的值。</p>
<h2 id="Go-Sync包使用Unsafe"><a href="#Go-Sync包使用Unsafe" class="headerlink" title="Go Sync包使用Unsafe"></a>Go Sync包使用Unsafe</h2><p><code>sync.Pool</code> 这些池通过一段go协程都能访问的内存片段来共享数据。这访问模式和C语言数组的访问方式很像</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">   lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">   <span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>l</code>是内存片段，<code>i</code>是数字。函数 <code>indexLocal</code> 只是读取这个内存段——它包含 X个poolLocal 结构——与它读取的索引相关的偏移量。 存储指向完整内存段的单个指针是实现共享池的一种非常轻量的方式。</p>
<h2 id="在Go-runtime包中的使用"><a href="#在Go-runtime包中的使用" class="headerlink" title="在Go runtime包中的使用"></a>在Go runtime包中的使用</h2><p>Go 在<code>runtime</code>包也大量使用 unsafe 包，因为它必须处理内存操作，如栈分配或释放栈内存。 栈由其结构中的两个边界表示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="type">uintptr</span></span><br><span class="line">    hi <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unsafe</code>包可以完成这个操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackfree</span><span class="params">(stk stack)</span></span> &#123;</span><br><span class="line">    [...]</span><br><span class="line">    v := unsafe.Pointer(stk.lo)</span><br><span class="line">    n := stk.hi - stk.lo</span><br><span class="line">    <span class="comment">// 内存基于栈上的指针释放</span></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开发平时使用"><a href="#开发平时使用" class="headerlink" title="开发平时使用"></a>开发平时使用</h2><p><code>unsafe</code>包的一个很好的用法是转换具有相同底层数据结构的不同结构体，这是转换器无法实现的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int8</span></span><br><span class="line">	B <span class="type">string</span></span><br><span class="line">	C <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	D <span class="type">int8</span></span><br><span class="line">	E <span class="type">string</span></span><br><span class="line">	F <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStructConvert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	a := A&#123;A: <span class="number">1</span>, B: <span class="string">`foo`</span>, C: <span class="number">1.23</span>&#125;</span><br><span class="line">	b := *(*B)(unsafe.Pointer(&amp;a))</span><br><span class="line">	<span class="built_in">println</span>(b.D, b.E, b.F) <span class="comment">// 1 foo 1.23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/06/Go%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/Go%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="post-title-link" itemprop="url">Go 定时任务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-06 08:28:50" itemprop="dateCreated datePublished" datetime="2021-07-06T08:28:50+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="不使用三方库"><a href="#不使用三方库" class="headerlink" title="不使用三方库"></a>不使用三方库</h2><h3 id="协程Sleep方式"><a href="#协程Sleep方式" class="headerlink" title="协程Sleep方式"></a>协程Sleep方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello !!&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="使用ticker方式1"><a href="#使用ticker方式1" class="headerlink" title="使用ticker方式1"></a>使用ticker方式1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello !!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for 10 seconds</span></span><br><span class="line">time.Sleep(<span class="number">10</span> *time.Second)</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>

<h3 id="使用ticker方式2"><a href="#使用ticker方式2" class="headerlink" title="使用ticker方式2"></a>使用ticker方式2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            ticker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Hello !!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for 10 seconds</span></span><br><span class="line">time.Sleep(<span class="number">10</span> *time.Second)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53057237/how-to-schedule-a-task-at-go-periodically">https://stackoverflow.com/questions/53057237/how-to-schedule-a-task-at-go-periodically</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%20TCP%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%20TCP%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">网络编程经验总结 TCP拆包粘包常见解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-04 13:23:05" itemprop="dateCreated datePublished" datetime="2021-07-04T13:23:05+08:00">2021-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="从简单通信协议开始"><a href="#从简单通信协议开始" class="headerlink" title="从简单通信协议开始"></a>从简单通信协议开始</h2><p>最近工作中又需要处理协议解析，我对协议解析和网络抓包其实还是小有研究，17年刚毕业的时候，就用Netty手写过SMPP协议的对接。（其实做协议解析是一个很枯燥的工作，如果协议解析可以像antlr那样子写grammar自动解析应该会很酷？）本文总结一下协议在tcp下编码拆包粘包的三种解决方案。</p>
<p>网上有一些人对拆包粘包的说法不是很认可，但是我觉得这个术语还是挺形象的。</p>
<p>首先，让我们来设计一个简单地通信协议，<strong>Sorry</strong>，客户端一直对服务器发送<code>I am Sorry</code>，服务端回复<code>That&#39;s ok</code>。如下图所示</p>
<p><img src="/Images/network-tcp-codec1.png" alt="image-20210704104926698"></p>
<p>让我们来写个demo程序实现这个协议</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1997&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listen.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleRequest(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle incoming requests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">// make a buffer to hold incoming data</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="comment">// Read the incoming connection into the buffer</span></span><br><span class="line">	reqLen, err := conn.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error reading: &quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> reqLen != <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;invalid request size &quot;</span>, reqLen)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;That&#x27;s ok&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error sending: &quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::from_utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> TcpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;localhost:1997&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> stream) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;success connect to 1997&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">msg</span> = <span class="string">b&quot;I am Sorry&quot;</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">expect_resp</span> = <span class="string">b&quot;That&#x27;s ok&quot;</span>;</span><br><span class="line">            stream.<span class="title function_ invoke__">write</span>(msg);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Send hello, awaiting reply&quot;</span>);</span><br><span class="line">            <span class="comment">// use 9 byte buffer</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = [<span class="number">0</span> <span class="keyword">as</span> <span class="type">u8</span>; <span class="number">9</span>];</span><br><span class="line">            <span class="keyword">match</span> stream.<span class="title function_ invoke__">read_exact</span>(&amp;<span class="keyword">mut</span> data) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> &amp;data == expect_resp &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Reply is ok&quot;</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">text</span> = <span class="title function_ invoke__">from_utf8</span>(&amp;data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Unexpected reply: &#123;&#125;&quot;</span>, text);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Failed to receive data: &#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Failed to connect: &#123;&#125;&quot;</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面在服务端的实现中，我们校验了请求体的大小。</p>
<p>运行成功，我们在<code>Wireshark</code>上可以看到</p>
<p><img src="/Images/network-tcp-codec2.png" alt="image-20210704115955993"></p>
<p>目标端口为1997，这是客户端发出的报文。当然也能看到响应的报文</p>
<p><img src="/Images/network-tcp-codec3.png" alt="image-20210704120027704"></p>
<p>那么，如果客户端是个十分礼貌的人，他如果连续发送10个<code>I am Sorry</code>呢？我们将代码修改为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端报错了，服务端收到了一个请求，大小为100。并不是新手预期的10个大小为10的消息，</p>
<p><img src="/Images/network-tcp-codec4.png" alt="image-20210704120639637"></p>
<p>那么实际在网络中是如何传输的呢？一定是1个大小为100的消息吗？答案是否定的。在我的这次测试中，在<code>TCP</code>层，分成了两组消息，第一个大小为10，包含一个<code>I am Sorry</code></p>
<p><img src="/Images/network-tcp-codec5.png" alt="image-20210704120759769"></p>
<p>另一个大小为90，包含9个</p>
<p><img src="/Images/network-tcp-codec6.png" alt="image-20210704120818834"></p>
<h2 id="揭秘时刻"><a href="#揭秘时刻" class="headerlink" title="揭秘时刻"></a>揭秘时刻</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><strong>TCP</strong>和<strong>UDP</strong>不同，它是一个基于流的协议，<strong>TCP</strong>并不识别你定义的协议规则，只负责将这些报文打包发送，它可以基于<code>TCP_NODELAY</code>、<code>Nagle</code>算法等，任意的对你的报文进行切分发送。有两个典型的场景：第一个像上文中的例子，两个及以上的包在一个TCP数据包发送了，有个很形象的名字叫<code>粘包</code>。还有一个，因为报文过大，拆分成两个<code>TCP</code>报文发送，这叫拆包。</p>
<h3 id="应用层读取"><a href="#应用层读取" class="headerlink" title="应用层读取"></a>应用层读取</h3><p>常见API，应用层读取也不保证单次操作一定仅仅读取一个<code>tcp</code>数据包，会根据你提供的buffer大小，尽量提供数据。你读取到的可能是上一个<code>TCP</code>包的末尾和下一个<code>TCP</code>包的开头部分。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>TCP</strong>是基于流的协议，并非基于报文。<strong>TCP</strong>提供了保序的语义保证，这要求应用程序，尤其是接收者，需要能够从报文流中提取出协议信息，<strong>TCP</strong>决不保证读取到的报文恰好是发送者一次<code>write</code>写入的报文，即使能在测试环境通过<code>case</code>，那也只不过是你运气好而已。</p>
<p>像我们上面，读取到100大小的消息。根据协议大小请求固定为10，我们就可以将100消息分割为10条协议报文。如果读取到的大小为96，那就先处理前90个字节，剩下6个字节，待后面4个字节到达之后再合并处理。下一节我们详细介绍一下几种常见方式。</p>
<h2 id="常见TCP协议定义方式"><a href="#常见TCP协议定义方式" class="headerlink" title="常见TCP协议定义方式"></a>常见TCP协议定义方式</h2><h3 id="定长编码"><a href="#定长编码" class="headerlink" title="定长编码"></a>定长编码</h3><p>就像我们例子中的那样一样，定义一个定长宽度，然后切分</p>
<p>使用Go的gnet库的<code>Server</code>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	codec := gnet.NewFixedLengthFrameCodec(<span class="number">10</span>)</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(codec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于分隔符"><a href="#基于分隔符" class="headerlink" title="基于分隔符"></a>基于分隔符</h3><p>基于分隔符的编码也十分容易理解，双方约定好一个字符，并在正常报文中不出现这个字符（出现则需要转义），比较类似的是以太网的<code>7d7d</code>?这个计算机网络链路层相关的知乎，学太久了，忘记了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	codec := gnet.NewDelimiterBasedFrameCodec(<span class="number">0x11</span>)</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(codec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于固定行数的编码"><a href="#基于固定行数的编码" class="headerlink" title="基于固定行数的编码"></a>基于固定行数的编码</h3><p>这个也很简单，协议内容不换行，发送完再发送一个换行符，比较类似的有HTTP的<code>\r\n</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(&amp;gnet.LineBasedFrameCodec&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="长度编码"><a href="#长度编码" class="headerlink" title="长度编码"></a>长度编码</h3><p>长度编码是使用最多的，最流行的一种编码方式。最简单的一种工作方式是，在报文的最开始数个字节（常见为4个字节，足以编码4个G长度，相比之下两个字节仅能存放64K消息），声明报文剩余内容的长度。以<code>Kafka</code>协议举例</p>
<p><img src="/Images/network-tcp-codec7.png" alt="image-20210704125652379"></p>
<p>Kafka这条消息，在<strong>TCP</strong>层占据的总长度为87字节，其中前4个字节<code>00 00 00 53</code>声明为83长度，为其余报文的长度。</p>
<p>这一模式还有很多变体，如</p>
<ul>
<li>声明的长度包括其长度字段本身的长度</li>
<li>长度字段并不是打头的字段</li>
<li>长度字段的长度</li>
</ul>
<p>等等。这也就是下面解码器，拥有的参数非常多的原因，都是为了适配这些变体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	encoderConfig := gnet.EncoderConfig&#123;</span><br><span class="line">		ByteOrder:                       binary.BigEndian,</span><br><span class="line">		LengthFieldLength:               <span class="number">4</span>,</span><br><span class="line">		LengthAdjustment:                <span class="number">0</span>,</span><br><span class="line">		LengthIncludesLengthFieldLength: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	decoderConfig := gnet.DecoderConfig&#123;</span><br><span class="line">		ByteOrder:           binary.BigEndian,</span><br><span class="line">		LengthFieldOffset:   <span class="number">0</span>,</span><br><span class="line">		LengthFieldLength:   <span class="number">4</span>,</span><br><span class="line">		LengthAdjustment:    <span class="number">-4</span>,</span><br><span class="line">		InitialBytesToStrip: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	codec := gnet.NewLengthFieldBasedFrameCodec(encoderConfig, decoderConfig)</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(codec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，长度字段编码格式是我见过开源代码使用最多的格式，像MQTT、KAFKA、SMPP等都使用这种格式。其中原因，个人觉得在于声明长度之后，buffer申请及释放，可以简化很多，性能最好。</p>
<h2 id="其他网络协议使用的编码方式"><a href="#其他网络协议使用的编码方式" class="headerlink" title="其他网络协议使用的编码方式"></a>其他网络协议使用的编码方式</h2><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>使用长度字段编码格式</p>
<p><img src="/Images/network-tcp-codec8.png" alt="image-20210704131034560"></p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP的解析较为麻烦，它根据协议目前的状态，同时使用定长编码和长度字段两种编码方式。这就要求解码器不仅仅要处理报文，还要处理当前协议交互到那个状态了。</p>
<h4 id="定长场景"><a href="#定长场景" class="headerlink" title="定长场景"></a>定长场景</h4><p><img src="/Images/network-tcp-codec9.png" alt="image-20210704131231757"></p>
<h4 id="长度字段模式"><a href="#长度字段模式" class="headerlink" title="长度字段模式"></a>长度字段模式</h4><p><img src="/Images/network-tcp-codec10.png" alt="image-20210704131317098"></p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><ul>
<li>Go代码: <a target="_blank" rel="noopener" href="https://github.com/hezhangjian/go_demo/tree/main/demo_gnet/codec">https://github.com/hezhangjian/go_demo/tree/main/demo_gnet/codec</a></li>
<li>Rust代码:<a target="_blank" rel="noopener" href="https://github.com/hezhangjian/rust-demo/blob/main/demo-tcp-client/src/main.rs">https://github.com/hezhangjian/rust-demo/blob/main/demo-tcp-client/src/main.rs</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/04/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAfilebeat%20output%20websocket%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/filebeat-output-websocket" class="post-title-link post-title-link-external" itemprop="url">开发一个filebeat output websocket插件<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-04 09:38:39" itemprop="dateCreated datePublished" datetime="2021-07-04T09:38:39+08:00">2021-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>开发一个filebeat的<code>websocket</code>插件， 代码仓地址: <a target="_blank" rel="noopener" href="https://github.com/hezhangjian/beats_output_websocket">https://github.com/hezhangjian/beats_output_websocket</a></p>
<h2 id="引入对beat的依赖"><a href="#引入对beat的依赖" class="headerlink" title="引入对beat的依赖"></a>引入对<code>beat</code>的依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/elastic/beats/v7</span><br></pre></td></tr></table></figure>

<h2 id="定义在filebeat中的配置文件"><a href="#定义在filebeat中的配置文件" class="headerlink" title="定义在filebeat中的配置文件"></a>定义在filebeat中的配置文件</h2><p><code>filebeat</code>通常以配置文件的方式加载插件。让我们定义一下必须的配置，就像<code>elasticsearch</code>中的连接地址等等一样。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.websocket:</span></span><br><span class="line">  <span class="comment"># worker</span></span><br><span class="line">  <span class="comment"># 用于工作的websocket客户端数量</span></span><br><span class="line">  <span class="attr">workers:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 日志批量的最大大小</span></span><br><span class="line">  <span class="attr">batch_size:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试的最大次数，0代表不重试</span></span><br><span class="line">  <span class="attr">retry_limit:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># conn</span></span><br><span class="line">  <span class="comment"># ws/wss</span></span><br><span class="line">  <span class="attr">schema:</span> <span class="string">&quot;ws&quot;</span></span><br><span class="line">  <span class="comment"># websocket连接地址</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">  <span class="comment"># websocket路径</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&quot;/echo&quot;</span></span><br><span class="line">  <span class="comment"># websocket心跳间隔，用于保活</span></span><br><span class="line">  <span class="attr">ping_interval:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="go文件中的配置"><a href="#go文件中的配置" class="headerlink" title="go文件中的配置"></a>go文件中的配置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Number of worker goroutines publishing log events</span></span><br><span class="line">	Workers <span class="type">int</span> <span class="string">`config:&quot;workers&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line">	<span class="comment">// Max number of events in a batch to send to a single client</span></span><br><span class="line">	BatchSize <span class="type">int</span> <span class="string">`config:&quot;batch_size&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line">	<span class="comment">// Max number of retries for single batch of events</span></span><br><span class="line">	RetryLimit <span class="type">int</span> <span class="string">`config:&quot;retry_limit&quot;`</span></span><br><span class="line">	<span class="comment">// Schema WebSocket Schema</span></span><br><span class="line">	Schema <span class="type">string</span> <span class="string">`config:&quot;schema&quot;`</span></span><br><span class="line">	<span class="comment">// Addr WebSocket Addr</span></span><br><span class="line">	Addr <span class="type">string</span> <span class="string">`config:&quot;addr&quot;`</span></span><br><span class="line">	<span class="comment">// Path WebSocket Path</span></span><br><span class="line">	Path <span class="type">string</span> <span class="string">`config:&quot;path&quot;`</span></span><br><span class="line">	<span class="comment">// PingInterval WebSocket PingInterval</span></span><br><span class="line">	PingInterval <span class="type">int</span> <span class="string">`config:&quot;ping_interval&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始化加载插件"><a href="#初始化加载插件" class="headerlink" title="初始化加载插件"></a>初始化加载插件</h2><h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>在某个init函数中注册插件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	outputs.RegisterType(<span class="string">&quot;websocket&quot;</span>, newWsOutput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>newWsOutput</code>中卸载配置，并提供配置给<code>WebSocket</code>客户端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWsOutput</span><span class="params">(_ outputs.IndexManager, _ beat.Info, stats outputs.Observer, cfg *common.Config)</span></span> (outputs.Group, <span class="type">error</span>) &#123;</span><br><span class="line">	config := clientConfig&#123;&#125;</span><br><span class="line">	<span class="comment">// 卸载配置，将配置用于初始化WebSocket客户端</span></span><br><span class="line">	<span class="keyword">if</span> err := cfg.Unpack(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> outputs.Fail(err)</span><br><span class="line">	&#125;</span><br><span class="line">	clients := <span class="built_in">make</span>([]outputs.NetworkClient, config.Workers)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; config.Workers; i++ &#123;</span><br><span class="line">		clients[i] = &amp;wsClient&#123;</span><br><span class="line">			stats:  stats,</span><br><span class="line">			Schema: config.Schema,</span><br><span class="line">			Host:   config.Addr,</span><br><span class="line">			Path:   config.Path,</span><br><span class="line">			PingInterval: config.PingInterval,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> outputs.SuccessNet(<span class="literal">true</span>, config.BatchSize, config.RetryLimit, clients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化WebSocket客户端"><a href="#初始化WebSocket客户端" class="headerlink" title="初始化WebSocket客户端"></a>初始化<code>WebSocket</code>客户端</h2><p><code>WebSocket</code>客户端不仅仅是一个<code>WebSocket</code>客户端，而且还需要实现<code>filebeat</code>中的<code>NetworkClient</code>接口，接下来，让我们来关注接口中的每一个方法的作用及实现</p>
<h3 id="String-接口"><a href="#String-接口" class="headerlink" title="String()接口"></a>String()接口</h3><p><code>String</code>作为客户端的名字，用来标识日志以及指标。是最简单的一个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;websocket&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Connect-接口"><a href="#Connect-接口" class="headerlink" title="Connect()接口"></a>Connect()接口</h3><p><code>Connect</code>用来初始化客户端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> Connect() <span class="type">error</span> &#123;</span><br><span class="line">	u := url.URL&#123;Scheme: w.Schema, Host: w.Host, Path: w.Path&#125;</span><br><span class="line">	dial, _, err := websocket.DefaultDialer.Dial(u.String(), <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		w.conn = dial</span><br><span class="line">		ticker := time.NewTicker(time.Duration(w.PingInterval) * time.Second)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">				w.conn.WriteMessage(websocket.PingMessage, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里初始化失败，需要<code>Sleep</code>一段时间，否则，filebeat会一直重试。这绝非是你想要的。或许对于场景来说，退避重试可能会更好</p>
<h3 id="Close-接口"><a href="#Close-接口" class="headerlink" title="Close()接口"></a>Close()接口</h3><p>关闭客户端，也是很简单的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Publish-接口"><a href="#Publish-接口" class="headerlink" title="Publish()接口"></a>Publish()接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> Publish(_ context.Context, batch publisher.Batch) <span class="type">error</span> &#123;</span><br><span class="line">	events := batch.Events()</span><br><span class="line">	<span class="comment">// 记录这批日志</span></span><br><span class="line">	w.stats.NewBatch(<span class="built_in">len</span>(events))</span><br><span class="line">	failEvents, err := w.PublishEvents(events)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果发送正常，则ACK</span></span><br><span class="line">		batch.ACK()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 发送失败，则重试。受RetryLimit的限制</span></span><br><span class="line">		batch.RetryEvents(failEvents)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> PublishEvents(events []publisher.Event) ([]publisher.Event, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		err := w.publishEvent(&amp;event)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果单条消息发送失败，则将剩余的消息直接重试</span></span><br><span class="line">			<span class="keyword">return</span> events[i:], err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> publishEvent(event *publisher.Event) <span class="type">error</span> &#123;</span><br><span class="line">	bytes, err := encode(&amp;event.Content)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果编码失败，就不重试了，重试也不会成功</span></span><br><span class="line">		<span class="comment">// encode error, don&#x27;t retry.</span></span><br><span class="line">		<span class="comment">// consider being success</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = w.conn.WriteMessage(websocket.TextMessage, bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 写入WebSocket Server失败</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码的逻辑因人而异，事实上，这可能是大家最大的差异所在。这里只是做一个简单地例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">	Timestamp time.Time <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">	Message   <span class="type">string</span>    <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(event *beat.Event)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	logOutput := &amp;LogOutput&#123;&#125;</span><br><span class="line">	value, err := event.Fields.GetValue(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	logOutput.Timestamp = event.Timestamp</span><br><span class="line">	logOutput.Message = value.(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">return</span> json.Marshal(logOutput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后是我们的wsclient"><a href="#最后是我们的wsclient" class="headerlink" title="最后是我们的wsclient"></a>最后是我们的<code>wsclient</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wsClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// construct field</span></span><br><span class="line">	Schema       <span class="type">string</span></span><br><span class="line">	Host         <span class="type">string</span></span><br><span class="line">	Path         <span class="type">string</span></span><br><span class="line">	PingInterval <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	stats outputs.Observer</span><br><span class="line">	conn  *websocket.Conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加额外的功能：大包丢弃"><a href="#添加额外的功能：大包丢弃" class="headerlink" title="添加额外的功能：大包丢弃"></a>添加额外的功能：大包丢弃</h2><p>你可能会想保护你的<code>WebSocket</code>服务器，避免接收到超级大的日志。我们可以在配置项中添加一个配置</p>
<p>maxLen用来限制日志长度，超过maxLen的日志直接丢弃。为什么不使用<code>filebeat</code>中的<code>max_bytes</code>？</p>
<p>因为<code>filebeat</code>中<code>max_bytes</code>的默认行为是截断，截断的日志在某些场景下不如丢弃。（比如，日志是json格式，截断后格式无法解析）</p>
<h3 id="配置中添加maxLen"><a href="#配置中添加maxLen" class="headerlink" title="配置中添加maxLen"></a>配置中添加maxLen</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_len:</span> <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>省略掉那些重复的添加结构体，读取<code>max_len</code>在encode的时候忽略掉</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := value.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt;= w.MaxLen &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/02/Go%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/02/Go%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Go 内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-02 14:28:45" itemprop="dateCreated datePublished" datetime="2021-07-02T14:28:45+08:00">2021-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></p>
<h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><ul>
<li>协程之间的数据可见性满足HappensBefore法则，并具有传递性</li>
<li>如果包 p 导入包 q，则 q 的 init 函数的完成发生在任何 p 的操作开始之前</li>
<li>main.main 函数的启动发生在所有 init 函数完成之后</li>
<li><code>go</code>语句启动新的协程发生在新协程启动开始之前</li>
<li><code>go</code>协程的退出并不保证发生在任何事件之前</li>
<li><code>channel</code>上的发送发生在对应<code>channel</code>接收之前</li>
<li>无buffer<code>channel</code>的接收发生在发送操作完成之前</li>
<li>对于容量为C的buffer channel来说，第k次从channel中接收，发生在第<code>k + C</code>次发送完成之前。</li>
<li>对于任何的<code>sync.Mutex</code>或者<code>sync.RWMutex</code>变量<code>，且有</code>n&lt;m<code>，第</code>n<code>个调用</code>UnLock<code>一定发生在</code>m<code>个</code>Lock&#96;之前。</li>
<li>从 once.Do(f) 对 f() 的单个调用返回在任何一个 once.Do(f) 返回之前。</li>
<li>如果两个动作不满足HappensBefore，则顺序无法预测</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go内存模型指定了在何种条件下可以保证在一个 goroutine 中读取变量时观察到不同 goroutine 中写入该变量的值。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>通过多个协程并发修改数据的程序必须将操作序列化。为了序列化访问，通过channel操作或者其他同步原语（<code>sync</code>、<code>sync/atomic</code>）来保护数据。</p>
<p>如果你必须要阅读本文的其他部分才能理解你程序的行为，请尽量不要这样…</p>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><p>在单个 <code>goroutine</code> 中，读取和写入的行为必须像按照程序指定的顺序执行一样。 也就是说，只有当重新排序不会改变语言规范定义的 goroutine 中的行为时，编译器和处理器才可以重新排序在单个 goroutine 中执行的读取和写入。 由于这种重新排序，一个 goroutine 观察到的执行顺序可能与另一个 goroutine 感知的顺序不同。 例如，如果一个 goroutine 执行 a &#x3D; 1; b &#x3D; 2;，另一个可能会在 a 的更新值之前观察到 b 的更新值。</p>
<p>为了满足读写的需求，我们定义了<code>happens before</code>，Go程序中内存操作的局部顺序。如果事件<code>e1</code>在<code>e2</code>之前发生，我们说<code>e2</code>在<code>e1</code>之后发生。还有，如果<code>e1</code>不在<code>e2</code>之前发生、<code>e2</code>也不在<code>e1</code>之前发生，那么我们说<code>e1</code>和<code>e2</code>并发happen。</p>
<p>在单个<code>goroutine</code>中，<code>happens-before</code>顺序由程序指定。</p>
<p>当下面两个条件满足时，变量<code>v</code>的阅读操作<code>r</code>就<strong>可能</strong>观察到写入操作<code>w</code></p>
<ul>
<li><code>r</code>不在<code>w</code>之前发生</li>
<li>没有其他的请求<code>w2</code>发生在<code>w</code>之后，<code>r</code>之前</li>
</ul>
<p>为了保证<code>r</code>一定能阅读到<code>v</code>，保证<code>w</code>是<code>r</code>能观测到的唯一的写操作。当下面两个条件满足时，<code>r</code>保证可以读取到<code>w</code></p>
<ul>
<li><code>w</code>在<code>r</code>之前发生</li>
<li>任何其他对共享变量<code>v</code>的操作，要么在<code>w</code>之前发生，要么在<code>r</code>之后发生</li>
</ul>
<p>这一对条件比上一对条件更强；这要求无论是<code>w</code>还是<code>r</code>，都没有相应的并发操作。</p>
<p>在单个<code>goroutine</code>中，没有并发。所以这两个定义等价：读操作<code>r</code>能读到最近一次<code>w</code>写入<code>v</code>的值。但是当多个<code>goroutine</code>访问共享变量时，它们必须使用同步事件来建立<code>happens-before</code>关系。</p>
<p>使用变量<code>v</code>类型的0值初始化变量<code>v</code>的行为类似于内存模型中的写入。</p>
<p>对于大于单个机器字长的值的读取和写入表现为未指定顺序的对多个机器字长的操作。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>程序初始化在单个 goroutine 中运行，但该 goroutine 可能会创建其他并发运行的 goroutine。</p>
<p><strong>如果包 p 导入包 q，则 q 的 init 函数的完成发生在任何 p 的操作开始之前。</strong></p>
<p><strong>main.main 函数的启动发生在所有 init 函数完成之后。</strong></p>
<h3 id="Go协程的创建"><a href="#Go协程的创建" class="headerlink" title="Go协程的创建"></a>Go协程的创建</h3><p><strong><code>go</code>语句启动新的协程发生在新协程启动开始之前。</strong></p>
<p>举个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>hello</code>将会打印<code>hello, world</code>。当然，这个时候<code>hello</code>可能已经返回了。</p>
<h3 id="Go协程的销毁"><a href="#Go协程的销毁" class="headerlink" title="Go协程的销毁"></a>Go协程的销毁</h3><p><strong><code>go</code>协程的退出并不保证发生在任何事件之前</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">&quot;hello&quot;</span> &#125;()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 a 的赋值之后没有任何同步事件，因此不能保证任何其他 goroutine 都会观察到它。 事实上，激进的编译器可能会删除整个 go 语句。</p>
<p>如果一个 goroutine 的效果必须被另一个 goroutine 观察到，请使用同步机制，例如锁或通道通信来建立相对顺序。</p>
<h3 id="通道通信"><a href="#通道通信" class="headerlink" title="通道通信"></a>通道通信</h3><p>通道通信是在go协程之间传输数据的主要手段。在特定通道上的发送总有一个对应的channel的接收，通常是在另外一个协程。</p>
<p><strong><code>channel</code>上的发送发生在对应<code>channel</code>接收之前</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序能保证输出<code>hello, world</code>。对a的写入发生在往<code>c</code>发送数据之前，往<code>c</code>发送数据又发生在从<code>c</code>接收数据之前，它又发生在<code>print</code>之前。</p>
<p><strong><code>channel</code>的关闭发生在从<code>channel</code>中获取到0值之前</strong></p>
<p>在之前的例子中，将<code>c&lt;-0</code>替换为<code>close(c)</code>，程序还是能保证输出<code>hello, world</code></p>
<p><strong>无buffer<code>channel</code>的接收发生在发送操作完成之前</strong><br>这个程序，和之前一样，但是调换发送和接收操作，并且使用无buffer的channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也保证能够输出<code>hello, world</code>。对a的写入发生在c的接收之前，继而发生在c的写入操作完成之前，继而发生在print之前。</p>
<p>如果该<code>channel</code>是buffer<code>channel</code>（例如：<code>c=make(chan int, 1)</code>），那么程序就不能保证输出<code>hello, world</code>。可能会打印空字符串、崩溃等等。从而，我们得到一个相对通用的推论：</p>
<p><strong>对于容量为C的buffer channel来说，第k次从channel中接收，发生在第<code>k + C</code>次发送完成之前。</strong></p>
<p>此规则将先前的规则推广到缓冲通道。 它允许通过buffer channel 来模拟信号量：通道中的条数对应活跃的数量，通道的容量对应于最大并发数。向channel发送数据相当于获取信号量，从channel中接收数据相当于释放信号量。 这是限制并发的常用习惯用法。</p>
<p>该程序为工作列表中的每个条目启动一个 goroutine，但是 goroutine 使用<code>limit</code>channel进行协调，以确保一次最多三个work函数正在运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">			limit &lt;- <span class="number">1</span></span><br><span class="line">			w()</span><br><span class="line">			&lt;-limit</span><br><span class="line">		&#125;(w)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><code>sync</code>包中实现了两种锁类型：<code>sync.Mutex</code>和<code>sync.RWMutex</code></p>
<p><strong>对于任何的<code>sync.Mutex</code>或者<code>sync.RWMutex</code>变量<code>，且有</code>n&lt;m<code>，第</code>n<code>个调用</code>UnLock<code>一定发生在</code>m<code>个</code>Lock&#96;之前。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序也保证输出<code>hello,world</code>。第一次调用<code>unLock</code>一定发生在第二次<code>Lock</code>调用之前</p>
<p><strong>对于任何<code>sync.RWMutex</code>的<code>RLock</code>方法调用，存在变量n，满足<code>RLock</code>方法发生在第<code>n</code>个<code>UnLock</code>调用之后，并且对应的<code>RUnlock</code>发生在第<code>n+1</code>个<code>Lock</code>方法之前。</strong></p>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>在存在多个 goroutine 时，<code>sync</code>包通过<code>once</code>提供了一种安全的初始化机制。对于特定的<code>f</code>，多个线程可以执行<code>once.Do(f)</code>，但是只有一个会运行<code>f()</code>，另一个调用会阻塞，直到<code>f()</code>返回</p>
<p><strong>从 once.Do(f) 对 f() 的单个调用返回在任何一个 once.Do(f) 返回之前。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(setup)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 twoprint 将只调用一次 setup。 <code>setup</code>函数将在任一打印调用之前完成。 结果将是<code>hello, world</code>打印两次。</p>
<h2 id="不正确的同步"><a href="#不正确的同步" class="headerlink" title="不正确的同步"></a>不正确的同步</h2><p>注意，读取<code>r</code>有可能观察到了由写入<code>w</code>并发写入的值。尽管观察到了这个值，也并不意味着<code>r</code>后续的读取可以读取到<code>w</code>之前的写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有可能<code>g</code>会接连打印2和0两个值。</p>
<p>双检查锁是为了降低同步造成的开销。举个例子，<code>twoprint</code>方法可能会被误写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !done &#123;</span><br><span class="line">		once.Do(setup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有任何机制保证，协程观察到done为true的同时可以观测到a为<code>hello, world</code>,其中有一个<code>doprint</code>可能会输出空字符。</p>
<p>另外一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和以前一样，不能保证在 main 中，观察对 done 的写入意味着观察对 a 的写入，因此该程序也可以打印一个空字符串。 更糟糕的情况下，由于两个线程之间没有同步事件，因此无法保证 main 会观察到对 done 的写入。 main 中的循环会一直死循环。</p>
<p>下面是该例子的一个更微妙的变体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := <span class="built_in">new</span>(T)</span><br><span class="line">	t.msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管<code>main</code>观测到g不为nil，但是也没有任何机制保证可以读取到t.msg。</p>
<p>在上述例子中，解决方案都是相同的：请使用显式的同步机制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/01/Go%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/01/Go%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Go 编译流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-01 13:19:53" itemprop="dateCreated datePublished" datetime="2021-07-01T13:19:53+08:00">2021-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/cmd/compile/README.md">https://github.com/golang/go/blob/master/src/cmd/compile/README.md</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889">https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889</a></li>
<li>基于Golang 1.16版本</li>
</ul>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>Go编译器由四个阶段组成，可以分为两类</p>
<ul>
<li>frontend前端：这一阶段对源码进行语法解析，并生成AST</li>
<li>backend后端：这一阶段将把transform the representation of the source code into machine code, 并进行数项优化</li>
</ul>
<p>为了更好地理解每个阶段，让我们使用如下的示例程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">		add(a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1-解析"><a href="#P1-解析" class="headerlink" title="P1 解析"></a>P1 解析</h2><ul>
<li><code>cmd/compile/internal/syntax</code> 词法，解析器，语法树</li>
</ul>
<p>第一个阶段非常简单直接：</p>
<p>第一阶段，源码经过词法分析、语法解析，对每个源码文件，都构造出相应的语法树</p>
<p>Lexer首先运行，把源代码转化为词法单元。我们可以通过这个程序来自己模拟运行Lexer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;go/scanner&quot;</span></span><br><span class="line">	<span class="string">&quot;go/token&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// src is the input that we want to tokenize.</span></span><br><span class="line">	src, _ := ioutil.ReadFile(<span class="string">`main.go`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the scanner</span></span><br><span class="line">	<span class="keyword">var</span> s scanner.Scanner</span><br><span class="line">	<span class="comment">// positions are relative to fSet</span></span><br><span class="line">	fSet := token.NewFileSet()</span><br><span class="line">	file := fSet.AddFile(<span class="string">&quot;&quot;</span>, fSet.Base(), <span class="built_in">len</span>(src))</span><br><span class="line">	<span class="comment">// nil means no error handler</span></span><br><span class="line">	s.Init(file, src, <span class="literal">nil</span>, scanner.ScanComments)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Repeated calls to Scan yield the token sequence found in the input</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		pos, tok, lit := s.Scan()</span><br><span class="line">		<span class="keyword">if</span> tok == token.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\t%s\t%q\n&quot;</span>, fSet.Position(pos), tok, lit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>截选输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1:1	package	&quot;package&quot;</span><br><span class="line">1:9	IDENT	&quot;main&quot;</span><br><span class="line">1:13	;	&quot;\n&quot;</span><br><span class="line">3:1	func	&quot;func&quot;</span><br><span class="line">3:6	IDENT	&quot;main&quot;</span><br><span class="line">3:10	(	&quot;&quot;</span><br><span class="line">3:11	)	&quot;&quot;</span><br><span class="line">3:13	&#123;	&quot;&quot;</span><br><span class="line">4:2	IDENT	&quot;a&quot;</span><br><span class="line">4:4	:=	&quot;&quot;</span><br><span class="line">4:7	INT	&quot;1&quot;</span><br><span class="line">4:8	;	&quot;\n&quot;</span><br><span class="line">5:2	IDENT	&quot;b&quot;</span><br><span class="line">5:4	:=	&quot;&quot;</span><br><span class="line">5:7	INT	&quot;2&quot;</span><br><span class="line">5:8	;	&quot;\n&quot;</span><br><span class="line">6:2	if	&quot;if&quot;</span><br><span class="line">6:5	IDENT	&quot;true&quot;</span><br><span class="line">6:10	&#123;	&quot;&quot;</span><br><span class="line">7:3	IDENT	&quot;add&quot;</span><br><span class="line">7:6	(	&quot;&quot;</span><br><span class="line">7:7	IDENT	&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>一旦经过词法化，源码被解析构造成语法树。</p>
<p>语法树还包含了代码位置信息，该信息可用于debug或错误报告。</p>
<h2 id="P2-类型检查和AST转化"><a href="#P2-类型检查和AST转化" class="headerlink" title="P2 类型检查和AST转化"></a>P2 类型检查和AST转化</h2><ul>
<li><code>cmd/compile/internal/gc</code> 创建编译器AST，类型检查，AST转换</li>
</ul>
<p>AST是类型检查的。第一个步骤就是名字解析和类型推断，确定对象和标识符的对应关系，表达式是何种类型。Type-checking这一阶段还引入了额外的确定性步骤，例如，“声明未使用”、函数是否终止等。</p>
<p>还有一些确定的转换也在AST阶段完成。一些节点会根据类型信息进行细化，比如字符串加法从算术加法节点中分离出来。其他一些示例是不可达代码清除、内联函数调用、逃逸分析。</p>
<p>转化到AST的步骤可以通过命令<code>go tool compile -w</code>来展示出来，如果加上-l，则可以禁用内联。在我们的样例代码中，如果不禁用内联，add方法会被内联掉。我们可以分别使用<code>go tool compile -w example.o</code>和<code>go tool compile -w -l example.o</code>进行对比</p>
<p>禁用了内联的命令，会输出这样的AST</p>
<p><img src="/Images/go-compile-process1.png" alt="image-20210701110847543"></p>
<p>没禁用内联的命令则不会生成，这里可以看出来，编译器做了内联的优化。</p>
<h2 id="SSA-生成"><a href="#SSA-生成" class="headerlink" title="SSA 生成"></a>SSA 生成</h2><h3 id="SSA-概念"><a href="#SSA-概念" class="headerlink" title="SSA 概念"></a>SSA 概念</h3><ul>
<li><code>cmd/compile/internal/gc</code> AST转化到SSA</li>
<li><code>cmd/compile/internal/ssa</code> SSA阶段和规则</li>
</ul>
<p>在这个阶段，AST转化为SSA的格式，这是一种具有特定属性的更底层的IR，可以更轻松地在上面进行优化并最终生成机器码。阶段应用了内联函数。这些是编译器被教导要根据具体情况用高度优化的代码替换的特殊函数。在AST到SSA的转换期间，某些确定的节点也被降低为更简单的组件，使得编译器的其余部分可以使用它们。例如，内置的copy函数被内存移动取代、范围循环被重写为for循环。由于历史原因，其中一些目前在SSA转换之前发生，但长期计划是将它们全部移到这里。</p>
<p>然后，应用一系列的、机器无关的阶段和规则。这些不涉及任何的计算机架构，因此可以在任何<code>GOARCH</code>变体上运行。</p>
<p>这些通用的阶段包括：不可达代码清除、删除不需要的nil检查、移除无用的分支。</p>
<p>通用的重写规则主要涉及表达式，包括表达式替换为常量、优化乘法和浮点运算等。</p>
<p>SSA code可以用这个命令<code>dump</code>并展示出来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOSSAFUNC=main go tool compile main.go &amp;&amp; open ssa.html</span><br></pre></td></tr></table></figure>

<h3 id="SSA阶段"><a href="#SSA阶段" class="headerlink" title="SSA阶段"></a>SSA阶段</h3><p><img src="/Images/go-compile-process2.png" alt="Go编译流程"></p>
<h3 id="SSA优化解析"><a href="#SSA优化解析" class="headerlink" title="SSA优化解析"></a>SSA优化解析</h3><p>start Tab上生成了最开始的SSA</p>
<p><img src="/Images/go-compile-process3.png" alt="image-20210701101016958"></p>
<p>变量 a 和 b 与 if 条件一起在此处突出显示，以便我们稍后查看这些行是如何更改的。 代码还向我们展示了编译器如何管理 <code>println</code><br>函数，它被分解为 4 个步骤：<code>printlock</code>、<code>printint</code>、<code>printnl</code>、<code>printunlock</code>。 编译器会自动为我们加锁，并根据参数的类型调用相关方法正确打印。<br>在我们的示例中，由于 a 和 b 在编译时已知，编译器可以计算最终结果并将变量标记为不再需要。  <code>opt</code>阶段 会优化这部分：</p>
<p><img src="/Images/go-compile-process4.png" alt="image-20210701101445933"></p>
<p>这个阶段v7被优化计算成了3。并且接下来，因为v4和v5已经没有人声明使用，在<code>opt deadcode</code>阶段，v4和v5也会被清除掉</p>
<p><img src="/Images/go-compile-process5.png" alt="image-20210701101729496"></p>
<p>等待所有阶段完成之后，Go编译器将会生成中间汇编语言</p>
<p><img src="/Images/go-compile-process6.png" alt="image-20210701102735403"></p>
<p>下一阶段会将汇编语言转换为二进制文件</p>
<h2 id="机器代码生成"><a href="#机器代码生成" class="headerlink" title="机器代码生成"></a>机器代码生成</h2><ul>
<li><code>cmd/compile/internal/ssa</code> SSA “lowering” 和 特定arch的阶段</li>
<li><code>cmd/internal/obj</code> 机器语言生成</li>
</ul>
<p>机器相关的编译阶段从”lowering”阶段开始，它将通用的值替换成机器特定的变体。例如，在 amd64 内存操作数上是可能的，因此可以组合许多加载-存储操作。</p>
<p>注意这些底层阶段执行了所有机器特定的规则，所以也应用了很多优化。</p>
<p>一旦SSA被”lowered”到更特定的目标架构，就开始执行最终的代码优化。这包括另一个不可达代码清除阶段、将值更靠近它们的使用者、移除从未使用的本地变量、寄存器分配。</p>
<p>还有一部分重要工作包括堆栈帧布局，它将堆栈偏移分配给局部变量，以及指针存活分析，它计算每个 GC 安全点上哪些堆栈上指针是活跃的。</p>
<p>在 SSA 生成阶段结束时，Go 函数已转换为一系列 obj.Prog 指令。 这些被传递给汇编器（cmd&#x2F;internal&#x2F;obj），汇编器将它们转换成机器代码并写出最终的目标文件。<br>目标文件还将包含反射数据、导出数据和调试信息。</p>
<p>我们可以使用<code>go tool objdump $binary</code>来查看汇编代码。当compile的<code>.o</code>文件生成之后，可以通过<code>go tool link</code>来生成二进制可运行文件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/06/27/Go%20%E5%B9%B6%E5%8F%91%E8%8C%83%E5%BC%8F%20%E8%B6%85%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/Go%20%E5%B9%B6%E5%8F%91%E8%8C%83%E5%BC%8F%20%E8%B6%85%E6%97%B6/" class="post-title-link" itemprop="url">Go并发范式：超时</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 10:40:47" itemprop="dateCreated datePublished" datetime="2021-06-27T10:40:47+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="翻译自"><a href="#翻译自" class="headerlink" title="翻译自"></a>翻译自</h2><p><a target="_blank" rel="noopener" href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a></p>
<h2 id="Go并发范式：超时，继续执行"><a href="#Go并发范式：超时，继续执行" class="headerlink" title="Go并发范式：超时，继续执行"></a>Go并发范式：超时，继续执行</h2><p>并发编程有自己的习惯用法。 超时是一个很好的例子。在商用软件开发时，所有操作都需要有超时。</p>
<p>虽然 Go 的<strong>channel</strong>不直接支持超时，但很容易实现。假设我们想从通道 ch 接收，但希望实现一秒钟超时。 我们可以创建一个信号<strong>channel</strong>并启动一个在通道上发送之前休眠的 goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    timeout &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>我们可以使用<strong>select</strong>语句从<code>ch</code>或者<code>timeout</code>中接收。如果过了1秒还没有数据返回，超时的case会被选中，尝试从<code>ch</code>读取的操作被放弃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="comment">// a read from ch has occurred</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">    <span class="comment">// the read from ch has timed out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timeout channel有1个buffer，允许超时 goroutine 发送到通道然后退出。 goroutine 不关心这个值是否被接收了。这意味着如果 ch 接收发生在超时之前，goroutine 不会永远挂起。timeout channel 最终会被gc释放。</p>
<p>（在这个例子中，我们使用 time.Sleep 来演示 goroutines 和通道的机制。在实际程序中，你应该使用 <a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#After">time.After</a>来完成这个延迟发送）</p>
<p>让我们看看这种模式的另一种变体。在这个例子中，我们有一个程序可以同时从多个数据库的副本中读取数据。程序只需要一个结果，它应该接受最先返回的结果。</p>
<p>函数 Query 接受多个数据库连接和一个查询字符串。它并行查询每个数据库并返回它收到的第一个响应：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(conns []Conn, query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    <span class="keyword">for</span> _, conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c Conn)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- c.DoQuery(query):</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，闭包执行<strong>非阻塞发送</strong>，它通过在把<code>send</code>放在带有<code>default</code>的<code>select</code>中实现。 如果<code>send</code>不能立即完成，则将选择<code>default</code>情况。 <strong>非阻塞发送</strong>保证循环中启动的任何 goroutine 都不会挂起。 </p>
<p>但是，这个例子中有一个问题，如果结果在主函数执行到11行接收的时候之前到达，发送都会失败，最终函数无法取得结果。</p>
<p>这个问题是所谓的竞争条件的教科书示例，修复非常简单。 我们只要保证channel有着缓冲通道（通过添加缓冲区长度作为 make 的第二个参数）来保证第一次发送有一个放置值的地方。 这确保发送总是成功，并且无论执行顺序如何，第一个值都会被获取。</p>
<p>这两个例子展示了 Go 可以简单地表达 goroutines 之间复杂的交互。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/06/21/Go%20time.Time%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/21/Go%20time.Time%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/" class="post-title-link" itemprop="url">Go time.Time 应该使用值传递还是指针引用传递</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-21 14:48:57" itemprop="dateCreated datePublished" datetime="2021-06-21T14:48:57+08:00">2021-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h3><p>大部分场景应该使用值传递。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>Go 的文档指出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time. A Time value can be used by multiple goroutines simultaneously.</span><br></pre></td></tr></table></figure>

<p>翻译一下就是</p>
<p>程序使用times典型场景应该把它们当做值传递，而非指针。也就是说time变量及结构体field应该为<code>time.Time</code>，而不是<code>*time.Time</code>。Time值是协程安全的。之所以说<code>typically</code>，是因为有着那么不<code>typically</code>的场景，比如你想在方法内修改原来的<code>time.Time</code>对象这种场景（很少见）。</p>
<p><code>time.Time</code>是一个较小的对象，把它作为值传递是完全合理的。传递指针而不是值的很重要的一个原因是避免昂贵的拷贝动作。但是传递指针也会给gc带来一些额外的开销，如逃逸分析等。</p>
<p>值得一提的是，你可以通过<code>go build -gcflags=&quot;-m&quot;</code>来判断变量在堆中还是在栈中。</p>
<p><img src="/Images/go-time-pass.png" alt="go-time-pass"></p>
<p><code>time.Time</code>在我的MBP上只有24个字节。附上几个简单类型的字节数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte size is  1</span><br><span class="line">int32 size is  4</span><br><span class="line">int size is  8</span><br><span class="line">int64 size is  8</span><br><span class="line">float32 size is  4</span><br><span class="line">float64 size is  8</span><br><span class="line">time size is  24</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo_base</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSize</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">byte</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;byte size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;int32 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;int size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;int64 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">float32</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;float32 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;float64 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line">		fmt.Println(<span class="string">&quot;time size is &quot;</span>, unsafe.Sizeof(t))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhangjian He</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
