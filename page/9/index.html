<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hezhangjian.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"normal"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="张俭的博客">
<meta property="og:url" content="https://hezhangjian.com/page/9/index.html">
<meta property="og:site_name" content="张俭的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhangjian He">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hezhangjian.com/page/9/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>张俭的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">张俭的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangjian He</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hezhangjian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/hezhangjian" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/06/Go%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/Go%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="post-title-link" itemprop="url">Go 定时任务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-06 08:28:50" itemprop="dateCreated datePublished" datetime="2021-07-06T08:28:50+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="不使用三方库"><a href="#不使用三方库" class="headerlink" title="不使用三方库"></a>不使用三方库</h2><h3 id="协程Sleep方式"><a href="#协程Sleep方式" class="headerlink" title="协程Sleep方式"></a>协程Sleep方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello !!&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="使用ticker方式1"><a href="#使用ticker方式1" class="headerlink" title="使用ticker方式1"></a>使用ticker方式1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello !!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for 10 seconds</span></span><br><span class="line">time.Sleep(<span class="number">10</span> *time.Second)</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>

<h3 id="使用ticker方式2"><a href="#使用ticker方式2" class="headerlink" title="使用ticker方式2"></a>使用ticker方式2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            ticker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Hello !!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for 10 seconds</span></span><br><span class="line">time.Sleep(<span class="number">10</span> *time.Second)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53057237/how-to-schedule-a-task-at-go-periodically">https://stackoverflow.com/questions/53057237/how-to-schedule-a-task-at-go-periodically</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%20TCP%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%20TCP%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">网络编程经验总结 TCP拆包粘包常见解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-04 13:23:05" itemprop="dateCreated datePublished" datetime="2021-07-04T13:23:05+08:00">2021-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="从简单通信协议开始"><a href="#从简单通信协议开始" class="headerlink" title="从简单通信协议开始"></a>从简单通信协议开始</h2><p>最近工作中又需要处理协议解析，我对协议解析和网络抓包其实还是小有研究，17年刚毕业的时候，就用Netty手写过SMPP协议的对接。（其实做协议解析是一个很枯燥的工作，如果协议解析可以像antlr那样子写grammar自动解析应该会很酷？）本文总结一下协议在tcp下编码拆包粘包的三种解决方案。</p>
<p>网上有一些人对拆包粘包的说法不是很认可，但是我觉得这个术语还是挺形象的。</p>
<p>首先，让我们来设计一个简单地通信协议，<strong>Sorry</strong>，客户端一直对服务器发送<code>I am Sorry</code>，服务端回复<code>That&#39;s ok</code>。如下图所示</p>
<p><img src="/Images/network-tcp-codec1.png" alt="image-20210704104926698"></p>
<p>让我们来写个demo程序实现这个协议</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1997&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listen.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleRequest(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle incoming requests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">// make a buffer to hold incoming data</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="comment">// Read the incoming connection into the buffer</span></span><br><span class="line">	reqLen, err := conn.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error reading: &quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> reqLen != <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;invalid request size &quot;</span>, reqLen)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;That&#x27;s ok&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error sending: &quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::from_utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> TcpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;localhost:1997&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> stream) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;success connect to 1997&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">msg</span> = <span class="string">b&quot;I am Sorry&quot;</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">expect_resp</span> = <span class="string">b&quot;That&#x27;s ok&quot;</span>;</span><br><span class="line">            stream.<span class="title function_ invoke__">write</span>(msg);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Send hello, awaiting reply&quot;</span>);</span><br><span class="line">            <span class="comment">// use 9 byte buffer</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = [<span class="number">0</span> <span class="keyword">as</span> <span class="type">u8</span>; <span class="number">9</span>];</span><br><span class="line">            <span class="keyword">match</span> stream.<span class="title function_ invoke__">read_exact</span>(&amp;<span class="keyword">mut</span> data) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> &amp;data == expect_resp &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Reply is ok&quot;</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">text</span> = <span class="title function_ invoke__">from_utf8</span>(&amp;data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Unexpected reply: &#123;&#125;&quot;</span>, text);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Failed to receive data: &#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Failed to connect: &#123;&#125;&quot;</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面在服务端的实现中，我们校验了请求体的大小。</p>
<p>运行成功，我们在<code>Wireshark</code>上可以看到</p>
<p><img src="/Images/network-tcp-codec2.png" alt="image-20210704115955993"></p>
<p>目标端口为1997，这是客户端发出的报文。当然也能看到响应的报文</p>
<p><img src="/Images/network-tcp-codec3.png" alt="image-20210704120027704"></p>
<p>那么，如果客户端是个十分礼貌的人，他如果连续发送10个<code>I am Sorry</code>呢？我们将代码修改为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端报错了，服务端收到了一个请求，大小为100。并不是新手预期的10个大小为10的消息，</p>
<p><img src="/Images/network-tcp-codec4.png" alt="image-20210704120639637"></p>
<p>那么实际在网络中是如何传输的呢？一定是1个大小为100的消息吗？答案是否定的。在我的这次测试中，在<code>TCP</code>层，分成了两组消息，第一个大小为10，包含一个<code>I am Sorry</code></p>
<p><img src="/Images/network-tcp-codec5.png" alt="image-20210704120759769"></p>
<p>另一个大小为90，包含9个</p>
<p><img src="/Images/network-tcp-codec6.png" alt="image-20210704120818834"></p>
<h2 id="揭秘时刻"><a href="#揭秘时刻" class="headerlink" title="揭秘时刻"></a>揭秘时刻</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><strong>TCP</strong>和<strong>UDP</strong>不同，它是一个基于流的协议，<strong>TCP</strong>并不识别你定义的协议规则，只负责将这些报文打包发送，它可以基于<code>TCP_NODELAY</code>、<code>Nagle</code>算法等，任意的对你的报文进行切分发送。有两个典型的场景：第一个像上文中的例子，两个及以上的包在一个TCP数据包发送了，有个很形象的名字叫<code>粘包</code>。还有一个，因为报文过大，拆分成两个<code>TCP</code>报文发送，这叫拆包。</p>
<h3 id="应用层读取"><a href="#应用层读取" class="headerlink" title="应用层读取"></a>应用层读取</h3><p>常见API，应用层读取也不保证单次操作一定仅仅读取一个<code>tcp</code>数据包，会根据你提供的buffer大小，尽量提供数据。你读取到的可能是上一个<code>TCP</code>包的末尾和下一个<code>TCP</code>包的开头部分。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>TCP</strong>是基于流的协议，并非基于报文。<strong>TCP</strong>提供了保序的语义保证，这要求应用程序，尤其是接收者，需要能够从报文流中提取出协议信息，<strong>TCP</strong>决不保证读取到的报文恰好是发送者一次<code>write</code>写入的报文，即使能在测试环境通过<code>case</code>，那也只不过是你运气好而已。</p>
<p>像我们上面，读取到100大小的消息。根据协议大小请求固定为10，我们就可以将100消息分割为10条协议报文。如果读取到的大小为96，那就先处理前90个字节，剩下6个字节，待后面4个字节到达之后再合并处理。下一节我们详细介绍一下几种常见方式。</p>
<h2 id="常见TCP协议定义方式"><a href="#常见TCP协议定义方式" class="headerlink" title="常见TCP协议定义方式"></a>常见TCP协议定义方式</h2><h3 id="定长编码"><a href="#定长编码" class="headerlink" title="定长编码"></a>定长编码</h3><p>就像我们例子中的那样一样，定义一个定长宽度，然后切分</p>
<p>使用Go的gnet库的<code>Server</code>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	codec := gnet.NewFixedLengthFrameCodec(<span class="number">10</span>)</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(codec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于分隔符"><a href="#基于分隔符" class="headerlink" title="基于分隔符"></a>基于分隔符</h3><p>基于分隔符的编码也十分容易理解，双方约定好一个字符，并在正常报文中不出现这个字符（出现则需要转义），比较类似的是以太网的<code>7d7d</code>?这个计算机网络链路层相关的知乎，学太久了，忘记了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	codec := gnet.NewDelimiterBasedFrameCodec(<span class="number">0x11</span>)</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(codec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于固定行数的编码"><a href="#基于固定行数的编码" class="headerlink" title="基于固定行数的编码"></a>基于固定行数的编码</h3><p>这个也很简单，协议内容不换行，发送完再发送一个换行符，比较类似的有HTTP的<code>\r\n</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(&amp;gnet.LineBasedFrameCodec&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="长度编码"><a href="#长度编码" class="headerlink" title="长度编码"></a>长度编码</h3><p>长度编码是使用最多的，最流行的一种编码方式。最简单的一种工作方式是，在报文的最开始数个字节（常见为4个字节，足以编码4个G长度，相比之下两个字节仅能存放64K消息），声明报文剩余内容的长度。以<code>Kafka</code>协议举例</p>
<p><img src="/Images/network-tcp-codec7.png" alt="image-20210704125652379"></p>
<p>Kafka这条消息，在<strong>TCP</strong>层占据的总长度为87字节，其中前4个字节<code>00 00 00 53</code>声明为83长度，为其余报文的长度。</p>
<p>这一模式还有很多变体，如</p>
<ul>
<li>声明的长度包括其长度字段本身的长度</li>
<li>长度字段并不是打头的字段</li>
<li>长度字段的长度</li>
</ul>
<p>等等。这也就是下面解码器，拥有的参数非常多的原因，都是为了适配这些变体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/panjf2000/gnet&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gnet.EventServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	encoderConfig := gnet.EncoderConfig&#123;</span><br><span class="line">		ByteOrder:                       binary.BigEndian,</span><br><span class="line">		LengthFieldLength:               <span class="number">4</span>,</span><br><span class="line">		LengthAdjustment:                <span class="number">0</span>,</span><br><span class="line">		LengthIncludesLengthFieldLength: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	decoderConfig := gnet.DecoderConfig&#123;</span><br><span class="line">		ByteOrder:           binary.BigEndian,</span><br><span class="line">		LengthFieldOffset:   <span class="number">0</span>,</span><br><span class="line">		LengthFieldLength:   <span class="number">4</span>,</span><br><span class="line">		LengthAdjustment:    <span class="number">-4</span>,</span><br><span class="line">		InitialBytesToStrip: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	codec := gnet.NewLengthFieldBasedFrameCodec(encoderConfig, decoderConfig)</span><br><span class="line">	gnet.Serve(&amp;ExampleServer&#123;&#125;, <span class="string">&quot;tcp://localhost:1998&quot;</span>, gnet.WithCodec(codec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，长度字段编码格式是我见过开源代码使用最多的格式，像MQTT、KAFKA、SMPP等都使用这种格式。其中原因，个人觉得在于声明长度之后，buffer申请及释放，可以简化很多，性能最好。</p>
<h2 id="其他网络协议使用的编码方式"><a href="#其他网络协议使用的编码方式" class="headerlink" title="其他网络协议使用的编码方式"></a>其他网络协议使用的编码方式</h2><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>使用长度字段编码格式</p>
<p><img src="/Images/network-tcp-codec8.png" alt="image-20210704131034560"></p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP的解析较为麻烦，它根据协议目前的状态，同时使用定长编码和长度字段两种编码方式。这就要求解码器不仅仅要处理报文，还要处理当前协议交互到那个状态了。</p>
<h4 id="定长场景"><a href="#定长场景" class="headerlink" title="定长场景"></a>定长场景</h4><p><img src="/Images/network-tcp-codec9.png" alt="image-20210704131231757"></p>
<h4 id="长度字段模式"><a href="#长度字段模式" class="headerlink" title="长度字段模式"></a>长度字段模式</h4><p><img src="/Images/network-tcp-codec10.png" alt="image-20210704131317098"></p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><ul>
<li>Go代码: <a target="_blank" rel="noopener" href="https://github.com/hezhangjian/go_demo/tree/main/demo_gnet/codec">https://github.com/hezhangjian/go_demo/tree/main/demo_gnet/codec</a></li>
<li>Rust代码:<a target="_blank" rel="noopener" href="https://github.com/hezhangjian/rust-demo/blob/main/demo-tcp-client/src/main.rs">https://github.com/hezhangjian/rust-demo/blob/main/demo-tcp-client/src/main.rs</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/04/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAfilebeat%20output%20websocket%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/filebeat-output-websocket" class="post-title-link post-title-link-external" itemprop="url">开发一个filebeat output websocket插件<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-04 09:38:39" itemprop="dateCreated datePublished" datetime="2021-07-04T09:38:39+08:00">2021-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>开发一个filebeat的<code>websocket</code>插件， 代码仓地址: <a target="_blank" rel="noopener" href="https://github.com/hezhangjian/beats_output_websocket">https://github.com/hezhangjian/beats_output_websocket</a></p>
<h2 id="引入对beat的依赖"><a href="#引入对beat的依赖" class="headerlink" title="引入对beat的依赖"></a>引入对<code>beat</code>的依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/elastic/beats/v7</span><br></pre></td></tr></table></figure>

<h2 id="定义在filebeat中的配置文件"><a href="#定义在filebeat中的配置文件" class="headerlink" title="定义在filebeat中的配置文件"></a>定义在filebeat中的配置文件</h2><p><code>filebeat</code>通常以配置文件的方式加载插件。让我们定义一下必须的配置，就像<code>elasticsearch</code>中的连接地址等等一样。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.websocket:</span></span><br><span class="line">  <span class="comment"># worker</span></span><br><span class="line">  <span class="comment"># 用于工作的websocket客户端数量</span></span><br><span class="line">  <span class="attr">workers:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 日志批量的最大大小</span></span><br><span class="line">  <span class="attr">batch_size:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试的最大次数，0代表不重试</span></span><br><span class="line">  <span class="attr">retry_limit:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># conn</span></span><br><span class="line">  <span class="comment"># ws/wss</span></span><br><span class="line">  <span class="attr">schema:</span> <span class="string">&quot;ws&quot;</span></span><br><span class="line">  <span class="comment"># websocket连接地址</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">  <span class="comment"># websocket路径</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&quot;/echo&quot;</span></span><br><span class="line">  <span class="comment"># websocket心跳间隔，用于保活</span></span><br><span class="line">  <span class="attr">ping_interval:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="go文件中的配置"><a href="#go文件中的配置" class="headerlink" title="go文件中的配置"></a>go文件中的配置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Number of worker goroutines publishing log events</span></span><br><span class="line">	Workers <span class="type">int</span> <span class="string">`config:&quot;workers&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line">	<span class="comment">// Max number of events in a batch to send to a single client</span></span><br><span class="line">	BatchSize <span class="type">int</span> <span class="string">`config:&quot;batch_size&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line">	<span class="comment">// Max number of retries for single batch of events</span></span><br><span class="line">	RetryLimit <span class="type">int</span> <span class="string">`config:&quot;retry_limit&quot;`</span></span><br><span class="line">	<span class="comment">// Schema WebSocket Schema</span></span><br><span class="line">	Schema <span class="type">string</span> <span class="string">`config:&quot;schema&quot;`</span></span><br><span class="line">	<span class="comment">// Addr WebSocket Addr</span></span><br><span class="line">	Addr <span class="type">string</span> <span class="string">`config:&quot;addr&quot;`</span></span><br><span class="line">	<span class="comment">// Path WebSocket Path</span></span><br><span class="line">	Path <span class="type">string</span> <span class="string">`config:&quot;path&quot;`</span></span><br><span class="line">	<span class="comment">// PingInterval WebSocket PingInterval</span></span><br><span class="line">	PingInterval <span class="type">int</span> <span class="string">`config:&quot;ping_interval&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始化加载插件"><a href="#初始化加载插件" class="headerlink" title="初始化加载插件"></a>初始化加载插件</h2><h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>在某个init函数中注册插件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	outputs.RegisterType(<span class="string">&quot;websocket&quot;</span>, newWsOutput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>newWsOutput</code>中卸载配置，并提供配置给<code>WebSocket</code>客户端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWsOutput</span><span class="params">(_ outputs.IndexManager, _ beat.Info, stats outputs.Observer, cfg *common.Config)</span></span> (outputs.Group, <span class="type">error</span>) &#123;</span><br><span class="line">	config := clientConfig&#123;&#125;</span><br><span class="line">	<span class="comment">// 卸载配置，将配置用于初始化WebSocket客户端</span></span><br><span class="line">	<span class="keyword">if</span> err := cfg.Unpack(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> outputs.Fail(err)</span><br><span class="line">	&#125;</span><br><span class="line">	clients := <span class="built_in">make</span>([]outputs.NetworkClient, config.Workers)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; config.Workers; i++ &#123;</span><br><span class="line">		clients[i] = &amp;wsClient&#123;</span><br><span class="line">			stats:  stats,</span><br><span class="line">			Schema: config.Schema,</span><br><span class="line">			Host:   config.Addr,</span><br><span class="line">			Path:   config.Path,</span><br><span class="line">			PingInterval: config.PingInterval,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> outputs.SuccessNet(<span class="literal">true</span>, config.BatchSize, config.RetryLimit, clients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化WebSocket客户端"><a href="#初始化WebSocket客户端" class="headerlink" title="初始化WebSocket客户端"></a>初始化<code>WebSocket</code>客户端</h2><p><code>WebSocket</code>客户端不仅仅是一个<code>WebSocket</code>客户端，而且还需要实现<code>filebeat</code>中的<code>NetworkClient</code>接口，接下来，让我们来关注接口中的每一个方法的作用及实现</p>
<h3 id="String-接口"><a href="#String-接口" class="headerlink" title="String()接口"></a>String()接口</h3><p><code>String</code>作为客户端的名字，用来标识日志以及指标。是最简单的一个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;websocket&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Connect-接口"><a href="#Connect-接口" class="headerlink" title="Connect()接口"></a>Connect()接口</h3><p><code>Connect</code>用来初始化客户端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> Connect() <span class="type">error</span> &#123;</span><br><span class="line">	u := url.URL&#123;Scheme: w.Schema, Host: w.Host, Path: w.Path&#125;</span><br><span class="line">	dial, _, err := websocket.DefaultDialer.Dial(u.String(), <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		w.conn = dial</span><br><span class="line">		ticker := time.NewTicker(time.Duration(w.PingInterval) * time.Second)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">				w.conn.WriteMessage(websocket.PingMessage, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里初始化失败，需要<code>Sleep</code>一段时间，否则，filebeat会一直重试。这绝非是你想要的。或许对于场景来说，退避重试可能会更好</p>
<h3 id="Close-接口"><a href="#Close-接口" class="headerlink" title="Close()接口"></a>Close()接口</h3><p>关闭客户端，也是很简单的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Publish-接口"><a href="#Publish-接口" class="headerlink" title="Publish()接口"></a>Publish()接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> Publish(_ context.Context, batch publisher.Batch) <span class="type">error</span> &#123;</span><br><span class="line">	events := batch.Events()</span><br><span class="line">	<span class="comment">// 记录这批日志</span></span><br><span class="line">	w.stats.NewBatch(<span class="built_in">len</span>(events))</span><br><span class="line">	failEvents, err := w.PublishEvents(events)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果发送正常，则ACK</span></span><br><span class="line">		batch.ACK()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 发送失败，则重试。受RetryLimit的限制</span></span><br><span class="line">		batch.RetryEvents(failEvents)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> PublishEvents(events []publisher.Event) ([]publisher.Event, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		err := w.publishEvent(&amp;event)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果单条消息发送失败，则将剩余的消息直接重试</span></span><br><span class="line">			<span class="keyword">return</span> events[i:], err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsClient)</span></span> publishEvent(event *publisher.Event) <span class="type">error</span> &#123;</span><br><span class="line">	bytes, err := encode(&amp;event.Content)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果编码失败，就不重试了，重试也不会成功</span></span><br><span class="line">		<span class="comment">// encode error, don&#x27;t retry.</span></span><br><span class="line">		<span class="comment">// consider being success</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = w.conn.WriteMessage(websocket.TextMessage, bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 写入WebSocket Server失败</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码的逻辑因人而异，事实上，这可能是大家最大的差异所在。这里只是做一个简单地例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">	Timestamp time.Time <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">	Message   <span class="type">string</span>    <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(event *beat.Event)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	logOutput := &amp;LogOutput&#123;&#125;</span><br><span class="line">	value, err := event.Fields.GetValue(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	logOutput.Timestamp = event.Timestamp</span><br><span class="line">	logOutput.Message = value.(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">return</span> json.Marshal(logOutput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后是我们的wsclient"><a href="#最后是我们的wsclient" class="headerlink" title="最后是我们的wsclient"></a>最后是我们的<code>wsclient</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wsClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// construct field</span></span><br><span class="line">	Schema       <span class="type">string</span></span><br><span class="line">	Host         <span class="type">string</span></span><br><span class="line">	Path         <span class="type">string</span></span><br><span class="line">	PingInterval <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	stats outputs.Observer</span><br><span class="line">	conn  *websocket.Conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加额外的功能：大包丢弃"><a href="#添加额外的功能：大包丢弃" class="headerlink" title="添加额外的功能：大包丢弃"></a>添加额外的功能：大包丢弃</h2><p>你可能会想保护你的<code>WebSocket</code>服务器，避免接收到超级大的日志。我们可以在配置项中添加一个配置</p>
<p>maxLen用来限制日志长度，超过maxLen的日志直接丢弃。为什么不使用<code>filebeat</code>中的<code>max_bytes</code>？</p>
<p>因为<code>filebeat</code>中<code>max_bytes</code>的默认行为是截断，截断的日志在某些场景下不如丢弃。（比如，日志是json格式，截断后格式无法解析）</p>
<h3 id="配置中添加maxLen"><a href="#配置中添加maxLen" class="headerlink" title="配置中添加maxLen"></a>配置中添加maxLen</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_len:</span> <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>省略掉那些重复的添加结构体，读取<code>max_len</code>在encode的时候忽略掉</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := value.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt;= w.MaxLen &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/02/Go%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/02/Go%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Go 内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-02 14:28:45" itemprop="dateCreated datePublished" datetime="2021-07-02T14:28:45+08:00">2021-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></p>
<h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><ul>
<li>协程之间的数据可见性满足HappensBefore法则，并具有传递性</li>
<li>如果包 p 导入包 q，则 q 的 init 函数的完成发生在任何 p 的操作开始之前</li>
<li>main.main 函数的启动发生在所有 init 函数完成之后</li>
<li><code>go</code>语句启动新的协程发生在新协程启动开始之前</li>
<li><code>go</code>协程的退出并不保证发生在任何事件之前</li>
<li><code>channel</code>上的发送发生在对应<code>channel</code>接收之前</li>
<li>无buffer<code>channel</code>的接收发生在发送操作完成之前</li>
<li>对于容量为C的buffer channel来说，第k次从channel中接收，发生在第<code>k + C</code>次发送完成之前。</li>
<li>对于任何的<code>sync.Mutex</code>或者<code>sync.RWMutex</code>变量<code>，且有</code>n&lt;m<code>，第</code>n<code>个调用</code>UnLock<code>一定发生在</code>m<code>个</code>Lock&#96;之前。</li>
<li>从 once.Do(f) 对 f() 的单个调用返回在任何一个 once.Do(f) 返回之前。</li>
<li>如果两个动作不满足HappensBefore，则顺序无法预测</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go内存模型指定了在何种条件下可以保证在一个 goroutine 中读取变量时观察到不同 goroutine 中写入该变量的值。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>通过多个协程并发修改数据的程序必须将操作序列化。为了序列化访问，通过channel操作或者其他同步原语（<code>sync</code>、<code>sync/atomic</code>）来保护数据。</p>
<p>如果你必须要阅读本文的其他部分才能理解你程序的行为，请尽量不要这样…</p>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><p>在单个 <code>goroutine</code> 中，读取和写入的行为必须像按照程序指定的顺序执行一样。 也就是说，只有当重新排序不会改变语言规范定义的 goroutine 中的行为时，编译器和处理器才可以重新排序在单个 goroutine 中执行的读取和写入。 由于这种重新排序，一个 goroutine 观察到的执行顺序可能与另一个 goroutine 感知的顺序不同。 例如，如果一个 goroutine 执行 a &#x3D; 1; b &#x3D; 2;，另一个可能会在 a 的更新值之前观察到 b 的更新值。</p>
<p>为了满足读写的需求，我们定义了<code>happens before</code>，Go程序中内存操作的局部顺序。如果事件<code>e1</code>在<code>e2</code>之前发生，我们说<code>e2</code>在<code>e1</code>之后发生。还有，如果<code>e1</code>不在<code>e2</code>之前发生、<code>e2</code>也不在<code>e1</code>之前发生，那么我们说<code>e1</code>和<code>e2</code>并发happen。</p>
<p>在单个<code>goroutine</code>中，<code>happens-before</code>顺序由程序指定。</p>
<p>当下面两个条件满足时，变量<code>v</code>的阅读操作<code>r</code>就<strong>可能</strong>观察到写入操作<code>w</code></p>
<ul>
<li><code>r</code>不在<code>w</code>之前发生</li>
<li>没有其他的请求<code>w2</code>发生在<code>w</code>之后，<code>r</code>之前</li>
</ul>
<p>为了保证<code>r</code>一定能阅读到<code>v</code>，保证<code>w</code>是<code>r</code>能观测到的唯一的写操作。当下面两个条件满足时，<code>r</code>保证可以读取到<code>w</code></p>
<ul>
<li><code>w</code>在<code>r</code>之前发生</li>
<li>任何其他对共享变量<code>v</code>的操作，要么在<code>w</code>之前发生，要么在<code>r</code>之后发生</li>
</ul>
<p>这一对条件比上一对条件更强；这要求无论是<code>w</code>还是<code>r</code>，都没有相应的并发操作。</p>
<p>在单个<code>goroutine</code>中，没有并发。所以这两个定义等价：读操作<code>r</code>能读到最近一次<code>w</code>写入<code>v</code>的值。但是当多个<code>goroutine</code>访问共享变量时，它们必须使用同步事件来建立<code>happens-before</code>关系。</p>
<p>使用变量<code>v</code>类型的0值初始化变量<code>v</code>的行为类似于内存模型中的写入。</p>
<p>对于大于单个机器字长的值的读取和写入表现为未指定顺序的对多个机器字长的操作。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>程序初始化在单个 goroutine 中运行，但该 goroutine 可能会创建其他并发运行的 goroutine。</p>
<p><strong>如果包 p 导入包 q，则 q 的 init 函数的完成发生在任何 p 的操作开始之前。</strong></p>
<p><strong>main.main 函数的启动发生在所有 init 函数完成之后。</strong></p>
<h3 id="Go协程的创建"><a href="#Go协程的创建" class="headerlink" title="Go协程的创建"></a>Go协程的创建</h3><p><strong><code>go</code>语句启动新的协程发生在新协程启动开始之前。</strong></p>
<p>举个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>hello</code>将会打印<code>hello, world</code>。当然，这个时候<code>hello</code>可能已经返回了。</p>
<h3 id="Go协程的销毁"><a href="#Go协程的销毁" class="headerlink" title="Go协程的销毁"></a>Go协程的销毁</h3><p><strong><code>go</code>协程的退出并不保证发生在任何事件之前</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">&quot;hello&quot;</span> &#125;()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 a 的赋值之后没有任何同步事件，因此不能保证任何其他 goroutine 都会观察到它。 事实上，激进的编译器可能会删除整个 go 语句。</p>
<p>如果一个 goroutine 的效果必须被另一个 goroutine 观察到，请使用同步机制，例如锁或通道通信来建立相对顺序。</p>
<h3 id="通道通信"><a href="#通道通信" class="headerlink" title="通道通信"></a>通道通信</h3><p>通道通信是在go协程之间传输数据的主要手段。在特定通道上的发送总有一个对应的channel的接收，通常是在另外一个协程。</p>
<p><strong><code>channel</code>上的发送发生在对应<code>channel</code>接收之前</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序能保证输出<code>hello, world</code>。对a的写入发生在往<code>c</code>发送数据之前，往<code>c</code>发送数据又发生在从<code>c</code>接收数据之前，它又发生在<code>print</code>之前。</p>
<p><strong><code>channel</code>的关闭发生在从<code>channel</code>中获取到0值之前</strong></p>
<p>在之前的例子中，将<code>c&lt;-0</code>替换为<code>close(c)</code>，程序还是能保证输出<code>hello, world</code></p>
<p><strong>无buffer<code>channel</code>的接收发生在发送操作完成之前</strong><br>这个程序，和之前一样，但是调换发送和接收操作，并且使用无buffer的channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也保证能够输出<code>hello, world</code>。对a的写入发生在c的接收之前，继而发生在c的写入操作完成之前，继而发生在print之前。</p>
<p>如果该<code>channel</code>是buffer<code>channel</code>（例如：<code>c=make(chan int, 1)</code>），那么程序就不能保证输出<code>hello, world</code>。可能会打印空字符串、崩溃等等。从而，我们得到一个相对通用的推论：</p>
<p><strong>对于容量为C的buffer channel来说，第k次从channel中接收，发生在第<code>k + C</code>次发送完成之前。</strong></p>
<p>此规则将先前的规则推广到缓冲通道。 它允许通过buffer channel 来模拟信号量：通道中的条数对应活跃的数量，通道的容量对应于最大并发数。向channel发送数据相当于获取信号量，从channel中接收数据相当于释放信号量。 这是限制并发的常用习惯用法。</p>
<p>该程序为工作列表中的每个条目启动一个 goroutine，但是 goroutine 使用<code>limit</code>channel进行协调，以确保一次最多三个work函数正在运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">			limit &lt;- <span class="number">1</span></span><br><span class="line">			w()</span><br><span class="line">			&lt;-limit</span><br><span class="line">		&#125;(w)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><code>sync</code>包中实现了两种锁类型：<code>sync.Mutex</code>和<code>sync.RWMutex</code></p>
<p><strong>对于任何的<code>sync.Mutex</code>或者<code>sync.RWMutex</code>变量<code>，且有</code>n&lt;m<code>，第</code>n<code>个调用</code>UnLock<code>一定发生在</code>m<code>个</code>Lock&#96;之前。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序也保证输出<code>hello,world</code>。第一次调用<code>unLock</code>一定发生在第二次<code>Lock</code>调用之前</p>
<p><strong>对于任何<code>sync.RWMutex</code>的<code>RLock</code>方法调用，存在变量n，满足<code>RLock</code>方法发生在第<code>n</code>个<code>UnLock</code>调用之后，并且对应的<code>RUnlock</code>发生在第<code>n+1</code>个<code>Lock</code>方法之前。</strong></p>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>在存在多个 goroutine 时，<code>sync</code>包通过<code>once</code>提供了一种安全的初始化机制。对于特定的<code>f</code>，多个线程可以执行<code>once.Do(f)</code>，但是只有一个会运行<code>f()</code>，另一个调用会阻塞，直到<code>f()</code>返回</p>
<p><strong>从 once.Do(f) 对 f() 的单个调用返回在任何一个 once.Do(f) 返回之前。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(setup)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 twoprint 将只调用一次 setup。 <code>setup</code>函数将在任一打印调用之前完成。 结果将是<code>hello, world</code>打印两次。</p>
<h2 id="不正确的同步"><a href="#不正确的同步" class="headerlink" title="不正确的同步"></a>不正确的同步</h2><p>注意，读取<code>r</code>有可能观察到了由写入<code>w</code>并发写入的值。尽管观察到了这个值，也并不意味着<code>r</code>后续的读取可以读取到<code>w</code>之前的写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有可能<code>g</code>会接连打印2和0两个值。</p>
<p>双检查锁是为了降低同步造成的开销。举个例子，<code>twoprint</code>方法可能会被误写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !done &#123;</span><br><span class="line">		once.Do(setup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有任何机制保证，协程观察到done为true的同时可以观测到a为<code>hello, world</code>,其中有一个<code>doprint</code>可能会输出空字符。</p>
<p>另外一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和以前一样，不能保证在 main 中，观察对 done 的写入意味着观察对 a 的写入，因此该程序也可以打印一个空字符串。 更糟糕的情况下，由于两个线程之间没有同步事件，因此无法保证 main 会观察到对 done 的写入。 main 中的循环会一直死循环。</p>
<p>下面是该例子的一个更微妙的变体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := <span class="built_in">new</span>(T)</span><br><span class="line">	t.msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管<code>main</code>观测到g不为nil，但是也没有任何机制保证可以读取到t.msg。</p>
<p>在上述例子中，解决方案都是相同的：请使用显式的同步机制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/07/01/Go%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/01/Go%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Go 编译流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-01 13:19:53" itemprop="dateCreated datePublished" datetime="2021-07-01T13:19:53+08:00">2021-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/cmd/compile/README.md">https://github.com/golang/go/blob/master/src/cmd/compile/README.md</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889">https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889</a></li>
<li>基于Golang 1.16版本</li>
</ul>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>Go编译器由四个阶段组成，可以分为两类</p>
<ul>
<li>frontend前端：这一阶段对源码进行语法解析，并生成AST</li>
<li>backend后端：这一阶段将把transform the representation of the source code into machine code, 并进行数项优化</li>
</ul>
<p>为了更好地理解每个阶段，让我们使用如下的示例程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">		add(a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1-解析"><a href="#P1-解析" class="headerlink" title="P1 解析"></a>P1 解析</h2><ul>
<li><code>cmd/compile/internal/syntax</code> 词法，解析器，语法树</li>
</ul>
<p>第一个阶段非常简单直接：</p>
<p>第一阶段，源码经过词法分析、语法解析，对每个源码文件，都构造出相应的语法树</p>
<p>Lexer首先运行，把源代码转化为词法单元。我们可以通过这个程序来自己模拟运行Lexer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;go/scanner&quot;</span></span><br><span class="line">	<span class="string">&quot;go/token&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// src is the input that we want to tokenize.</span></span><br><span class="line">	src, _ := ioutil.ReadFile(<span class="string">`main.go`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the scanner</span></span><br><span class="line">	<span class="keyword">var</span> s scanner.Scanner</span><br><span class="line">	<span class="comment">// positions are relative to fSet</span></span><br><span class="line">	fSet := token.NewFileSet()</span><br><span class="line">	file := fSet.AddFile(<span class="string">&quot;&quot;</span>, fSet.Base(), <span class="built_in">len</span>(src))</span><br><span class="line">	<span class="comment">// nil means no error handler</span></span><br><span class="line">	s.Init(file, src, <span class="literal">nil</span>, scanner.ScanComments)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Repeated calls to Scan yield the token sequence found in the input</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		pos, tok, lit := s.Scan()</span><br><span class="line">		<span class="keyword">if</span> tok == token.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\t%s\t%q\n&quot;</span>, fSet.Position(pos), tok, lit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>截选输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1:1	package	&quot;package&quot;</span><br><span class="line">1:9	IDENT	&quot;main&quot;</span><br><span class="line">1:13	;	&quot;\n&quot;</span><br><span class="line">3:1	func	&quot;func&quot;</span><br><span class="line">3:6	IDENT	&quot;main&quot;</span><br><span class="line">3:10	(	&quot;&quot;</span><br><span class="line">3:11	)	&quot;&quot;</span><br><span class="line">3:13	&#123;	&quot;&quot;</span><br><span class="line">4:2	IDENT	&quot;a&quot;</span><br><span class="line">4:4	:=	&quot;&quot;</span><br><span class="line">4:7	INT	&quot;1&quot;</span><br><span class="line">4:8	;	&quot;\n&quot;</span><br><span class="line">5:2	IDENT	&quot;b&quot;</span><br><span class="line">5:4	:=	&quot;&quot;</span><br><span class="line">5:7	INT	&quot;2&quot;</span><br><span class="line">5:8	;	&quot;\n&quot;</span><br><span class="line">6:2	if	&quot;if&quot;</span><br><span class="line">6:5	IDENT	&quot;true&quot;</span><br><span class="line">6:10	&#123;	&quot;&quot;</span><br><span class="line">7:3	IDENT	&quot;add&quot;</span><br><span class="line">7:6	(	&quot;&quot;</span><br><span class="line">7:7	IDENT	&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>一旦经过词法化，源码被解析构造成语法树。</p>
<p>语法树还包含了代码位置信息，该信息可用于debug或错误报告。</p>
<h2 id="P2-类型检查和AST转化"><a href="#P2-类型检查和AST转化" class="headerlink" title="P2 类型检查和AST转化"></a>P2 类型检查和AST转化</h2><ul>
<li><code>cmd/compile/internal/gc</code> 创建编译器AST，类型检查，AST转换</li>
</ul>
<p>AST是类型检查的。第一个步骤就是名字解析和类型推断，确定对象和标识符的对应关系，表达式是何种类型。Type-checking这一阶段还引入了额外的确定性步骤，例如，“声明未使用”、函数是否终止等。</p>
<p>还有一些确定的转换也在AST阶段完成。一些节点会根据类型信息进行细化，比如字符串加法从算术加法节点中分离出来。其他一些示例是不可达代码清除、内联函数调用、逃逸分析。</p>
<p>转化到AST的步骤可以通过命令<code>go tool compile -w</code>来展示出来，如果加上-l，则可以禁用内联。在我们的样例代码中，如果不禁用内联，add方法会被内联掉。我们可以分别使用<code>go tool compile -w example.o</code>和<code>go tool compile -w -l example.o</code>进行对比</p>
<p>禁用了内联的命令，会输出这样的AST</p>
<p><img src="/Images/go-compile-process1.png" alt="image-20210701110847543"></p>
<p>没禁用内联的命令则不会生成，这里可以看出来，编译器做了内联的优化。</p>
<h2 id="SSA-生成"><a href="#SSA-生成" class="headerlink" title="SSA 生成"></a>SSA 生成</h2><h3 id="SSA-概念"><a href="#SSA-概念" class="headerlink" title="SSA 概念"></a>SSA 概念</h3><ul>
<li><code>cmd/compile/internal/gc</code> AST转化到SSA</li>
<li><code>cmd/compile/internal/ssa</code> SSA阶段和规则</li>
</ul>
<p>在这个阶段，AST转化为SSA的格式，这是一种具有特定属性的更底层的IR，可以更轻松地在上面进行优化并最终生成机器码。阶段应用了内联函数。这些是编译器被教导要根据具体情况用高度优化的代码替换的特殊函数。在AST到SSA的转换期间，某些确定的节点也被降低为更简单的组件，使得编译器的其余部分可以使用它们。例如，内置的copy函数被内存移动取代、范围循环被重写为for循环。由于历史原因，其中一些目前在SSA转换之前发生，但长期计划是将它们全部移到这里。</p>
<p>然后，应用一系列的、机器无关的阶段和规则。这些不涉及任何的计算机架构，因此可以在任何<code>GOARCH</code>变体上运行。</p>
<p>这些通用的阶段包括：不可达代码清除、删除不需要的nil检查、移除无用的分支。</p>
<p>通用的重写规则主要涉及表达式，包括表达式替换为常量、优化乘法和浮点运算等。</p>
<p>SSA code可以用这个命令<code>dump</code>并展示出来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOSSAFUNC=main go tool compile main.go &amp;&amp; open ssa.html</span><br></pre></td></tr></table></figure>

<h3 id="SSA阶段"><a href="#SSA阶段" class="headerlink" title="SSA阶段"></a>SSA阶段</h3><p><img src="/Images/go-compile-process2.png" alt="Go编译流程"></p>
<h3 id="SSA优化解析"><a href="#SSA优化解析" class="headerlink" title="SSA优化解析"></a>SSA优化解析</h3><p>start Tab上生成了最开始的SSA</p>
<p><img src="/Images/go-compile-process3.png" alt="image-20210701101016958"></p>
<p>变量 a 和 b 与 if 条件一起在此处突出显示，以便我们稍后查看这些行是如何更改的。 代码还向我们展示了编译器如何管理 <code>println</code><br>函数，它被分解为 4 个步骤：<code>printlock</code>、<code>printint</code>、<code>printnl</code>、<code>printunlock</code>。 编译器会自动为我们加锁，并根据参数的类型调用相关方法正确打印。<br>在我们的示例中，由于 a 和 b 在编译时已知，编译器可以计算最终结果并将变量标记为不再需要。  <code>opt</code>阶段 会优化这部分：</p>
<p><img src="/Images/go-compile-process4.png" alt="image-20210701101445933"></p>
<p>这个阶段v7被优化计算成了3。并且接下来，因为v4和v5已经没有人声明使用，在<code>opt deadcode</code>阶段，v4和v5也会被清除掉</p>
<p><img src="/Images/go-compile-process5.png" alt="image-20210701101729496"></p>
<p>等待所有阶段完成之后，Go编译器将会生成中间汇编语言</p>
<p><img src="/Images/go-compile-process6.png" alt="image-20210701102735403"></p>
<p>下一阶段会将汇编语言转换为二进制文件</p>
<h2 id="机器代码生成"><a href="#机器代码生成" class="headerlink" title="机器代码生成"></a>机器代码生成</h2><ul>
<li><code>cmd/compile/internal/ssa</code> SSA “lowering” 和 特定arch的阶段</li>
<li><code>cmd/internal/obj</code> 机器语言生成</li>
</ul>
<p>机器相关的编译阶段从”lowering”阶段开始，它将通用的值替换成机器特定的变体。例如，在 amd64 内存操作数上是可能的，因此可以组合许多加载-存储操作。</p>
<p>注意这些底层阶段执行了所有机器特定的规则，所以也应用了很多优化。</p>
<p>一旦SSA被”lowered”到更特定的目标架构，就开始执行最终的代码优化。这包括另一个不可达代码清除阶段、将值更靠近它们的使用者、移除从未使用的本地变量、寄存器分配。</p>
<p>还有一部分重要工作包括堆栈帧布局，它将堆栈偏移分配给局部变量，以及指针存活分析，它计算每个 GC 安全点上哪些堆栈上指针是活跃的。</p>
<p>在 SSA 生成阶段结束时，Go 函数已转换为一系列 obj.Prog 指令。 这些被传递给汇编器（cmd&#x2F;internal&#x2F;obj），汇编器将它们转换成机器代码并写出最终的目标文件。<br>目标文件还将包含反射数据、导出数据和调试信息。</p>
<p>我们可以使用<code>go tool objdump $binary</code>来查看汇编代码。当compile的<code>.o</code>文件生成之后，可以通过<code>go tool link</code>来生成二进制可运行文件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/06/27/Go%20%E5%B9%B6%E5%8F%91%E8%8C%83%E5%BC%8F%20%E8%B6%85%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/Go%20%E5%B9%B6%E5%8F%91%E8%8C%83%E5%BC%8F%20%E8%B6%85%E6%97%B6/" class="post-title-link" itemprop="url">Go并发范式：超时</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 10:40:47" itemprop="dateCreated datePublished" datetime="2021-06-27T10:40:47+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="翻译自"><a href="#翻译自" class="headerlink" title="翻译自"></a>翻译自</h2><p><a target="_blank" rel="noopener" href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a></p>
<h2 id="Go并发范式：超时，继续执行"><a href="#Go并发范式：超时，继续执行" class="headerlink" title="Go并发范式：超时，继续执行"></a>Go并发范式：超时，继续执行</h2><p>并发编程有自己的习惯用法。 超时是一个很好的例子。在商用软件开发时，所有操作都需要有超时。</p>
<p>虽然 Go 的<strong>channel</strong>不直接支持超时，但很容易实现。假设我们想从通道 ch 接收，但希望实现一秒钟超时。 我们可以创建一个信号<strong>channel</strong>并启动一个在通道上发送之前休眠的 goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    timeout &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>我们可以使用<strong>select</strong>语句从<code>ch</code>或者<code>timeout</code>中接收。如果过了1秒还没有数据返回，超时的case会被选中，尝试从<code>ch</code>读取的操作被放弃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="comment">// a read from ch has occurred</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">    <span class="comment">// the read from ch has timed out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timeout channel有1个buffer，允许超时 goroutine 发送到通道然后退出。 goroutine 不关心这个值是否被接收了。这意味着如果 ch 接收发生在超时之前，goroutine 不会永远挂起。timeout channel 最终会被gc释放。</p>
<p>（在这个例子中，我们使用 time.Sleep 来演示 goroutines 和通道的机制。在实际程序中，你应该使用 <a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#After">time.After</a>来完成这个延迟发送）</p>
<p>让我们看看这种模式的另一种变体。在这个例子中，我们有一个程序可以同时从多个数据库的副本中读取数据。程序只需要一个结果，它应该接受最先返回的结果。</p>
<p>函数 Query 接受多个数据库连接和一个查询字符串。它并行查询每个数据库并返回它收到的第一个响应：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(conns []Conn, query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    <span class="keyword">for</span> _, conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c Conn)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- c.DoQuery(query):</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，闭包执行<strong>非阻塞发送</strong>，它通过在把<code>send</code>放在带有<code>default</code>的<code>select</code>中实现。 如果<code>send</code>不能立即完成，则将选择<code>default</code>情况。 <strong>非阻塞发送</strong>保证循环中启动的任何 goroutine 都不会挂起。 </p>
<p>但是，这个例子中有一个问题，如果结果在主函数执行到11行接收的时候之前到达，发送都会失败，最终函数无法取得结果。</p>
<p>这个问题是所谓的竞争条件的教科书示例，修复非常简单。 我们只要保证channel有着缓冲通道（通过添加缓冲区长度作为 make 的第二个参数）来保证第一次发送有一个放置值的地方。 这确保发送总是成功，并且无论执行顺序如何，第一个值都会被获取。</p>
<p>这两个例子展示了 Go 可以简单地表达 goroutines 之间复杂的交互。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/06/21/Go%20time.Time%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/21/Go%20time.Time%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/" class="post-title-link" itemprop="url">Go time.Time 应该使用值传递还是指针引用传递</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-21 14:48:57" itemprop="dateCreated datePublished" datetime="2021-06-21T14:48:57+08:00">2021-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h3><p>大部分场景应该使用值传递。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>Go 的文档指出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time. A Time value can be used by multiple goroutines simultaneously.</span><br></pre></td></tr></table></figure>

<p>翻译一下就是</p>
<p>程序使用times典型场景应该把它们当做值传递，而非指针。也就是说time变量及结构体field应该为<code>time.Time</code>，而不是<code>*time.Time</code>。Time值是协程安全的。之所以说<code>typically</code>，是因为有着那么不<code>typically</code>的场景，比如你想在方法内修改原来的<code>time.Time</code>对象这种场景（很少见）。</p>
<p><code>time.Time</code>是一个较小的对象，把它作为值传递是完全合理的。传递指针而不是值的很重要的一个原因是避免昂贵的拷贝动作。但是传递指针也会给gc带来一些额外的开销，如逃逸分析等。</p>
<p>值得一提的是，你可以通过<code>go build -gcflags=&quot;-m&quot;</code>来判断变量在堆中还是在栈中。</p>
<p><img src="/Images/go-time-pass.png" alt="go-time-pass"></p>
<p><code>time.Time</code>在我的MBP上只有24个字节。附上几个简单类型的字节数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte size is  1</span><br><span class="line">int32 size is  4</span><br><span class="line">int size is  8</span><br><span class="line">int64 size is  8</span><br><span class="line">float32 size is  4</span><br><span class="line">float64 size is  8</span><br><span class="line">time size is  24</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo_base</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSize</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">byte</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;byte size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;int32 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;int size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;int64 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">float32</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;float32 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;float64 size is &quot;</span>, unsafe.Sizeof(x))</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line">		fmt.Println(<span class="string">&quot;time size is &quot;</span>, unsafe.Sizeof(t))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/06/20/Go%20%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/20/Go%20%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Go 生成随机字符串的八种方式与性能测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-20 13:57:42" itemprop="dateCreated datePublished" datetime="2021-06-20T13:57:42+08:00">2021-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是**<a target="_blank" rel="noopener" href="https://stackoverflow.com/users/1705598/icza">icza</a>**<br>在StackOverflow上的一篇<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go/22892986#22892986">回答</a><br>，质量很高，翻译一下，大家一起学习</p>
<p>问题是：在go，有没有什么最快最简单的方法，用来生成只包含英文字母的随机字符串</p>
<p>icza给出了8个方案，最简单的方法并不是最快的方法，它们各有优劣，末尾附上性能测试结果：</p>
<h3 id="1-Runes"><a href="#1-Runes" class="headerlink" title="1. Runes"></a>1. Runes</h3><p>比较简单的答案，声明一个rune数组，通过随机数选取rune字符，拼接成结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> approach1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> letters = []<span class="type">rune</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">rune</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">		b[i] = letters[rand.Intn(<span class="built_in">len</span>(letters))]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestApproach1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	fmt.Println(randStr(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkApproach1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = randStr(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Bytes"><a href="#2-Bytes" class="headerlink" title="2. Bytes"></a>2. Bytes</h3><p>如果随机挑选的字符只包含英文字母，我们可以直接使用bytes，因为在UTF-8编码模式下，英文字符和Bytes是一对一的（Go正是使用UTF-8模式编码）</p>
<p>所以可以把</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = []<span class="type">rune</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>用这个替代</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = []<span class="type">byte</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者更好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> letters = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们有很大的进展了，我们把它变为了一个常数，在go里面，只有string常数，可并没有slice常数。额外的收获，表达式<code>len(letters)</code><br>也变为了一个常数（如果<code>s</code>为常数，那么<code>len(s)</code>也将是常数)</p>
<p>我们没有付出什么代码，现在<code>letters</code>可以通过下标访问其中的bytes了，这正是我们需要的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> approach2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letters = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">		b[i] = letters[rand.Intn(<span class="built_in">len</span>(letters))]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestApproach2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	fmt.Println(randStr(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkApproach2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = randStr(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Remainder"><a href="#3-Remainder" class="headerlink" title="3. Remainder"></a>3. Remainder</h3><p>上面的解决方法通过<code>rand.Intn()</code>来获得一个随机字母，这个方法底层调用了<code>Rand.Intn()</code>，然后调用了<code>Rand.Int31n()</code></p>
<p>相比于生成63个随机bits的函数<code>rand.Int63()</code>来说，<code>Rand.Int31n()</code>很慢。</p>
<p>我们可以简单地调用<code>rand.Int63()</code>然后除以<code>len(letterBytes)</code>，使用它的余数来生成字母</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> approach3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letters = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">		b[i] = letters[rand.Int63() % <span class="type">int64</span>(<span class="built_in">len</span>(letters))]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestApproach3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	fmt.Println(randStr(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkApproach3</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = randStr(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个算法能正常工作并且非常快，不过它牺牲了部分精确性，字母出现的概率并不是精确一样的（假设<code>rand.Int63()</code><br>生成63比特的数字是等概率的）。由于字母总共才52个，远小于 1&lt;&lt;63 - 1，因此失真非常小，因此实际上这完全没问题。</p>
<p>解释: 假设你想要0<del>5的随机数，如果使用3位的bit，3位的bit等概率出现0</del>7，所以出现0和1的概率是出现2、3、4概率的两倍。使用5位的<br>bit，0和1出现的概率是<code>6/32</code>，2、3、4出现的概率是<code>5/32</code>。现在接近了一些了，是吧？不断地增加比特位，这个差距就会变得越小，当你有63位地时候，这差别已经可忽略不计。</p>
<h3 id="4-Masking"><a href="#4-Masking" class="headerlink" title="4. Masking"></a>4. Masking</h3><p>在上一个方案的基础上，我们通过仅使用随机数的最低n位保持均匀分布，n为表示所有字符的数量。比如我们有52个字母，我们需要6位（52 &#x3D;<br>110100b）。所以我们仅仅使用了<code>rand.Int63()</code>的最后6位。并且，为了保持所有字符的均匀分布，我们决定只接受在<br><code>0..len(letterBytes)-1</code>的数字即0~51。（译者注：这里已经没有第三个方案的不准确问题了）</p>
<p>最低几位大于等于<code>len(letterBytes)</code>的概率一般小于<code>0.5</code><br>（平均值为0.25），这意味着出现这种情况，只要重试就好。重试n次之后，我们仍然需要丢弃这个数字的概率远小于0.5的n次方（这是上界了，实际会低于这个值）。以本文的52个字母为例，最低6位需要丢弃的概率只有<br><code>(64-52)/64=0.19</code>。这意味着，重复10次，仍然没有数字的概率是1*10^-8。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> approach4</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letters = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 6 bits to represent a letters index</span></span><br><span class="line">	letterIdBits = <span class="number">6</span></span><br><span class="line">	<span class="comment">// All 1-bits as many as letterIdBits</span></span><br><span class="line">	letterIdMask = <span class="number">1</span> &lt;&lt;letterIdBits - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">		<span class="keyword">if</span> idx := <span class="type">int</span>(rand.Int63() &amp; letterIdMask); idx &lt; <span class="built_in">len</span>(letters) &#123;</span><br><span class="line">			b[i] = letters[idx]</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestApproach4</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	fmt.Println(randStr(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkApproach4</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = randStr(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Masking-Improved"><a href="#5-Masking-Improved" class="headerlink" title="5. Masking Improved"></a>5. Masking Improved</h3><p>第4节的方案只使用了<code>rand.Int63()</code>方法返回的64个随机字节的后6位。这实在是太浪费了，因为<code>rand.Int63()</code>是我们算法中最耗时的部分了。</p>
<p>如果我们有52个字母，6位就能生成一个随机字符串。所以63个随机字节，可以利用<code>63/6=10</code>次。</p>
<p>译者注：使用了缓存，缓存了<code>rand.Int63()</code>方法返回的内容，使用10次，不过已经并不是协程安全的了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> approach5</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letters = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 6 bits to represent a letter index</span></span><br><span class="line">	letterIdBits = <span class="number">6</span></span><br><span class="line">	<span class="comment">// All 1-bits as many as letterIdBits</span></span><br><span class="line">	letterIdMask = <span class="number">1</span>&lt;&lt;letterIdBits - <span class="number">1</span></span><br><span class="line">	letterIdMax  = <span class="number">63</span> / letterIdBits</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	<span class="comment">// A rand.Int63() generates 63 random bits, enough for letterIdMax letters!</span></span><br><span class="line">	<span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, rand.Int63(), letterIdMax; i &gt;= <span class="number">0</span>; &#123;</span><br><span class="line">		<span class="keyword">if</span> remain == <span class="number">0</span> &#123;</span><br><span class="line">			cache, remain = rand.Int63(), letterIdMax</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> idx := <span class="type">int</span>(cache &amp; letterIdMask); idx &lt; <span class="built_in">len</span>(letters) &#123;</span><br><span class="line">			b[i] = letters[idx]</span><br><span class="line">			i--</span><br><span class="line">		&#125;</span><br><span class="line">		cache &gt;&gt;= letterIdBits</span><br><span class="line">		remain--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestApproach5</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	fmt.Println(randStr(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkApproach5</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = randStr(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-Source"><a href="#6-Source" class="headerlink" title="6. Source"></a>6. Source</h3><p>第5个方案非常好，能改进的点并不多。我们可以但不值得搞得很复杂。</p>
<p>让我们来找可以改进的点：<strong>随机数的生成源</strong></p>
<p><code>crypto/rand</code>的包提供了<code>Read(b []byte)</code>的函数，可以通过这个函数获得需要的随机比特数，只需要一次调用。不过并不能提升性能，因为<br><code>crypto/rand</code>实现了一个密码学上的安全伪随机数，所以速度比较慢。</p>
<p>所以让我们坚持使用<code>math/rand</code>包，<code>rand.Rand</code>使用<code>rand.Source</code>作为随机位的来源，<code>rand.Source</code>是一个声明了<code>Int63() int64</code><br>的接口：正是我们在最新解决方案中需要和使用的唯一方法。</p>
<p>所以我们不是真的需要<code>rand.Rand</code>，<code>rand.Source</code>包对于我们来说已经足够了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> approach6</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letters = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = rand.NewSource(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 6 bits to represent a letter index</span></span><br><span class="line">	letterIdBits = <span class="number">6</span></span><br><span class="line">	<span class="comment">// All 1-bits as many as letterIdBits</span></span><br><span class="line">	letterIdMask = <span class="number">1</span>&lt;&lt;letterIdBits - <span class="number">1</span></span><br><span class="line">	letterIdMax  = <span class="number">63</span> / letterIdBits</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	<span class="comment">// A rand.Int63() generates 63 random bits, enough for letterIdMax letters!</span></span><br><span class="line">	<span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, src.Int63(), letterIdMax; i &gt;= <span class="number">0</span>; &#123;</span><br><span class="line">		<span class="keyword">if</span> remain == <span class="number">0</span> &#123;</span><br><span class="line">			cache, remain = src.Int63(), letterIdMax</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> idx := <span class="type">int</span>(cache &amp; letterIdMask); idx &lt; <span class="built_in">len</span>(letters) &#123;</span><br><span class="line">			b[i] = letters[idx]</span><br><span class="line">			i--</span><br><span class="line">		&#125;</span><br><span class="line">		cache &gt;&gt;= letterIdBits</span><br><span class="line">		remain--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestApproach6</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(randStr(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkApproach6</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = randStr(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这里我们没有使用种子初始化rand了，取而代之的是初始化了<code>rand.Source</code></p>
<p>还有一件需要注意的事，<code>math/rand</code>的文档指出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认的Source是协程安全的</span><br></pre></td></tr></table></figure>

<p>所以默认的Source比通过<code>rand.NewSource()</code>创建出来的<code>Source</code>要慢。不用处理协程并发场景，当然慢啦。</p>
<h3 id="7-使用-strings-Builder"><a href="#7-使用-strings-Builder" class="headerlink" title="7. 使用 strings.Builder"></a>7. 使用 strings.Builder</h3><p>之前的解决方案都返回了通过slice构造的字符串。最后的一次转换进行了一次拷贝，因为字符串是不可变的，如果转换的时候不进行拷贝，就无法保证转换完成之后，byte<br>slice再被修改后，字符串仍能保持不变。</p>
<p>Go1.10引入了<strong>strings.Builder</strong>，这是一个新的类型，和bytes.Buffer类似，用来构造字符串。底层使用<code>[]byte</code><br>来构造内容，正是我们现在在做的，最后可以通过<code>Builder.String()</code>方法来获得最终的字符串值。但它很酷的地方在于，它无需执行刚才谈到的复制即可完成此操作。它敢这么做是因为它底层构造的<br><code>[]byte</code>从未暴露出来，所以仍然可以保证没有人可以无意地、恶意地来修改已经生成的不可变字符串。</p>
<p>所以我们的下一个想法不是在slice中构建随机字符串，而是在 strings.Builder 的帮助下，一旦我们完成，我们就可以获取并返回结果，而无需复制。<br>这可能在速度方面有所帮助，并且在内存使用和分配方面肯定会有所帮助（译者注：等会在benchmark中会清晰地看到）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/06/14/%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E6%B5%81%E8%BD%AC%E5%88%B0S3%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/14/%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E6%B5%81%E8%BD%AC%E5%88%B0S3%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">物联网平台规则引擎流转到S3对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-14 18:48:57" itemprop="dateCreated datePublished" datetime="2021-06-14T18:48:57+08:00">2021-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对于物联网平台来说，规则引擎是其中一个很重要的功能，也叫消息流转功能，将消息流转到各类中间件、云产品中。在华为、AWS、Azure、阿里这四个物联网平台中，阿里不支持流转到S3&#x2F;类S3存储中。本文对比一下华为云、AWS、Azure把设备消息流转到S3&#x2F;类S3存储的功能</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.amazonaws.cn/general/latest/gr/iot-core.html#limits_iot">https://docs.amazonaws.cn/general/latest/gr/iot-core.html#limits_iot</a></li>
</ul>
<h2 id="华为云"><a href="#华为云" class="headerlink" title="华为云"></a>华为云</h2><h3 id="规则粒度和限制"><a href="#规则粒度和限制" class="headerlink" title="规则粒度和限制"></a>规则粒度和限制</h3><ul>
<li><p>规则配置粒度到<strong>OBS</strong>桶</p>
</li>
<li><p>限制单用户配置100条规则，每个规则10个Action</p>
</li>
</ul>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>针对华为云，我测试了设备的消息上报转发到华为云OBS的功能。</p>
<p>流转规则需要指定obs桶，随后运行之后，华为云OBS体现为</p>
<ul>
<li>设备的每条消息都会在obs中存储为一个文件</li>
<li>名称采用deviceId+毫秒级时间戳+后面4位数字</li>
</ul>
<h3 id="关键路径截图"><a href="#关键路径截图" class="headerlink" title="关键路径截图"></a>关键路径截图</h3><h4 id="配置规则时指定到obs桶"><a href="#配置规则时指定到obs桶" class="headerlink" title="配置规则时指定到obs桶"></a>配置规则时指定到obs桶</h4><p><img src="/Images/iot-push-s31.png" alt="image-20210614184348066"></p>
<h4 id="单条消息单个文件"><a href="#单条消息单个文件" class="headerlink" title="单条消息单个文件"></a>单条消息单个文件</h4><p><img src="/Images/iot-push-s32.png" alt="image-20210614184522958"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>可以非常轻易地查询出单个设备的消息，因为文件名携带有毫秒级时间戳，还可以指定具体</p>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>用来做MapReduce的话，文件数目太多，由于S3云厂商往往通过API调用次数收费，不仅是速度，成本也会很高。</p>
<h2 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h2><h3 id="规则粒度和限制-1"><a href="#规则粒度和限制-1" class="headerlink" title="规则粒度和限制"></a>规则粒度和限制</h3><ul>
<li>规则配置粒度到桶及Key，相当于华为云OBS桶+文件名</li>
<li>限制规则每秒进行20k次运算</li>
<li>限制最多拥有1000条规则</li>
<li>限制每个规则最多10个action</li>
</ul>
<h3 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h3><p>再次上报数据触发规则会把obs中的数据替换。（通过版本控制可以获取到老的数据）</p>
<h3 id="关键路径截图-1"><a href="#关键路径截图-1" class="headerlink" title="关键路径截图"></a>关键路径截图</h3><h4 id="配置规则指定粒度到Key"><a href="#配置规则指定粒度到Key" class="headerlink" title="配置规则指定粒度到Key"></a>配置规则指定粒度到Key</h4><p><img src="/Images/iot-push-s33.png" alt="image-20210614165708645"> </p>
<h4 id="仅有一个Key，新值覆盖旧值"><a href="#仅有一个Key，新值覆盖旧值" class="headerlink" title="仅有一个Key，新值覆盖旧值"></a>仅有一个Key，新值覆盖旧值</h4><p><img src="/Images/iot-push-s34.png" alt="image-20210614170447237"></p>
<h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><p>AWS的这个模式很适合存储每个设备的最新数据。不过由于规则数量上的限制，最多只能在S3上存储1000个键值对。可用性较低。可用于数量小于1000的设备，存储、查询最新数据。</p>
<h2 id="Azure转发"><a href="#Azure转发" class="headerlink" title="Azure转发"></a>Azure转发</h2><h3 id="规则粒度限制"><a href="#规则粒度限制" class="headerlink" title="规则粒度限制"></a>规则粒度限制</h3><ul>
<li>规则配置粒度到存储容器</li>
<li>Azure可配置存储入存储容器的批量频率和大小限制</li>
<li>编码支持Avro和Json两种格式</li>
<li>最多100条路由</li>
</ul>
<h3 id="功能实现-2"><a href="#功能实现-2" class="headerlink" title="功能实现"></a>功能实现</h3><p>自上报事件，到存储中出现数据，azure是最慢的，azure做了批量的缓冲，达到batch的大小和时间要求后才会写入存储。</p>
<h3 id="关键路径截图-2"><a href="#关键路径截图-2" class="headerlink" title="关键路径截图"></a>关键路径截图</h3><h4 id="配置路由规则"><a href="#配置路由规则" class="headerlink" title="配置路由规则"></a>配置路由规则</h4><p><img src="/Images/iot-push-s35.png" alt="image-20210614181514437"></p>
<h4 id="存储中批量数据"><a href="#存储中批量数据" class="headerlink" title="存储中批量数据"></a>存储中批量数据</h4><p>因为选择了avro格式，所以vim打开是乱码，不过明显可以看到是多条数据</p>
<p><img src="/Images/iot-push-s36.png" alt="image-20210614181738380"></p>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>Azure的这种方式，比较适合做MapReduce类操作，相对华为云来说，Azure的文件数量大大减少，如果用于做MapReduce这类操作，因为文件碎片小，作业速度会比华为云快，而且由于云厂商对存储，通常以api调用次数收费，价格也会比华为云低。</p>
<h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><p>不易针对单个设备进行查询。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/05/30/%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/cert-manager" class="post-title-link post-title-link-external" itemprop="url">大型系统中的证书管理<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-30 22:47:05" itemprop="dateCreated datePublished" datetime="2021-05-30T22:47:05+08:00">2021-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="大型系统中的证书管理"><a href="#大型系统中的证书管理" class="headerlink" title="大型系统中的证书管理"></a>大型系统中的证书管理</h1><p>随着安全的要求，现在我们在越来越多的通信中使用TLS加密。下图是一个微服务架构下数据流向的例子</p>
<p><img src="/Images/cert-manager1.png" alt="cert-manager1"></p>
<ul>
<li>蓝色部分，即和三方交互时需要TLS加密认证</li>
<li>红色部分，各个微服务、消息中间件等通信需要TLS加密认证</li>
<li>绿色部分，各个微服务和存储层通信也需要TLS加密认证</li>
</ul>
<p>安全上对我们的要求逐步变化为，仅蓝色使用TLS&#x3D;》蓝色和红色使用TLS&#x3D;》全部使用TLS加密</p>
<h2 id="证书管理的必要性"><a href="#证书管理的必要性" class="headerlink" title="证书管理的必要性"></a>证书管理的必要性</h2><p>从安全的角度上来说，我们最好能支持证书的更换和热加载。如果您的业务当前使用加密的场景不多，可能暂时看不到证书管理的意义。但是当你在各个方面使用TLS更加频繁之后，会发现证书管理可带来如下好处：</p>
<ul>
<li>可以通过抽象出场景，通过场景和证书的关联联系，在各个地方通信使用的证书，可以统一更换。</li>
<li>统一提供证书过期告警等功能</li>
<li>统一提供证书的变更通知，通知到各个实例</li>
</ul>
<p>以我在工作中接触到的两个基础PAAS平台，都有证书管理的功能，可见证书管理的必要性。</p>
<p>PS: 开源组件大多都拥有证书配置能力，没有可对接证书管理的能力，但这个能力很难贡献给社区，需要自己开发。</p>
<h2 id="证书管理概念"><a href="#证书管理概念" class="headerlink" title="证书管理概念"></a>证书管理概念</h2><p>在TLS会话中，从依赖的证书文件角度来看，可以分为加密流程和验证流程。</p>
<h3 id="加密证书"><a href="#加密证书" class="headerlink" title="加密证书"></a>加密证书</h3><p>TLS加密流程的证书，包含证书链文件和密钥</p>
<h3 id="验证证书"><a href="#验证证书" class="headerlink" title="验证证书"></a>验证证书</h3><p>TLS验证流程的证书，仅包含证书链文件</p>
<h3 id="拆分为加密流程和验证流程的合理性"><a href="#拆分为加密流程和验证流程的合理性" class="headerlink" title="拆分为加密流程和验证流程的合理性"></a>拆分为加密流程和验证流程的合理性</h3><p>这使得加密流程证书和验证流程证书可以互相独立的替换，更方便在大型场景下复用证书。</p>
<p>让我们来假设如下的场景：</p>
<p><img src="/Images/cert-manager2.png" alt="cert-manager2"></p>
<p>客户A、客户B、客户C、客户D的验证流程证书自然不相同，但服务跟客户交互的时候，使用的加密流程证书确实同一份。如果将两个阶段的证书合一，那么在更换证书的时候，就需要更新4份数据，当你有1000名用户的时候，这个数字将会是1000，这对于存储和应用程序来说都是不小的冲击。</p>
<h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>Scene是在一个会话中，代表会话和请求证书、验证证书的绑定关系。Scene和请求证书、验证证书都是1：1的关系。这使得我们不仅仅可以修改证书文件，也可以对TLS会话中使用的证书进行修改。在证书无法复用，且证书绑定了多个场景的时候，针对单个场景修改其绑定的证书。</p>
<p>以上图作为例子，假设客户D有特殊的要求，要求加密流程使用特定的证书或密钥，我们就可以将客户D的场景绑定到客户D独有的加密证书</p>
<h3 id="多集群管理"><a href="#多集群管理" class="headerlink" title="多集群管理"></a>多集群管理</h3><p>如果证书管理需要管理多个集群，那么证书和Scene前面可以加上层级来隔离，如环境、集群等。</p>
<h3 id="对小型系统的建议"><a href="#对小型系统的建议" class="headerlink" title="对小型系统的建议"></a>对小型系统的建议</h3><p>如果规模不大，且TLS场景有限，需要考虑一下有无拆分加密证书和验证证书的必要，可以合一，应用程序直接以合一的证书id来关联，而非场景id。虽不方便复用，但大大降低了复杂性。</p>
<h2 id="证书管理的功能"><a href="#证书管理的功能" class="headerlink" title="证书管理的功能"></a>证书管理的功能</h2><p><img src="/Images/cert-manager3.png" alt="cert-manager3"></p>
<h2 id="证书管理场景"><a href="#证书管理场景" class="headerlink" title="证书管理场景"></a>证书管理场景</h2><h3 id="设定一个TLS会话"><a href="#设定一个TLS会话" class="headerlink" title="设定一个TLS会话"></a>设定一个TLS会话</h3><p><img src="/Images/cert-manager4.png" alt="cert-manager4"></p>
<h3 id="使用TLS会话"><a href="#使用TLS会话" class="headerlink" title="使用TLS会话"></a>使用TLS会话</h3><p>这要求应用程序持久化场景信息</p>
<p><img src="/Images/cert-manager5.png" alt="cert-manager5"></p>
<h2 id="组织架构相关"><a href="#组织架构相关" class="headerlink" title="组织架构相关"></a>组织架构相关</h2><p>大型系统下，证书管理是一个必须的组件，且一定是由团队最底层的组织架构承接。如若不然，那么由底层组织架构维护的组件，因为依赖关系，无法基于证书管理来统一实现证书的更换和过期告警。除非不基于证书管理自己构筑一套能力。</p>
<h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><p>随着组件和使用加密场景的不断扩大，证书管理是一个必须的组件，通过抽象出场景的概念来复用证书，通过变更通知在微服务模式下快速更换所有微服务实例上的证书，并提供统一的证书过期告警功能来提醒管理员更换证书。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhangjian He</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
