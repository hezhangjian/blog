<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hezhangjian.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"normal"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="张俭的博客">
<meta property="og:url" content="https://hezhangjian.com/page/9/index.html">
<meta property="og:site_name" content="张俭的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhangjian He">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hezhangjian.com/page/9/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>张俭的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">张俭的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangjian He</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hezhangjian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/hezhangjian" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2018/09/09/WireShark%20%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/wireshark-display-filter" class="post-title-link post-title-link-external" itemprop="url">Wireshark 显示过滤器<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-09 09:55:09" itemprop="dateCreated datePublished" datetime="2018-09-09T09:55:09+08:00">2018-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何使用显示过滤器"><a href="#如何使用显示过滤器" class="headerlink" title="如何使用显示过滤器"></a>如何使用显示过滤器</h1><p><img src="/Images/wireshark-display-filter1.png" alt="wireshark-display-filter1"><br>或者按住 CTRL + F，输入显示过滤器<br><img src="/Images/wireshark-display-filter2.png" alt="wireshark-display-filter2"></p>
<h2 id="二层显示过滤器举例"><a href="#二层显示过滤器举例" class="headerlink" title="二层显示过滤器举例"></a>二层显示过滤器举例</h2><h3 id="长度小于128字节的数据包"><a href="#长度小于128字节的数据包" class="headerlink" title="长度小于128字节的数据包"></a>长度小于128字节的数据包</h3><p>frame.len&lt;&#x3D;128</p>
<h3 id="排除ARP流量"><a href="#排除ARP流量" class="headerlink" title="排除ARP流量"></a>排除ARP流量</h3><p>!arp</p>
<h2 id="三层显示过滤器举例"><a href="#三层显示过滤器举例" class="headerlink" title="三层显示过滤器举例"></a>三层显示过滤器举例</h2><h3 id="只显示192-168-0-1-IP相关数据包"><a href="#只显示192-168-0-1-IP相关数据包" class="headerlink" title="只显示192.168.0.1 IP相关数据包"></a>只显示192.168.0.1 IP相关数据包</h3><p>ip.addr&#x3D;&#x3D;192.168.0.1</p>
<h2 id="四层显示过滤器举例"><a href="#四层显示过滤器举例" class="headerlink" title="四层显示过滤器举例"></a>四层显示过滤器举例</h2><h3 id="排除RDP流量"><a href="#排除RDP流量" class="headerlink" title="排除RDP流量"></a>排除RDP流量</h3><p>!tcp.port&#x3D;&#x3D;3389</p>
<h3 id="具有SYN标志的TCP数据包"><a href="#具有SYN标志的TCP数据包" class="headerlink" title="具有SYN标志的TCP数据包"></a>具有SYN标志的TCP数据包</h3><p>tcp.flags.syn&#x3D;&#x3D;1</p>
<h3 id="具有RST标志的TCP数据包"><a href="#具有RST标志的TCP数据包" class="headerlink" title="具有RST标志的TCP数据包"></a>具有RST标志的TCP数据包</h3><p>tcp.flags.rst&#x3D;&#x3D;1</p>
<h3 id="TCP确认时间较久"><a href="#TCP确认时间较久" class="headerlink" title="TCP确认时间较久"></a>TCP确认时间较久</h3><p>tcp.analysis.ack_rtt &gt; 0.2 and tcp.len &#x3D;&#x3D; 0<br>###启用TCP Relative Sequence Number的情况<br>如何启用?<br>Edit -&gt; Preferences -&gt; Protocols -&gt; TCP Relative Sequence Numbers</p>
<h3 id="握手被对方拒绝的包"><a href="#握手被对方拒绝的包" class="headerlink" title="握手被对方拒绝的包"></a>握手被对方拒绝的包</h3><p>tcp.flags.reset &#x3D;&#x3D; 1 &amp;&amp; tcp.seq &#x3D;&#x3D; 1</p>
<h3 id="客户端重传"><a href="#客户端重传" class="headerlink" title="客户端重传"></a>客户端重传</h3><p>tcp.flags.syn &#x3D;&#x3D; 1 &amp;&amp; tcp.analysis.retransmission</p>
<h3 id="Tcp包含"><a href="#Tcp包含" class="headerlink" title="Tcp包含"></a>Tcp包含</h3><p>tcp contains {str}</p>
<h2 id="应用层显示过滤器举例"><a href="#应用层显示过滤器举例" class="headerlink" title="应用层显示过滤器举例"></a>应用层显示过滤器举例</h2><h3 id="所有http流量"><a href="#所有http流量" class="headerlink" title="所有http流量"></a>所有http流量</h3><p>http</p>
<h3 id="文本管理流量"><a href="#文本管理流量" class="headerlink" title="文本管理流量"></a>文本管理流量</h3><p>tcp.port &#x3D;&#x3D; 23 || tcp.port &#x3D;&#x3D; 21</p>
<h3 id="文本email流量"><a href="#文本email流量" class="headerlink" title="文本email流量"></a>文本email流量</h3><p>email || pop || imap</p>
<h3 id="只显示访问某指定主机名的HTTP协议数据包"><a href="#只显示访问某指定主机名的HTTP协议数据包" class="headerlink" title="只显示访问某指定主机名的HTTP协议数据包"></a>只显示访问某指定主机名的HTTP协议数据包</h3><p>http.host &#x3D;&#x3D; &lt;”hostname”&gt;</p>
<h3 id="只显示包含HTTP-GET方法的HTTP协议数据包"><a href="#只显示包含HTTP-GET方法的HTTP协议数据包" class="headerlink" title="只显示包含HTTP GET方法的HTTP协议数据包"></a>只显示包含HTTP GET方法的HTTP协议数据包</h3><p>http.request.method &#x3D;&#x3D; ‘GET’</p>
<h3 id="只显示HTTP-客户端发起的包含指定URI请求的HTTP协议数据包"><a href="#只显示HTTP-客户端发起的包含指定URI请求的HTTP协议数据包" class="headerlink" title="只显示HTTP 客户端发起的包含指定URI请求的HTTP协议数据包"></a>只显示HTTP 客户端发起的包含指定URI请求的HTTP协议数据包</h3><p>http.request.uri &#x3D;&#x3D; &lt;”Full request URI”&gt;</p>
<h3 id="只显示包含ZIP文件的数据包"><a href="#只显示包含ZIP文件的数据包" class="headerlink" title="只显示包含ZIP文件的数据包"></a>只显示包含ZIP文件的数据包</h3><p>http matches “.zip” &amp;&amp; http.request.method &#x3D;&#x3D; ‘GET’</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2018/09/09/WireShark%20%E6%8D%95%E8%8E%B7%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/wireshark-capture-filter" class="post-title-link post-title-link-external" itemprop="url">Wireshark 捕获过滤器<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-09 09:47:02" itemprop="dateCreated datePublished" datetime="2018-09-09T09:47:02+08:00">2018-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何使用捕获过滤器"><a href="#如何使用捕获过滤器" class="headerlink" title="如何使用捕获过滤器"></a>如何使用捕获过滤器</h1><p>点击捕获，选项，然后在所选择的捕获过滤器上输入对应的捕获表达式</p>
<p><img src="/Images/wireshark-capture-filter1.png" alt="wireshark-capture-filter1"></p>
<p><img src="/Images/wireshark-capture-filter2.png" alt="wireshark-capture-filter2"></p>
<h1 id="抓包过滤器"><a href="#抓包过滤器" class="headerlink" title="抓包过滤器"></a>抓包过滤器</h1><ul>
<li>type(类型) 限定符: 比如host，net，port限定符等</li>
<li>dir(方向) 限定符: src dst</li>
<li>Proto(协议类型)限定符: ether ip arp</li>
</ul>
<h2 id="二层过滤器举例"><a href="#二层过滤器举例" class="headerlink" title="二层过滤器举例"></a>二层过滤器举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcp dst port 135 //tcp协议，目标端口为135的数据包</span><br><span class="line">ether host &lt;Ethernet host&gt; //让wireshark只抓取这个地址相关的以太网帧</span><br><span class="line">ether dst &lt;Ethernet host&gt;</span><br><span class="line">ether src &lt;Ethernet src&gt;</span><br><span class="line">ether broadcast //Wireshark只抓取所有以太网广播流量</span><br><span class="line">ether multicast //只抓取多播流量</span><br><span class="line">ether proto &lt;protocol&gt;</span><br><span class="line">vlan &lt;vlan_id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三层过滤器举例"><a href="#三层过滤器举例" class="headerlink" title="三层过滤器举例"></a>三层过滤器举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip #只抓取ipv4流量</span><br><span class="line">ipv6</span><br><span class="line">host 10.0.0.2</span><br><span class="line">dest host &lt;host&gt;</span><br><span class="line">src host &lt;host&gt;</span><br><span class="line">broadcast #ip广播包</span><br><span class="line">multicast #ip多播包</span><br><span class="line">ip proto &lt;protocol code&gt; #ip数据包有多种类型，比如TCP(6), UDP(17) ICMP(1)</span><br></pre></td></tr></table></figure>

<h3 id="只抓取源于或者发往IPv6-2001-16的数据包"><a href="#只抓取源于或者发往IPv6-2001-16的数据包" class="headerlink" title="只抓取源于或者发往IPv6 2001::&#x2F;16的数据包"></a>只抓取源于或者发往IPv6 2001::&#x2F;16的数据包</h3><p>net 2001::&#x2F;16</p>
<h3 id="只抓取ICMP流量"><a href="#只抓取ICMP流量" class="headerlink" title="只抓取ICMP流量"></a>只抓取ICMP流量</h3><p>ip proto 1</p>
<h3 id="只抓取ICMP-echo-request流量"><a href="#只抓取ICMP-echo-request流量" class="headerlink" title="只抓取ICMP echo request流量"></a>只抓取ICMP echo request流量</h3><p>icmp[icmptype]&#x3D;&#x3D;icmp-echo<br>icmp[icmptype]&#x3D;&#x3D;8</p>
<h3 id="只抓取特定长度的IP数据包"><a href="#只抓取特定长度的IP数据包" class="headerlink" title="只抓取特定长度的IP数据包"></a>只抓取特定长度的IP数据包</h3><p>ip[2:2] &#x3D;&#x3D; <number></p>
<h3 id="只抓取具有特定TTL的IP数据包"><a href="#只抓取具有特定TTL的IP数据包" class="headerlink" title="只抓取具有特定TTL的IP数据包"></a>只抓取具有特定TTL的IP数据包</h3><p>ip[8] &#x3D;&#x3D; <number></p>
<h3 id="抓取数据包的源和目的IP地址相同"><a href="#抓取数据包的源和目的IP地址相同" class="headerlink" title="抓取数据包的源和目的IP地址相同"></a>抓取数据包的源和目的IP地址相同</h3><p>ip[12:4] &#x3D;&#x3D;1 ip[16:4]</p>
<h2 id="四层抓包过滤器举例"><a href="#四层抓包过滤器举例" class="headerlink" title="四层抓包过滤器举例"></a>四层抓包过滤器举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port &lt;port&gt;</span><br><span class="line">dst port &lt;port&gt;</span><br><span class="line">src port &lt;port&gt;</span><br><span class="line">tcp portrange &lt;p1&gt;-&lt;p2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="只抓取TCP中SYN或者FIN的数据包"><a href="#只抓取TCP中SYN或者FIN的数据包" class="headerlink" title="只抓取TCP中SYN或者FIN的数据包"></a>只抓取TCP中SYN或者FIN的数据包</h3><p>tcp [tcpflags] &amp; (tcp-syn | tcp-fin) !&#x3D; 0</p>
<h3 id="只抓所有RST标记位置为1的TCP数据包"><a href="#只抓所有RST标记位置为1的TCP数据包" class="headerlink" title="只抓所有RST标记位置为1的TCP数据包"></a>只抓所有RST标记位置为1的TCP数据包</h3><p>tcp[tcpflags] &amp; (tcp-rst) !&#x3D; 0</p>
<h3 id="tcp头部的常用标记位"><a href="#tcp头部的常用标记位" class="headerlink" title="tcp头部的常用标记位"></a>tcp头部的常用标记位</h3><ul>
<li>SYN: 用来表示打开连接</li>
<li>FIN: 用来表示拆除连接</li>
<li>ACK: 用来确认收到的数据</li>
<li>RST: 用来表示立刻拆除连接</li>
<li>PSH: 用来表示应将数据提交给末端应用程序处理</li>
</ul>
<h3 id="抓取所有标记位都未置1的TCP流量"><a href="#抓取所有标记位都未置1的TCP流量" class="headerlink" title="抓取所有标记位都未置1的TCP流量"></a>抓取所有标记位都未置1的TCP流量</h3><p>该报文可能用于端口探测,即如果<br>tcp[13] &amp; 0x00 &#x3D; 0</p>
<h3 id="设置了URG位的TCP数据包"><a href="#设置了URG位的TCP数据包" class="headerlink" title="设置了URG位的TCP数据包"></a>设置了URG位的TCP数据包</h3><p>URG位,表示该数据包十分紧急,不进入缓冲区,直接送给进程<br>tcp[13] &amp; 32 &#x3D;&#x3D; 32</p>
<h3 id="设置了ACK位的TCP数据包"><a href="#设置了ACK位的TCP数据包" class="headerlink" title="设置了ACK位的TCP数据包"></a>设置了ACK位的TCP数据包</h3><p>tcp[13] &amp; 16 &#x3D;&#x3D; 16</p>
<h3 id="设置了PSH位的TCP数据包"><a href="#设置了PSH位的TCP数据包" class="headerlink" title="设置了PSH位的TCP数据包"></a>设置了PSH位的TCP数据包</h3><p>PSH代表这个消息要从缓冲区立刻发送给应用程序<br>tcp[13] &amp; 8 &#x3D;&#x3D; 8</p>
<h3 id="设置了RST位的TCP数据包"><a href="#设置了RST位的TCP数据包" class="headerlink" title="设置了RST位的TCP数据包"></a>设置了RST位的TCP数据包</h3><p>tcp[13] &amp; 4 &#x3D;&#x3D; 4</p>
<h3 id="设置了SYN位的TCP数据包"><a href="#设置了SYN位的TCP数据包" class="headerlink" title="设置了SYN位的TCP数据包"></a>设置了SYN位的TCP数据包</h3><p>tcp[13] &amp; 2 &#x3D;&#x3D; 2</p>
<h3 id="设置了FIN位的TCP数据包"><a href="#设置了FIN位的TCP数据包" class="headerlink" title="设置了FIN位的TCP数据包"></a>设置了FIN位的TCP数据包</h3><p>tcp[13] &amp; 1 &#x3D;&#x3D; 1</p>
<h3 id="TCP-SYN-ACK数据包"><a href="#TCP-SYN-ACK数据包" class="headerlink" title="TCP SYN-ACK数据包"></a>TCP SYN-ACK数据包</h3><p>tcp[13] &#x3D;&#x3D; 18</p>
<h3 id="抓取目的端口范围的数据包"><a href="#抓取目的端口范围的数据包" class="headerlink" title="抓取目的端口范围的数据包"></a>抓取目的端口范围的数据包</h3><p>tcp portrange 2000-2500</p>
<p>###tcpdump捕获过滤器</p>
<p>常见命令介绍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w hzj.pcap -s0 -iany port 1028</span><br></pre></td></tr></table></figure>

<p>上面的命令代表<br>-w hzj.pcap 存储在hzj.pcap这个文件中<br>-s 0 代表抓取字节数不限制,在大多数linux系统下,默认捕获每个帧的前96个字节</p>
<h3 id="tcpdump捕获一定范围的端口-9200-9400"><a href="#tcpdump捕获一定范围的端口-9200-9400" class="headerlink" title="tcpdump捕获一定范围的端口(9200-9400)"></a>tcpdump捕获一定范围的端口(9200-9400)</h3><p>tcpdump portrange 9200-9400</p>
<h3 id="tcpdump-r-可以阅读捕获的文件-建议拷贝到wireshark中分析"><a href="#tcpdump-r-可以阅读捕获的文件-建议拷贝到wireshark中分析" class="headerlink" title="tcpdump -r 可以阅读捕获的文件(建议拷贝到wireshark中分析)"></a>tcpdump -r 可以阅读捕获的文件(建议拷贝到wireshark中分析)</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2018/09/07/WireShark%20%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/wireshark-install-basic-op" class="post-title-link post-title-link-external" itemprop="url">Wireshark 安装及基本操作<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-07 21:41:22" itemprop="dateCreated datePublished" datetime="2018-09-07T21:41:22+08:00">2018-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="WireShark安装"><a href="#WireShark安装" class="headerlink" title="WireShark安装"></a>WireShark安装</h1><p>wireshark在windows和mac上的安装方式都比较简单,下面是Linux下的安装方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository ppa:wireshark-dev/stable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install wireshark</span><br><span class="line">#以root权限启动</span><br><span class="line">sudo wireshark</span><br></pre></td></tr></table></figure>

<h1 id="WireShark的名字解析"><a href="#WireShark的名字解析" class="headerlink" title="WireShark的名字解析"></a>WireShark的名字解析</h1><p><img src="/Images/wireshark-name-resolve.png" alt="wireshark-name-resolve"></p>
<ul>
<li>L2层的名字解析，对Mac地址进行解析，返回机器名</li>
<li>L3层 ip解析为域名</li>
<li>L4层 端口号解析为协议端口号</li>
</ul>
<h1 id="Wireshark抓到的包更改时间格式"><a href="#Wireshark抓到的包更改时间格式" class="headerlink" title="Wireshark抓到的包更改时间格式"></a>Wireshark抓到的包更改时间格式</h1><p><img src="/Images/wireshark-time-format.png" alt="wireshark-time-format"></p>
<h1 id="查看EndPoint"><a href="#查看EndPoint" class="headerlink" title="查看EndPoint"></a>查看EndPoint</h1><p>点击Statistics-&gt;EndPoints，可以查看每一个捕获文件里的每个端点</p>
<p><img src="/Images/wireshark-endpoint.png" alt="wireshark-endpoint"></p>
<h1 id="查看网络会话"><a href="#查看网络会话" class="headerlink" title="查看网络会话"></a>查看网络会话</h1><p>Statistics-&gt;Conversations. 查看地址A和地址B，以及每个设备发送或收到的数据包和字节数</p>
<p><img src="/Images/wireshark-conversation.png" alt="wireshark-conversation"></p>
<h1 id="基于协议分层结构的统计数据"><a href="#基于协议分层结构的统计数据" class="headerlink" title="基于协议分层结构的统计数据"></a>基于协议分层结构的统计数据</h1><p>Statistics-&gt;Protocol Hierarchy</p>
<p><img src="/Images/wireshark-protocol-hierarchy.png" alt="wireshark-protocol-hierarchy"></p>
<h1 id="跟随流功能"><a href="#跟随流功能" class="headerlink" title="跟随流功能"></a>跟随流功能</h1><p>右键选中一个数据包，然后右键，follow。比如我在这里跟随一个tcp流</p>
<p><img src="/Images/wireshark-tcp-stream.png" alt="wireshark-tcp-stream"></p>
<p>&#x2F;&#x2F;这里也可以使用decode as解码功能，但是没有例子，暂不附图</p>
<h1 id="查看IO图"><a href="#查看IO图" class="headerlink" title="查看IO图"></a>查看IO图</h1><p>Statistics-&gt;IO Graphs</p>
<p><img src="/Images/wireshark-io-graph.png" alt="wireshark-io-graph"></p>
<h1 id="双向时间图"><a href="#双向时间图" class="headerlink" title="双向时间图"></a>双向时间图</h1><p>Statistics-&gt;TCP Stream Graph -&gt; Round Trip Time Graph<br><img src="/Images/wireshark-rtt-graph.png" alt="wireshark-rtt-graph"></p>
<h1 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h1><p>Statistics-&gt;Flow Graph<br><img src="/Images/wireshark-flow-graph.png" alt="wireshark-flow-graph"></p>
<h1 id="专家信息"><a href="#专家信息" class="headerlink" title="专家信息"></a>专家信息</h1><p>Analyze-&gt;Expert Info Composite<br><img src="/Images/wireshark-expert-info.png" alt="wireshark-expert-info"></p>
<h2 id="触发的专家信息"><a href="#触发的专家信息" class="headerlink" title="触发的专家信息"></a>触发的专家信息</h2><h3 id="对话消息"><a href="#对话消息" class="headerlink" title="对话消息"></a>对话消息</h3><h3 id="窗口更新-由接收者发送，用来通知发送者TCP接收窗口的大小已被改变"><a href="#窗口更新-由接收者发送，用来通知发送者TCP接收窗口的大小已被改变" class="headerlink" title="窗口更新 由接收者发送，用来通知发送者TCP接收窗口的大小已被改变"></a>窗口更新 由接收者发送，用来通知发送者TCP接收窗口的大小已被改变</h3><h2 id="注意消息"><a href="#注意消息" class="headerlink" title="注意消息"></a>注意消息</h2><h3 id="TCP重传输-数据包丢失的结果，发生在收到重复的ACK，或者数据包的重传输计时器超时的时候"><a href="#TCP重传输-数据包丢失的结果，发生在收到重复的ACK，或者数据包的重传输计时器超时的时候" class="headerlink" title="TCP重传输 数据包丢失的结果，发生在收到重复的ACK，或者数据包的重传输计时器超时的时候"></a>TCP重传输 数据包丢失的结果，发生在收到重复的ACK，或者数据包的重传输计时器超时的时候</h3><h3 id="重复ACK-当一台主机没有收到下一个期望序列的数据包时，它会生成最近收到一次数据的重复ACK"><a href="#重复ACK-当一台主机没有收到下一个期望序列的数据包时，它会生成最近收到一次数据的重复ACK" class="headerlink" title="重复ACK 当一台主机没有收到下一个期望序列的数据包时，它会生成最近收到一次数据的重复ACK"></a>重复ACK 当一台主机没有收到下一个期望序列的数据包时，它会生成最近收到一次数据的重复ACK</h3><h3 id="零窗口探查ACK-用来响应零窗口探查数据包"><a href="#零窗口探查ACK-用来响应零窗口探查数据包" class="headerlink" title="零窗口探查ACK 用来响应零窗口探查数据包"></a>零窗口探查ACK 用来响应零窗口探查数据包</h3><h3 id="窗口已满-用来通知传输主机及其接收者的TCP接收窗口已满"><a href="#窗口已满-用来通知传输主机及其接收者的TCP接收窗口已满" class="headerlink" title="窗口已满 用来通知传输主机及其接收者的TCP接收窗口已满"></a>窗口已满 用来通知传输主机及其接收者的TCP接收窗口已满</h3><h2 id="警告消息"><a href="#警告消息" class="headerlink" title="警告消息"></a>警告消息</h2><h3 id="上一段丢失-指明数据包丢失-发生在当数据流中一个期望的序列号被跳过时。"><a href="#上一段丢失-指明数据包丢失-发生在当数据流中一个期望的序列号被跳过时。" class="headerlink" title="上一段丢失 指明数据包丢失,发生在当数据流中一个期望的序列号被跳过时。"></a>上一段丢失 指明数据包丢失,发生在当数据流中一个期望的序列号被跳过时。</h3><h3 id="收到丢失数据包的ACK-发生在当一个数据包已经确认丢失但受到了其ACK数据包时"><a href="#收到丢失数据包的ACK-发生在当一个数据包已经确认丢失但受到了其ACK数据包时" class="headerlink" title="收到丢失数据包的ACK 发生在当一个数据包已经确认丢失但受到了其ACK数据包时"></a>收到丢失数据包的ACK 发生在当一个数据包已经确认丢失但受到了其ACK数据包时</h3><h3 id="保活-当一个连接的保活数据包出现时触发"><a href="#保活-当一个连接的保活数据包出现时触发" class="headerlink" title="保活 当一个连接的保活数据包出现时触发"></a>保活 当一个连接的保活数据包出现时触发</h3><h3 id="零窗口-当接收方已经达到TCP接收窗口大小时，发出一个零窗口通知，要求发送方停止传输数据"><a href="#零窗口-当接收方已经达到TCP接收窗口大小时，发出一个零窗口通知，要求发送方停止传输数据" class="headerlink" title="零窗口 当接收方已经达到TCP接收窗口大小时，发出一个零窗口通知，要求发送方停止传输数据"></a>零窗口 当接收方已经达到TCP接收窗口大小时，发出一个零窗口通知，要求发送方停止传输数据</h3><h3 id="乱序-当数据包被乱序接收时，会利用序列号进行检测"><a href="#乱序-当数据包被乱序接收时，会利用序列号进行检测" class="headerlink" title="乱序 当数据包被乱序接收时，会利用序列号进行检测"></a>乱序 当数据包被乱序接收时，会利用序列号进行检测</h3><h3 id="快速重传输-一次重传会在收到一个重复ACK的20ms内进行"><a href="#快速重传输-一次重传会在收到一个重复ACK的20ms内进行" class="headerlink" title="快速重传输 一次重传会在收到一个重复ACK的20ms内进行"></a>快速重传输 一次重传会在收到一个重复ACK的20ms内进行</h3><h2 id="WireShark性能"><a href="#WireShark性能" class="headerlink" title="WireShark性能"></a>WireShark性能</h2><h3 id="Statistics-Summary-查看平均速度"><a href="#Statistics-Summary-查看平均速度" class="headerlink" title="Statistics -&gt; Summary 查看平均速度"></a>Statistics -&gt; Summary 查看平均速度</h3><h3 id="Analyze-Expert-Infos"><a href="#Analyze-Expert-Infos" class="headerlink" title="Analyze -&gt; Expert Infos"></a>Analyze -&gt; Expert Infos</h3><h3 id="Statistics-TCP-StreamGraph-TCP-Sequence-Graph-Stenens"><a href="#Statistics-TCP-StreamGraph-TCP-Sequence-Graph-Stenens" class="headerlink" title="Statistics -&gt; TCP StreamGraph -&gt; TCP Sequence Graph(Stenens)"></a>Statistics -&gt; TCP StreamGraph -&gt; TCP Sequence Graph(Stenens)</h3><h3 id="TCP-Previous-segment-not-captured"><a href="#TCP-Previous-segment-not-captured" class="headerlink" title="TCP Previous segment not captured"></a>TCP Previous segment not captured</h3><p>在TCP传输过程中,同一台主机发出的数据段应该是连续的,即后一个包的Seq号等于前一个包的Seq + Len. 如果在网络包中没有找到,就会出现这个错误</p>
<h3 id="TCP-ACKed-unseen-segment"><a href="#TCP-ACKed-unseen-segment" class="headerlink" title="TCP ACKed unseen segment"></a>TCP ACKed unseen segment</h3><p>Wireshark发现被Ack的那个包没被wireshark捕获</p>
<h3 id="TCP-Out-of-Order"><a href="#TCP-Out-of-Order" class="headerlink" title="TCP Out-of-Order"></a>TCP Out-of-Order</h3><p>在TCP传输过程中,同一台主机发出的数据段应该是连续的,即后一个包的Seq号等于前一个包的Seq +<br>Len.当Wireshark发现后一个包的Seq号小于前一个包的Seq+Len 就乱序le</p>
<h3 id="TCP-Dup-ACK"><a href="#TCP-Dup-ACK" class="headerlink" title="TCP Dup ACK"></a>TCP Dup ACK</h3><p>当乱序或者丢包的时候,接收方会收到Seq号比期望值大的包,每收到一个这种包就会Ack一次期望的Seq值</p>
<h3 id="TCP-Fast-Retransmission"><a href="#TCP-Fast-Retransmission" class="headerlink" title="TCP Fast Retransmission"></a>TCP Fast Retransmission</h3><p>当发送方收到3个或以上TCP Dup ACK,就意识到之前发的包可能丢了,触发快速重传</p>
<h3 id="TCP-Retransmission"><a href="#TCP-Retransmission" class="headerlink" title="TCP Retransmission"></a>TCP Retransmission</h3><p>没有触发tcp超时重传,超时重传</p>
<h3 id="TCP-zerowindow"><a href="#TCP-zerowindow" class="headerlink" title="TCP zerowindow"></a>TCP zerowindow</h3><p>缓存区已满,不能再接收数据了</p>
<h3 id="TCP-window-FUll"><a href="#TCP-window-FUll" class="headerlink" title="TCP window FUll"></a>TCP window FUll</h3><p>Wireshark检测到,发送方发送的数据会把接收方的接收窗口耗尽</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2017/08/18/Java%20NIO%20%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/08/18/Java%20NIO%20%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Java NIO 解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-18 20:20:31" itemprop="dateCreated datePublished" datetime="2017-08-18T20:20:31+08:00">2017-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="NIO-主要概念介绍"><a href="#NIO-主要概念介绍" class="headerlink" title="NIO 主要概念介绍"></a>NIO 主要概念介绍</h2><p>1.Buffers(缓冲区)<br>Buffer类是常规JAVA类和channels(管道)之间的通道。Buffer包含固定长度的数组中，数组中存放着原始数据，封装在一个包含状态的对象中。管道可以消耗缓冲区的数据，也可以向缓冲区中存入数据。此外，还有一种特殊类型的缓冲区，用于内存映射文件。</p>
<p>2.Channels(通道)<br>NIO中引入的最抽象的概念就是Channel。通道对象代表着通信连接。通信连接可以是单向的，也可以是双向的。可以理解成缓冲区和IO设备之间的道路。</p>
<p>一些java.io中的旧类也可以使用channel。为了和使用通道的文件，socket连接，或多或少地添加了新方法</p>
<p>大多数通道可以工作在非块模式下，有很好的可扩展性，尤其是在和Selectors(选择器)同时使用的时候。</p>
<p>3.File locking and memory-mapped files(文件锁和内存映射文件)<br>FileChannel对象提供许多面向文件的功能。比如文件锁这个进程之间处理数据必不可少的功能。把内存映射到文件，在你看来，文件就像是在内存之上一样，省去了把文件拷贝到内存的操作。</p>
<p>4.Sockets<br>SocketChannel 提供了一种和网络套接字新的交互方法，SocketChannel可以工作在非阻塞模式可以用来和Selectors一起工作。作为结果，许多scoket可以多路传输，比起java.net里的传统socket类更高效</p>
<p>5.Selectors<br>Selectors提供准备就绪选择(查看channel是否准备就绪)。也可以确定你感兴趣的Channel。通过使用Selector，大量的活动中的I&#x2F;O channel 可以被一个线程简单有效地监控操作。</p>
<p>6.Character sets(字符集)<br>提供了多种从byte流映射到字符的方式。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer即缓冲区，是包含有一定量数据的容器。Buffer的工作和Channel有着紧密的联系。Channel是I&#x2F;O的出入口，buffer就是IO的来源或者目标。<br>要向外传输数据，把数据存放在buffer中交给channel<br>要接受数据，提供buffer让channel写入。</p>
<p><img src="/Images/java-nio-buffer1.png" alt="Buffer的类图.jpg"></p>
<p>Capacity<br>  Buffer可以包含的最大字节数。当Buffer创建的时候，容量被设置而且不可更改</p>
<p>Limit<br>  Buffer中的第一个元素，这个元素不应该被读或者是被写。包含着在buffer中“存活”的数据个数</p>
<p>Position<br>  下一个被操作的数据的位置。put和get操作会更新position的位置</p>
<p>Mark<br>  一个有记忆的位置，设置了mark，之后可以回退到标记点，重新进行操作。</p>
<p>新创建一个大小为10的Buffer，概念中可以理解成是这样的</p>
<p><img src="/Images/java-nio-buffer1.png" alt="Buffer的类图.jpg"></p>
<p>下面是Buffer的方法签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Buffer&#123;</span><br><span class="line">  public final int capacity()</span><br><span class="line">  public final int position()</span><br><span class="line">  public final Buffer position (int newPosition)</span><br><span class="line">  public final int limit ()</span><br><span class="line">  public final Buffer limit(int newLimit)</span><br><span class="line">  public final Buffer mark()</span><br><span class="line">  public final Buffer reset()</span><br><span class="line">  public final Buffer clear()</span><br><span class="line">  public final Buffer flip()</span><br><span class="line">  public final Buffer rewind()</span><br><span class="line">  public final int remaining()</span><br><span class="line">  public final boolean hasRemaining();</span><br><span class="line">  public abstract boolean isReadOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会觉得有一些方法应该返回空值，但是却返回了buffer对象，这是为了构建一个流式的API。比如像这样的代码<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line">buffer.position(5);</span><br><span class="line">buffer.reset()</span><br><span class="line">//就可以写成下面这样</span><br><span class="line">buffer.mark().position(5).reset();</span><br></pre></td></tr></table></figure><br>所有的buffer都是可读的，但并不是所有的buffer都支持写操作，通过isReadOnly方法判断是否可以写，如果你试图向不支持写操作的buffer中写入数据，会抛出ReadOnlyBufferException异常。</p>
<p>Buffer管理着给定数目的数据元素。但是在大多数情况下，我们只关心其中的一部分数据。就像是，当我们想要向池子里倒水时，水盆里的水，只盛了一半。但我们需要追踪一些信息，buffer中已经有的数据，下一个处理哪个数据？position属性负责处理这个信息。当处理put（向buffer中写入数据）或者get方法（从buffer中获取数据）的时候，position就会更新。</p>
<p>尽管在<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4e955074b3f0">JAVA NIO BUFFER（一）</a>中，列表中没有put和get方法。但是每个Buffer都包含这两个方法，因为每个buffer的实现不同，需要处理不同的数据类型，没法被声明为抽象方法(nio在jdk1.4被引入，泛型是1.5)。我们用ByteBuffer作为例子，来看这两个方法的声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteBuffer extends Buffer implements Comparable &#123;</span><br><span class="line">  //列出了一部分api</span><br><span class="line">  public abstract byte get();</span><br><span class="line">  public abstract byte get(int index);</span><br><span class="line">  public abstract ByteBuffer put(byte b);</span><br><span class="line">  public abstract ByteBuffer put(int index, byte b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不指定具体的位置，put和get就会操作在现有的position属性上，并将position加1。如果超出了capacity。如果是读操作就会抛出BufferOverflowException,写操作就会BufferUnderflowException.如果是任意操作，也会抛出一个IndexOutOfBoundsException.</p>
<p>让我们试着对ByteBuffer中写入数据，如果执行下面的命令，<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4e955074b3f0">JAVA NIO BUFFER（一）</a>中的概念图，就会变成如下的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put((byte)&#x27;H&#x27;).put((byte)&#x27;e&#x27;).put((byte)&#x27;l&#x27;).put((byte)&#x27;l&#x27;).put((byte)&#x27;o&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/Images/java-nio-buffer2.png" alt="B2CE351E19F8ECB67C2AD0AEE197EE5B.jpg"></p>
<p>猜一猜，如果执行这个命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(0,(byte)&#x27;M&#x27;).put((byte)&#x27;w&#x27;);</span><br></pre></td></tr></table></figure>
<p>会变成什么样子？</p>
<p><img src="/Images/java-nio-buffer3.png" alt="1D7142D68BB086C4A65AD87549C30598.jpg"></p>
<p>会变成这样！，第一个把0位置的H替换为M，然后紧接着的put操作查看到了position在5位置，把5位置写入W,然后position自加变为6.</p>
<p>我们准备好了Buffer，现在我们要将它交由Channel处理。现在假设我们填满了一个Buffer，emmmm，然后把它传给Channel对象，Channel对象对buffer调用get方法，然后position自加，会怎么样？IndexOutOfBoundsException被抛出了！</p>
<p>那怎么办？为了让Channel能够处理对象，我们需要把postion重设为你希望它开始处理的位置，顺便再设置limite为现在存储的位置，假设我们需要Channel从头开始处理对象，那么就应该做如下的处理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.limit(buffer.position()).position(0);</span><br><span class="line">//上面的调用，等同于如下的方法</span><br><span class="line">buffer.flip();</span><br></pre></td></tr></table></figure>
<p>然后概念图就会变成下面这样:<br><img src="/Images/java-nio-buffer4.png" alt="157F5BA61609A874814F433E2D7CDA26.jpg"><br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4e955074b3f0">JAVA NIO BUFFER（一）</a>中提到的rewind()方法，只把position设置为0，并不影响limit的位置。</p>
<p>进行完这个操作之后，你就可以试着读取里面的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//利用hasRemaining()方法判断Buffer中是否还有数据</span><br><span class="line">for(int i=0;buffer.hasRemaining();i++) &#123;</span><br><span class="line">  myByteArray[I]=buffer.get();</span><br><span class="line">&#125;</span><br><span class="line">//上面的方法未必高效，循环体中每次循环都要进行一次判断</span><br><span class="line">//你可以使用remaining()方法，返回剩余的数目</span><br><span class="line">int count = buffer.remaining();</span><br><span class="line">for(int i=0;buffer.count;i++) &#123;</span><br><span class="line">  myByteArray[I]=buffer.get();</span><br><span class="line">&#125;</span><br><span class="line">//如果你对Buffer有着惊人的控制，那么不进行数据检查将会是最快的</span><br></pre></td></tr></table></figure>
<p>一旦Buffer使用完毕，它就可以进行复用，clear()方法把一个Buffer重置到一个空的状态。它不更改任何数据，把limit设置为capacity，并把position设置为0.至于里面是不是还有数据？这不重要，Buffer仅仅通过position来判断数据的“死活”为什么一定要将数据置空，这些操作难道不需要时间吗？下面的例子使用到了一些buffer的基本操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class BufferFillDrain &#123;</span><br><span class="line">    //原代码作者 Ron Hitchens (ron@ronsoft.com)</span><br><span class="line">    private static int index = 0;</span><br><span class="line"></span><br><span class="line">    private static String[] strings = &#123;</span><br><span class="line">            &quot;Hello, this is ZhangJian&quot;,</span><br><span class="line">            &quot;He likes Eminem&quot;,</span><br><span class="line">            &quot;Put the dick in the dust&quot;,</span><br><span class="line">            &quot;And? Fuck the world?&quot;,</span><br><span class="line">            &quot;Lyrics are great&quot;,</span><br><span class="line">            &quot;But what I like more&quot;,</span><br><span class="line">            &quot;is the spirit&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CharBuffer buffer = CharBuffer.allocate(100);</span><br><span class="line">        while( fillBuffer(buffer)) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            drainBuffer(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void drainBuffer (CharBuffer buffer) &#123;</span><br><span class="line">        while (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean fillBuffer(CharBuffer buffer) &#123;</span><br><span class="line">        if(index &gt;= strings.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        String string = strings[index++];</span><br><span class="line">        for(int i=0;i&lt;string.length();i++) &#123;</span><br><span class="line">            buffer.put(string.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些情况，你只想把Buffer的一部分输出，然后下次再接着操作，下次操作的时候下标也要从0开始。这么做的话，就必须将未读的数据左移至开头，这样做毫无疑问是低效率的，如果一定要这么做的话，Buffer提供了compact方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.compact();</span><br></pre></td></tr></table></figure>
<p>假设你输出了两个字符那么现在概念图就会变成这样:<br><img src="/Images/java-nio-buffer5.png" alt="48BBB9F226F5DD44A7CE940747B47BDE.jpg"></p>
<p>然后你调用了compact方法<br><img src="/Images/java-nio-buffer6.png" alt="4A7013E3CD5086017F254507F2F79C47.jpg"></p>
<p>4，5都会保持不变，还是同样的道理，Buffer不会做那些看上去合理但并没有用的操作。</p>
<p>Mark方法，允许buffer记下一个位置，如果reset被调用，那么position会转移到mark的位置。如果在mark还未指定的情况下调用reset，会抛出InvalidMarkException。如果你调用一些buffer方法，mark标记会被丢弃，比如rewind，clear和flip。如果调用带参数的limit或者position方法，如果该参数值在mark标记之前，那么mark也会废弃。</p>
<p>设计buffer的目标是为了有效的数据交换，在循环中依次移动数据非常地没有效率。如下列出了CharBuffer中大量移动数据的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CharBuffer extends Buffer implements CharSequence,Comparable &#123;</span><br><span class="line">  //这只是方法的一部分</span><br><span class="line">  public CharBuffer get (char[] dst)</span><br><span class="line">  public CharBuffer get(char[] dst, int offset, int length)</span><br><span class="line"></span><br><span class="line">  public final CharBuffer put (char[] src)</span><br><span class="line">  public CharBuffer put(char[] src, int offset, int length)</span><br><span class="line">  public CharBuffer put(char[] src)</span><br><span class="line">  </span><br><span class="line">  public final CharBuffer put(String src)</span><br><span class="line">  public CharBuffer put(String src, int start, int end)</span><br></pre></td></tr></table></figure>
<p>两种方式从数组中复制数据。第一个方法，只携带一个数组作为参数。第二个携带偏移量和长度两个参数指定子数组。虽然最终这个和循环移动的结果相同，但是这种方式往往更加有效，因为通常这些方法都会优化移动数据或者调用native代码。</p>
<p>如果你要求的数据们无法被转移，那么会抛出BufferUnderflowException.或者你要求的参数，buffer无法全部填充，也会抛出异常。在尝试获取数据之前，你应该先判断一下容量是否充足：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char[] bigArray = new char[1000];</span><br><span class="line">//获取buffer剩余输出</span><br><span class="line">int length = buffer.remaining();</span><br><span class="line">//如果length不够填充整个数组</span><br><span class="line">buffer.get(bigArray,0,length);</span><br><span class="line">processData(bigArray,length);</span><br></pre></td></tr></table></figure>
<p>但是如果buffer持有的数据大于了你的数组，你可以这么做:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char[] smallArray = new char[10];</span><br><span class="line"></span><br><span class="line">while (buffer.hasRemaining()) &#123;</span><br><span class="line">    int length = Math.min(buffer.remaining(), smallArray.length);</span><br><span class="line">    buffer.get(smallArray, 0, length);</span><br><span class="line">    processData(smallArray, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buffer的put方法，如果buffer有空间存放这些数据，数据就会从现在buffer的position中开始写入，并且更新buffer的position值。如果空间不足，不会有任何数据写入，并抛出BufferOverflowException。</p>
<p>当然buffer的put方法也可以直接传入一个buffer作为参数，这和下面的操作等价:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstBuffer.put(srcBuffer) 等价于 dstBuffer.put(srcBuffer.get());</span><br></pre></td></tr></table></figure>

<p>如果是以String为参数的put方法，和charArray类似。尽管String并不是char的集合，但我们倾向于把String概念化为char的集合。</p>
<p>在<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4e955074b3f0">JAVA NIO BUFFER（一）</a>看到了七个基本的buffer类，我们以CharBuffer为例。来看看如何创建一个CharBuffer对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CharBuffer extends Buffer implements CharSequence, Comparable &#123;</span><br><span class="line">  public static CharBuffer allocate (int capacity)</span><br><span class="line">  </span><br><span class="line">  public static CharBuffer wrap(char[] array)</span><br><span class="line">  public static CharBuffer wrap(char[] array, int offset, int length)</span><br><span class="line"></span><br><span class="line">  public final boolean hasArray()</span><br><span class="line">  public final char[] array()</span><br><span class="line">  public final int arrayOffset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过包装或者分配都可以构造一个新的Buffer对象，分配方式创建了一个Buffer对象并且给它分配了私人空间。包装方式创建了一个Buffer对象但是没有给它分配私人空间(就使用你传递给它的数组参数)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//分配一个CharBuffer可以容纳100个字符</span><br><span class="line">CharBuffer charBuffer = CharBuffer.allocate(100);</span><br><span class="line">//如果你想要使用你自己的数组</span><br><span class="line">char[] myArray = new char[100];</span><br><span class="line">CharBuffer charBuffer = CharBuffer.wrap(myArray);</span><br></pre></td></tr></table></figure>

<p>那么你觉得如下的代码会怎么样呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer charBuffer = CharBuffer.wrap(myArray,12,42);</span><br></pre></td></tr></table></figure>
<p>会分配一个大小为30的数组给你操作？</p>
<p>不是，假如myArray的长度是100，CharBuffer还是掌控着长度为100的数组，只是初始的position为12，limit为42.而后面要提到的slice方法可以生成一个只能够操作给定范围的CharBuffer。</p>
<p>通过allocate或者wrap生成的buffer是不直接的。不直接的buffer包含有着数组。hasArray方法告诉你是否存在数组，如果这个方法返回true，那么array方法就会返回给你这个数组的引用。如果返回false，不要调用array或者arrayOffset方法，否则就会抛出UnsupportedOperationException.</p>
<p>如果Buffer是只读的，就算它是通过wrap数组方法生成的，调用它的array或者arrayOffset方法也会抛出ReadOnlyBufferException 防止你通过数组修改只读数据。</p>
<p>通过数组的形式存储数据，可以实现Buffer的功能，进而创建Buffer对象，但是Buffer可不仅仅只能通过数组才能实现。Buffer还可以管理其它buffer的数组。一旦这么做，就是一个view buffer对象。大多数view buffers是bytebuffers的视图。</p>
<p>View Buffers通常通过调用已经存在buffer的方法生成。创建的view buffer不仅可以通过get，put方法操作原有的buffer，而且如果原来的buffer是直接的，view buffer也可以得到同样的性能优势。以CharBuffer为例，查看它的相关方法声明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CharBuffer extends Buffer implements CharSequence, Comparable &#123;</span><br><span class="line">  public abstract CharBuffer duplicate();</span><br><span class="line">  public abstract CharBuffer asReadOnlyBuffer();</span><br><span class="line">  public abstract CharBuffer slice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>duplicate方法创建了一个跟原来相似的新的buffer。两个buffer共享数据，有相同的容量，但是两个buffer独自管理自己的position，limit和mark。对数据的更改会反应在两个buffer之上。</p>
<p>你也可以通过asReadOnlyBuffer来创建一个只读的CharBuffer，大部分和duplicate相同，新的buffer会禁用put方法，而且它的isReadOnly方法会返回true。如果试图破坏这个CharBuffer的只读属性，会抛出ReadOnlyBufferException，值得一提的是，对数据元素的更改也会反应在只读的CharBuffer上。</p>
<p>slice方法跟duplicate方法也很相似，但是slice方法返回的是一部分，下图说明一个原本大小为8的CharBuffer被slice之后，生成的新CharBuffer的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buffer = CharBuffer.allocate(8);</span><br><span class="line">buffer.position(3).limit(5);</span><br><span class="line">CharBuffer sliceBuffer = buffer.slice();</span><br></pre></td></tr></table></figure>

<p><img src="/Images/java-nio-buffer7.png" alt="3E8A4D8D1FB35C5E069CC57907621DA0.jpg"><br>这些方法都不会对mark属性进行操作。</p>
<p>除了布尔类型，其他基本类型都有自身的Buffer类，但是byteBuffer还有不少其他特性。操作系统和他的IO设备来看，byte是最基本的数据单元。需要把其他类型的数据转化为bytes来操作。为了方便参阅，这里列出来了ByteBuffer的完整API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">Buffer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span> <span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span> <span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDirect</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span> <span class="params">(<span class="type">byte</span>[] array, <span class="type">int</span> offset,<span class="type">int</span> length)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span> <span class="params">(<span class="type">byte</span>[] array)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">duplicate</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">asReadOnlyBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">slice</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasArray</span><span class="params">(  )</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">byte</span> [] array(  )</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">arrayOffset</span><span class="params">(  )</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> ByteBuffer <span class="title function_">get</span> <span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">  <span class="keyword">public</span> ByteBuffer <span class="title function_">get</span> <span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span> <span class="params">(<span class="type">byte</span> b)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span> <span class="params">(<span class="type">int</span> index, <span class="type">byte</span> b)</span>;</span><br><span class="line">  <span class="keyword">public</span> ByteBuffer <span class="title function_">put</span> <span class="params">(ByteBuffer src)</span></span><br><span class="line">  <span class="keyword">public</span> ByteBuffer <span class="title function_">put</span> <span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title function_">put</span> <span class="params">(<span class="type">byte</span>[] src)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title function_">order</span><span class="params">(  )</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title function_">order</span> <span class="params">(ByteOrder bo)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> CharBuffer <span class="title function_">asCharBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ShortBuffer <span class="title function_">asShortBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">asIntBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> LongBuffer <span class="title function_">asLongBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> FloatBuffer <span class="title function_">asFloatBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> DoubleBuffer <span class="title function_">asDoubleBuffer</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">char</span> <span class="title function_">getChar</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">char</span> <span class="title function_">getChar</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putChar</span> <span class="params">(<span class="type">char</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putChar</span> <span class="params">(<span class="type">int</span> index, <span class="type">char</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">short</span> <span class="title function_">getShort</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">short</span> <span class="title function_">getShort</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putShort</span> <span class="params">(<span class="type">short</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putShort</span> <span class="params">(<span class="type">int</span> index, <span class="type">short</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getInt</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putInt</span> <span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putInt</span> <span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">getLong</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putLong</span> <span class="params">(<span class="type">long</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putLong</span> <span class="params">(<span class="type">int</span> index, <span class="type">long</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">getFloat</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">getFloat</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putFloat</span> <span class="params">(<span class="type">float</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putFloat</span> <span class="params">(<span class="type">int</span> index, <span class="type">float</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getDouble</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getDouble</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putDouble</span> <span class="params">(<span class="type">double</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putDouble</span> <span class="params">(<span class="type">int</span> index, <span class="type">double</span> value)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">compact</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span> <span class="params">(Object ob)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span> <span class="params">(Object ob)</span>;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(  )</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(  )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了boolean类型之外，byte占1个byte，char两个，short两个，int四个，long八个，float四个，double八个。虽然这些字节一定是按照顺序的，但是也有大端和小端之分。(指的是连续的内存单元，先放高字节，还是先存放低字节)在java.nio中，字节顺序由ByteOrder这个类来封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class ByteOrder &#123;</span><br><span class="line">  public static final ByteOrder BIG_ENDIAN</span><br><span class="line">  public static final ByteOrder LITTLE_ENDIAN</span><br><span class="line"></span><br><span class="line">  public static ByteOrder nativeOrder()</span><br><span class="line">  public String toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类定义了两个自己实例的公共域，在JVM中，只有这两个实例，所以要比较的话，可以使用&#x3D;&#x3D;。如果你需要知道JVM上的字节顺序，调用nativeOrder方法。</p>
<p>每一个buffer类都可以通过order方法知悉自己现在的字节顺序设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final ByteOrder order()</span><br></pre></td></tr></table></figure>
<p>返回ByteOrder的两个实现之一，但和ByteBuffer不同，这个返回的对象只是可读的。ByteBuffer的默认字节顺序是大根端(无论运行在什么字节顺序的平台上),Java的默认字节顺序也是大根端，允许类文件，序列化的对象运行在任何JVM上。如果本地的硬件设备是小根端的话，这可能会有着性能的影响。把ByteBuffer作为其他数据类型接受的时候，使用本地的字节顺序会更有效。</p>
<p>ByteBuffer的字节顺序可以通过order方法改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final ByteOrder order()</span><br><span class="line">public final ByteOrder order(ByteOrder bo)</span><br></pre></td></tr></table></figure>
<p>如果buffer被创建为ByteBuffer的一个视图，那么order返回的就是当这个buffer创建时，原来的buffer的字节顺序，即使原来的buffer改变字节顺序，buffer的字节顺序也不会改变。</p>
<p>ByteBuffer和其他Buffer不同的是，它们可以作为Channel(通道)操作的起点或者终点。通道只接受ByteBuffer作为参数。</p>
<p>操作系统在内存区中进行IO操作，这些内存区域就是连续的byte。操作系统会直接进入进程的地址空间来转移数据。也就是说内存区的数据最好是连续的字节数。但是在JVM中，字节数组并不一定存储在连续的内存区域，GC可能会移动它们。如何存储数组，根据JVM的实现还有很大的区别。</p>
<p>因为这个原因，引入了direct buffer这一概念，direct buffer来处理通道和本地IO操作。尽最大努力把byte数据存储在一个channel可以直接使用的或者可以直接由本地方法通知操作系统，操作系统直接操作的内存区域。</p>
<p>这往往是IO最高效的选择，支持JVM能支持的最高效IO机制。非直接的Buffer也可以传递给channel，但是会导致性能的损失。通常情况下，非直接的buffer是不可能作为本地IO操作的目标的。如果你将一个非直接buffer传递给channel操作，channel可能会做如下的操作<br>  1.创建一个临时的direct ByteBuffer对象<br>  2.把非直接的ByteBuffer中的内容拷贝到1创建的对象中<br>  3.利用临时对象进行低等级的IO操作<br>  4.临时对象使用完毕，等待GC回收</p>
<p>创建DirectBuffer的代价可能会更高，DirectBuffer使用的内存是越过JVM，直接由本地代码分配的。而且DirectBuffer使用的内存无法被垃圾回收，因为它们在JVM堆之外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteBuffer extends Buffer implements Comparable &#123;</span><br><span class="line">  public static ByteBuffer allocate(int capacity)</span><br><span class="line">  public static ByteBuffer allocateDirect(int capacity)</span><br><span class="line">  public abstract boolean isDirect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用allocateDirect方法来创建一个DirectBuffer。那些根据wrap方法创建的buffer，总是非直接的(non-direct)。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channels是java.nio的第二个主要创新，提供了跟IO服务的直接连接。Channel是bytebuffer，文件，或者socket之间传输数据的导管。Channel提供了平台无关的抽象，但仍然可以比拟现代操作系统上native代码的IO能力。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Channel &#123;</span><br><span class="line">  public boolean isOpen();</span><br><span class="line">  public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟buffer不同，channel的实现在不同的操作系统上差距很大，所以channel只定义为一个接口，描述它可以做什么。通常情况下用native方法实现。只有两个方法，一个用来判断通道是否处于打开状态，一个用于关闭通道。</p>
<p>InterruptibleChannel是一个标记接口，代表这个通道是可中断的，可中断的通道在运行它们的线程中断时有特殊的特性。</p>
<p>IO分为两个大类，文件IO和流IO。通道也分为，文件通道和socket通道。Socket通道有工厂方法可以直接创建。但是一个文件通道不能够直接创建，只能够通过调用RandomAccessFile,FileInputStream,FileOutputStream的getChannel方法。你不能够直接创建一个FileChannel对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;some host&quot;</span>,someport));</span><br><span class="line"></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocketChannel</span>().open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(somelocalport));</span><br><span class="line"></span><br><span class="line"><span class="type">DatagramChannel</span> <span class="variable">dc</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;somefile&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> raf.getChannel();</span><br></pre></td></tr></table></figure>

<p>先看如下的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadableByteChannel extends Channel &#123;</span><br><span class="line">  public int read (ByteBuffer dst) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">public interface WritableByteChannel extends Channel &#123;</span><br><span class="line">  public int write(ByteBuffer src) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">public interface ByteChannel extends ReadableByteChannel, WritableByteChannel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道可以是双向的也可以是单向的。根据需要实现这三个接口中的一个。</p>
<p>通道的read(),write()方法都以ByteBuffer作为参数，每个都返回操作了的字节数，并更新ByteBuffer中的position属性。<br>下面的例子展示了使用channel进行putget的基本操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">16</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReadableByteChannel</span> <span class="variable">source</span> <span class="operator">=</span> Channels.newChannel(System.in);</span><br><span class="line">    <span class="type">WritableByteChannel</span> <span class="variable">dest</span> <span class="operator">=</span> Channels.newChannel(System.out);</span><br><span class="line">    <span class="comment">//call one of copy method</span></span><br><span class="line">    source.close();</span><br><span class="line">    dest.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">channelCopy1</span> <span class="params">(ReadableByteChannel src, WritableByteChannel dest)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (src.read(buffer)!=-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//准备好数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向通道中写入数据，可能阻塞</span></span><br><span class="line">        dest.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用compact方法，可以确保数据都被dest处理</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还有可能有数据剩余，此时只是没有可读数据了而已</span></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        dest.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">channelCopy2</span> <span class="params">(ReadableByteChannel src, WritableByteChannel dest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (src.read(buffer)!=-<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            dest.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道可以工作在阻塞或者非阻塞模式下。如果工作在非阻塞模式下，调用它的线程永远不会sleep。请求操作要么立刻完成，要么返回结果表明没有进行任何操作。只有面向流的通道，像socket或者pipe才可以工作在非阻塞模式。</p>
<p>跟buffer不同，channel不可以被复用。一个打开的通道代表着跟特定IO服务之间的连接，还封装着连接的状态。当通道关闭的时候，连接丢失。调用通道的close方法会导致当关闭IO服务的时候，线程短暂地阻塞，就算工作在非阻塞模式也一样。对同一个通道调用多次close方法是无害的。如果第一个线程在close方法中阻塞，其他调用close方法的线程也会阻塞等待。后面的close方法什么都不做，然后立刻返回。</p>
<p>通道有一些和关闭中断相关的特性。如果一个通道实现了InterruptibleChannel接口。那么，如果线程正在被通道所阻塞，然后线程被中断，通道会被关闭，然后线程会收到一个ClosedByInterruptException异常。另外，如果线程被设置为中断状态，然后线程尝试获取一个通道，通道就会立刻关闭，抛出同样的异常。</p>
<p>先看如下的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadableByteChannel extends Channel &#123;</span><br><span class="line">  public int read (ByteBuffer dst) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">public interface WritableByteChannel extends Channel &#123;</span><br><span class="line">  public int write(ByteBuffer src) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">public interface ByteChannel extends ReadableByteChannel, WritableByteChannel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道可以是双向的也可以是单向的。根据需要实现这三个接口中的一个。</p>
<p>通道的read(),write()方法都以ByteBuffer作为参数，每个都返回操作了的字节数，并更新ByteBuffer中的position属性。<br>下面的例子展示了使用channel进行putget的基本操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static final int BUFFER_SIZE = 16*1024;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ReadableByteChannel source = Channels.newChannel(System.in);</span><br><span class="line">    WritableByteChannel dest = Channels.newChannel(System.out);</span><br><span class="line">    //call one of copy method</span><br><span class="line">    source.close();</span><br><span class="line">    dest.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void channelCopy1 (ReadableByteChannel src, WritableByteChannel dest) throws IOException&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    while (src.read(buffer)!=-1) &#123;</span><br><span class="line">        //准备好数据</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        //向通道中写入数据，可能阻塞</span><br><span class="line">        dest.write(buffer);</span><br><span class="line"></span><br><span class="line">        //调用compact方法，可以确保数据都被dest处理</span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    //还有可能有数据剩余，此时只是没有可读数据了而已</span><br><span class="line">    while (buffer.hasRemaining()) &#123;</span><br><span class="line">        dest.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void channelCopy2 (ReadableByteChannel src, WritableByteChannel dest) throws IOException &#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    while (src.read(buffer)!=-1) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        while (buffer.hasRemaining()) &#123;</span><br><span class="line">            dest.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道可以工作在阻塞或者非阻塞模式下。如果工作在非阻塞模式下，调用它的线程永远不会sleep。请求操作要么立刻完成，要么返回结果表明没有进行任何操作。只有面向流的通道，像socket或者pipe才可以工作在非阻塞模式。</p>
<p>跟buffer不同，channel不可以被复用。一个打开的通道代表着跟特定IO服务之间的连接，还封装着连接的状态。当通道关闭的时候，连接丢失。调用通道的close方法会导致当关闭IO服务的时候，线程短暂地阻塞，就算工作在非阻塞模式也一样。对同一个通道调用多次close方法是无害的。如果第一个线程在close方法中阻塞，其他调用close方法的线程也会阻塞等待。后面的close方法什么都不做，然后立刻返回。</p>
<p>通道有一些和关闭中断相关的特性。如果一个通道实现了InterruptibleChannel接口。那么，如果线程正在被通道所阻塞，然后线程被中断，通道会被关闭，然后线程会收到一个ClosedByInterruptException异常。另外，如果线程被设置为中断状态，然后线程尝试获取一个通道，通道就会立刻关闭，抛出同样的异常。</p>
<p>通道提供了分散聚合的能力。就是说一次IO操作可以对应多个buffer。</p>
<p>对于写操作(向通道中写入数据),数据从数个buffer中汇合然后沿通道发送<br>对于读操作(从通道中读出数据),从通道中出来的数据分散到许多不同的buffer，尽可能地读取，直到数据或者buffer的可用空间被耗尽。</p>
<p>许多现代操作系统支持native vectored（矢量） IO；当你在一个通道上发起一个分散聚合请求时，请求会被解释成native方法。这样子buffer的复制和系统调用可以减少甚至消除。最好使用direct buffer，得到最优的性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface ScatteringByteChannel extends ReadableByteChannel &#123;</span><br><span class="line">  public long read(ByteBuffer[] dsts) throws IOException;</span><br><span class="line">  public long read(ByteBuffer[] dots,int offset, int length) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface GatheringByteChannel extends WritableByteChannel &#123;</span><br><span class="line">  public long write(ByteBuffer[] srcs) throws IOException;</span><br><span class="line">  public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看下面的代码段<br><img src="/Images/java-nio-channel1.png" alt="分散聚合类图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocateDirect(10);</span><br><span class="line">ByteBuffer body = ByteBuffer.allocateDirect(80);</span><br><span class="line">ByteBuffer[] buffers = &#123;header, body&#125;;</span><br><span class="line">int bytesRead = channel.read(buffers);</span><br></pre></td></tr></table></figure>
<p>如果返回值bytesRead为48，那么head中拥有最先的10个数据，body中有38个。</p>
<p>相似的，我们可以组装数据在不同的buffer中，然后发送聚合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body.clear();</span><br><span class="line">body.put(&quot;FOO&quot;.getBytes()).flip();</span><br><span class="line">header.clear();</span><br><span class="line">header.putShort(TYPE_FILE).putLong(body.limit()).flip();</span><br><span class="line">long bytesWritten = channel.write(buffers);</span><br></pre></td></tr></table></figure>

<p>FileChannel继承了ScatteringByteChannel,ByteChannel和GatheringByteChannel。在类中还引入了文件锁。下面是部分的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FileLock implements AutoClosable&#123;</span><br><span class="line">  public FileChannel channel()</span><br><span class="line">  public long position()</span><br><span class="line">  public long size()</span><br><span class="line">  public boolean isShared()</span><br><span class="line">  public boolean overlaps(long position, long size)</span><br><span class="line">  public boolean isValid()</span><br><span class="line">  public void release()</span><br><span class="line">  public String toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Images/java-nio-channel2.png" alt="89EFD771-3B57-4FFF-A6D9-B48DC66E6F85.png"><br>文件通道总是运行在阻塞模式而且不能在非阻塞模式下工作。面向流的非阻塞模式对文件操作来说意义不大。对于文件来说，真正需要的是异步IO，从操作系统发出一条或多条IO请求而不需要等待它们完成，而是在完成之后收到通知。</p>
<p>FileChannel对象可以通过调用RandomAccessFile,FileInputStream,FileOutputStream的getChannel方法得到，调用这个方法得到一个FileChannel对象，拥有和File对象一样的访问权限。</p>
<p>FileChannel是一个抽象类，你通过getChannel方法得到的是一个具体实现，往往实现中有着大量native代码。FileChannel是线程安全的。多线程可以同时调用他们的方法而不会引起任何问题，但不是所有操作都是多线程的，影响到通道的位置和文件大小是单线程的。如果有线程试图做这样的操作，那么它必须等待另一个线程执行完毕。</p>
<p>FileChannel保证同一个JVM中的所有实例看到的文件视图都是一致的。但这个视图和非JVM线程看到的可能相同也可能不同，这高度取决于底层的操作系统和文件系统。一般情况下来说，都是相同的。</p>
<p>FileChannel中的position，代表着数据下一个写入或者读取的地方，无参数的position方法，返回一个long类型的当前位置。第二个需要一个long类型的参数，如果你把参数设置为负，会抛出IllegalArgumentException,但是如果设置的超出了文件的大小不会抛出异常，但不会更改文件的大小。如果读操作超出了文件的大小，会返回EOF，如果是写操作，就会更改文件的大小。每个FileChannel对象都和一个File descriptor有着一对一的联系。而File descriptor是channel创建的时候被共享的。也就是说他们可以看到彼此对position的更改，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;filename&quot;,&quot;r&quot;);</span><br><span class="line">//设置position</span><br><span class="line">randomAccessFile.seek(1000);</span><br><span class="line">//创建一个channel</span><br><span class="line">FielChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line">System.out.println(fileChannel.position());//打印1000</span><br><span class="line">randomAccessFile.seek(500);</span><br><span class="line">System.out.println(fileChannel.position());//500</span><br><span class="line">fileChannel.position(200);</span><br><span class="line">System.out.println(randomAccessFile.getFilePointer());//200</span><br></pre></td></tr></table></figure>
<p>和buffer相似，FileChannel的read方法和write方法都可以携带一个position参数，这样子比起不带参数的read，write方法更为高效，因为不需要更新channel的状态，可以直接通过native code实现。最好的是，多线程可以同时访问一个文件而不需要相互打扰。</p>
<p>如果视图读取文件的结尾，会收到EOF，如果在这时，往超出文件大小的地方写入，文件就会自动增长，但在这EOF和此时写入的位置之间无数据的地方就要看具体的操作系统和文件系统了，可能会导致一个file hole。当你觉得有必要调整文件的大小时，调用truncate方法，携带一个long类型作为参数，如果大于你此时文件的大小，无事发生过。但是如果小于，大于这个数值的数据会被丢弃。</p>
<p>最后force方法，要求强制把现在已经做了的更改应用到磁盘文件上，参数表明是否更新元数据(如文件所有者，访问权限，最后一次修改时间等)</p>
<h2 id="文件锁FileLock"><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h2><p>文件锁可以是shared(共享锁)或者exclusive(排他锁)。不是所有的平台都以同一种方式实现文件锁，不同的操作系统可能不同，同一操作系统上的不同文件系统也可能不同。有些操作系统只提供协同锁，有些只提供强制锁，有些则都提供。</p>
<p>文件锁是以文件为单位的，不是以通道，也不是线程。所以文件锁不适合同一个多个线程访问的情形。如果一个线程获得了给定文件的排他锁，第二个线程请求打开了一个新的channel，请求获得排他锁，请求会被批准。但如果这两个线程运行在不同的JVM中，第二个线程会阻塞，因为锁往往是根据进程来进行裁决，而不是线程。锁工作于一个文件，而不是单独的文件处理器或是通道。<br>&#x2F;*<br>如果你需要控制多个线程之间的同步，你可能需要实现自己的轻量级的锁，内存映射文件可能是个适合的选择<br>*&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel &#123;</span><br><span class="line">  </span><br><span class="line">  public final FileLock lock()</span><br><span class="line">  public abstract FileLock lock (long position, long size, boolean shared)</span><br><span class="line"></span><br><span class="line">  public final FileLock tryLock()</span><br><span class="line">  public abstract FileLock tryLock(long position, long size, boolean shared)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看带参数的lock方法，获得给定区域的锁，自position开始，size大小，第三个布尔参数代表是锁是否共享。锁的区域并不受到文件大小的限制，锁可以超过文件的大小，也就是说在一段区域被写入数据之前锁住，是可行的。相反的，如果文件的大小超出了锁的限制，也就将不受到锁的限制。不带参数的lock方法，等效于<br><code>fileChannel.lock(0L,Long.MAX_VALUE, false);</code><br>如果你的请求是有效的，那么lock方法就会生效，但是要等待前一个锁(如果存在的话)释放。</p>
<p>tryLock方法是lock方法非阻塞的变种，功能和lock相似，但是如果不能立刻获得锁的话，tryLock会返回null。从创建开始，直到调用FileLock的release方法，FileLock对象都是有效的。可以通过isValid方法测试。一个锁是否有效可能会改变，但锁的位置，大小，是否共享，是不变的。</p>
<p>你可以通过isShared判断锁是否为共享锁，如果内在的文件系统操作系统不支持共享，那么这个方法总是会返回false，就算你传递true作为构造函数也一样。FileLock是线程安全的，多个线程可以通过一个FileLock进行操作。尽管FileLock对象和一个Channel相关，但是其实锁是和内在的文件联系的。这有可能造成冲突，也有可能死锁，如果你完成了操作而没有释放锁的话。一个典型的代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileLock lock = fileChannel.lock();</span><br><span class="line">try&#123;</span><br><span class="line">  &lt;perform read/write/whatever on channel&gt;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  &lt;handle unexcepted exception&gt;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个使用FileLock进行操作的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    private static final int SIZEOF_INT = 4;</span><br><span class="line">    private static final int INDEX_START = 0;</span><br><span class="line">    private static final int INDEX_COUNT = 10;</span><br><span class="line">    private static final int INDEX_SIZE = INDEX_COUNT * SIZEOF_INT;</span><br><span class="line"></span><br><span class="line">    private ByteBuffer buffer = ByteBuffer.allocate(INDEX_SIZE);</span><br><span class="line">    private IntBuffer indexBuffer = buffer.asIntBuffer();</span><br><span class="line">    private Random rand = new Random();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        boolean writer = false;</span><br><span class="line">        String filename;</span><br><span class="line">        //决定你所做的操作，读或者写</span><br><span class="line">        if(args.length!=2) &#123;</span><br><span class="line">            System.out.println(&quot;Usage: [-r|-w] filename&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        writer = args[0].equals(&quot;-w&quot;);//true写false读</span><br><span class="line">        filename = args[1];</span><br><span class="line">        RandomAccessFile raf = new RandomAccessFile(filename,writer?&quot;rw&quot;:&quot;r&quot;);</span><br><span class="line">        FileChannel fc = raf.getChannel();//通过RandomAccessFile拿到fileChannel</span><br><span class="line">        LockTest lockTest = new LockTest();</span><br><span class="line">        if(writer) &#123;</span><br><span class="line">            lockTest.doUpdates(fc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lockTest.doQueries(fc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doQueries (FileChannel fc) throws Exception &#123;</span><br><span class="line">        //如果是单次操作的话，没有这个循环，这里使用这个循环，为了多次</span><br><span class="line">        //运行程序，发现锁的工作原理</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            FileLock lock = fc.lock(INDEX_START,INDEX_SIZE,true);</span><br><span class="line">            int reps = rand.nextInt(60) + 20;</span><br><span class="line">            for(int i=0; i&lt;reps; i++) &#123;</span><br><span class="line">                int n = rand.nextInt(INDEX_COUNT);</span><br><span class="line">                int position = INDEX_START + (n*SIZEOF_INT);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                fc.read(buffer,position);</span><br><span class="line">                int value = indexBuffer.get(n);</span><br><span class="line">                Thread.sleep(100);//doing some work</span><br><span class="line">            &#125;</span><br><span class="line">            lock.release();</span><br><span class="line">            Thread.sleep(rand.nextInt(3000)+500);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doUpdates (FileChannel fc) throws Exception &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            FileLock lock = fc.lock(INDEX_START,INDEX_SIZE,false);</span><br><span class="line">            updateIndex(fc);</span><br><span class="line">            lock.release();</span><br><span class="line">            Thread.sleep(rand.nextInt(2000)+500);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int idxval = 1;</span><br><span class="line"></span><br><span class="line">    private void updateIndex (FileChannel fc) throws Exception&#123;</span><br><span class="line">        indexBuffer.clear();</span><br><span class="line">        for(int i=0; i&lt;INDEX_COUNT; i++) &#123;</span><br><span class="line">            idxval++;</span><br><span class="line">            indexBuffer.put(idxval);</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        fc.write(buffer,INDEX_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2017/08/16/Java%20IO%20%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/08/16/Java%20IO%20%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Java IO 相关类解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-16 21:57:58" itemprop="dateCreated datePublished" datetime="2017-08-16T21:57:58+08:00">2017-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>Java.io.OutputStream类声明了三个基本方法用来把byte数据写入到流中。当然也有用于关闭和刷新的流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>OutputStreams是一个抽象类，子类提供方法的实现。大多数情况下，你只需要知道你处理的对象是一个OutputStream就足够了。<br>OutputStream中最基本的方法是write()</p>
<p>  public abstract void write(int b) throws IOException<br>这个方法书写了一个无符号byte（0-255），如果你传入了大于255或者小于0的数值，会对256取模直到得到一个合适的值。<br>通常来说，对大量的数据，用byte来传递会更快一些。这正是两个write方法的用途<br>第一个写入整个byte数组。第二个只写入数组的一部分，从offset开始写入length长度的数据。<br>相反地，如果你尝试一次性写入太多的数据，性能上就会出现问题。文件最好一次一次地写入小的块，典型地数值像512，1024，2048.网络连接通常只需要更小的块，128或者256.<br>输出流缓冲区用来提高性能。比起把每一个字节送到它想去的终点，字节们先在内存缓冲区中集合。当缓冲区被填满，数据被传送出去。flush方法强迫缓冲区没有满的时候输出。<br>如果你只使用流很短的时间，你不需要明确地调用flush方法。它应该在流关闭的时候被flush。一旦你关闭了流，你就不能再向其中写入数据，如果你尝试这么做，就会引起IOException.</p>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>Java.io.InputStream类声明了三个基本方法用来把byte数据写入到流中。当然也有用于关闭和刷新的流,查看还有多少数据可以读，略过一些输入，在流中标记一个位置然后重置到那个位置，还有决定标记和重设是否是支持的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract int read() throws IOException</span><br><span class="line">public int read(byte[] data) throws IOException</span><br><span class="line">public int read(byte[] data, int offset, int length) throws IOException</span><br><span class="line">public long skip(long n) throws IOException</span><br><span class="line">public int available() throws IOException</span><br><span class="line">public void close() throws IOException</span><br><span class="line">public synchronized void mark(int readLimit)</span><br><span class="line">public synchronized void reset() throws IOException</span><br><span class="line">public boolean markSupported()</span><br></pre></td></tr></table></figure>
<p>  InputStream中最基本的方法是read,这个方法读入一个无符号的byte类型，然后返回它的整型值。就像大多数的IO方法一样，read方法也会有异常抛出，如果read中无数据可读，你不会受到异常，而是返回-1。用这个作为流结尾的标志。如下的代码展示了如何catch IOException和查看是否为结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    int[] data = new int[10];</span><br><span class="line">    for(int i=0;i&lt;data.length;i++) &#123;</span><br><span class="line">        int datum = System.in.read();</span><br><span class="line">        if (datum == -1) break;</span><br><span class="line">        data[i] = datum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e ) &#123;</span><br><span class="line">    System.err.println(&quot;Couldn&#x27;t read from System.in!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  read方法等待或者阻塞直到byte数据可用而且准备就绪。Input和Output可能会很慢，所以如果你的程序在执行其他重要的事情。你应该把IO操作放在它们自己的线程当中。下面这个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class StreamPrinter &#123;</span><br><span class="line">  InputStream theInput;</span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    StreamPrinter sr = new StreamPrinter(System.in);</span><br><span class="line">    sr.print();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamPrinter(InputStream in) &#123;</span><br><span class="line">    theInput = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void print() &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      while(true) &#123;</span><br><span class="line">        int datum = theInput.read();</span><br><span class="line">        if (datum == -1) break;</span><br><span class="line">        System.out.println(datum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      System.err.println(&quot;couldn&#x27;t read from system in&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第一个read方法读入一批连续数据到byte数组中，第二个尝试读入一定长度的data从offset开始到byte数组。它们两个都不保证读入任意数量的byte。<br>  如果你打算从System.in读入10byte的数据，如下的代码可以完成操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = new byte[10];</span><br><span class="line">System.in.read(b);</span><br></pre></td></tr></table></figure>
<p>  但是，并不是每次read都可以拿到你想要的那么多数据。但是这行代码也不能阻止你试图往read中写入超过容量的数据，如果你这么做了，就会导致ArrayIndexOutOfBoundsException.<br>  如下的代码利用循环，确保尽可能多得获得数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = new byte[100];</span><br><span class="line">int offset = 0;</span><br><span class="line">while(offset &lt;b.length) &#123;</span><br><span class="line">  int bytesRead = System.in.read(b, offset,b.length-offset);</span><br><span class="line">  if(bytesRead==-1) break;</span><br><span class="line">  offset+=bytesRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  尽管上述的代码可以尽可能多得获取数据，但是并不能规避异常的发生。所以，如果在你尝试读它们之前，你可以知道有多少数据将要被读，这将会非常方便。InputStream中的available方法可以告诉你答案<br>  你可以手动操作代码来忽略掉一部分的数据，但JAVA还是提供了skip方法用来跳过给定byte数的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public long skip(long bytesToSkip) throws IOException</span><br></pre></td></tr></table></figure>
<p>  返回值是实际略去的byte数。如果返回-1，则证明剩下的部分都被忽略了。通常来说skip方法比自己手动忽略要快。<br>  并不是所有的流都需要被关闭，比如System.in。但是跟文件或者网络相关的连接还是需要被关闭的。</p>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>java.io.FileInputStream是InputStream的具体实现，提供具体文件的输入流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStream extends InputStream</span><br></pre></td></tr></table></figure>
<p>  FileInputStream 实现了InputStream的常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int read() throws IOException</span><br><span class="line">public int read(byte[] data) throws IOException</span><br><span class="line">public int read(byte[] data, int offset, int length) throws IOException</span><br><span class="line">public native long skip(long n) throws IOException</span><br><span class="line">public native int available() throws IOException</span><br><span class="line">public native void close() throws IOException</span><br></pre></td></tr></table></figure>
<p>  这些方法都是Java Native Code，除了read方法，但这些方法还是把参数传给了native方法。所以实际上，这些方法都是Native方法。<br>  FileInputStream有三种构造方法，区别在于文件是如何指定的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public FileInputStream(String fileName) throws IOException</span><br><span class="line">public FileInputStream(File file) throws FileNotFoundException</span><br><span class="line">public FileInputStream(FileDescriptor fdObj)</span><br></pre></td></tr></table></figure>
<p>  第一个构造函数使用文件的名称，文件的名称跟平台相关，所以硬编码文件名不是一个好的方案，相比之下，后两个就要好很多。<br>  读取文件，我们只需要把文件名称传递给构造函数。然后像平常那样调用read方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = new FileInputStream(&quot;README.TXT&quot;);</span><br><span class="line">int n;</span><br><span class="line">while ((n=fis.available())&gt;0) &#123;</span><br><span class="line">  byte[] b = new byte[n];</span><br><span class="line">  int result = fis.read(b);</span><br><span class="line">  if( result == -1) break;</span><br><span class="line">  String s = new String(b);</span><br><span class="line">  System.out.print(s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>  Java在当前的工作路径寻找文件，通常来说，就是你键入java programName时的路径。在FileInputStream的构造函数中传入相对路径和绝对路径都是可行的。<br>  如果你试图打开一个并不存在的文件，就会抛出FileNotFoundException。如果因为其他原因无法写入（比如权限不足）其他类型的异常会被抛出。下面是一个通过控制台获取文件名，然后把文件打印到控制台的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FileTyper &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if(args.length==0) &#123;</span><br><span class="line">      System.err.println(&quot;no file is determined&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">      try&#123;</span><br><span class="line">        typeFile(args[i]);</span><br><span class="line">        if(i+1&lt;args.length) &#123;</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.println(&quot;--------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125; catch (IOException e) &#123;System.err.println(e);&#125; </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void typeFile(String filename) throws IOException &#123;</span><br><span class="line">    FileInputStream fin = new FileInputStream(filename);</span><br><span class="line">    StreamCopier.copy(fin,System.out);</span><br><span class="line">    fin.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果需要的话，你也可以对同一个文件同时打开多个流。每一个流维护一个单独的指针，指向文件中的当前位置。读取文件并不会更改文件，如果是写文件的话，那就是另一回事了。</p>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>  java.io.FileOutputStream是java.io.OutputStream的具体实现,提供连接到文件的输出流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FileOutputStream extends OutputStream</span><br></pre></td></tr></table></figure>
<p>  类中实现了OutputStream的所有常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native void write(int b) throws IOException</span><br><span class="line">public void write(byte[] data) throws IOException</span><br><span class="line">public void write(byte[] data, int offset, int length) throws IOException</span><br><span class="line">public native void close() throws IOException</span><br></pre></td></tr></table></figure>
<p>  跟之前的FileInputStream相同，FileOutputStream的四个方法也都是实际上的native方法。如下的三种构造器，区别在于文件是如何指定的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public FileOutputStream(String filename) throws IOException</span><br><span class="line">public FileOutputStream(File file) throws IOException</span><br><span class="line">public FileOutputStream(FileDescriptor fd)</span><br></pre></td></tr></table></figure>
<p>  和FileInputStream不同的是，如果指定的文件不存在，那么FileOutputStream会创建它，如果文件存在，FileOutputStream会覆盖它。这个特性让我们使用的时候有些不太方便，有的时候，往往我们需要往一个文件里面添加一些数据，比如向日志文件里面存储记录。这时候，第四个构造函数就体现了它的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public FileOutputStream(String name, boolean append) throws IOException</span><br></pre></td></tr></table></figure>
<p>  如果append设置为true，那么如果文件存在，FileOutputStream会向文件的末尾追加数据，而不是覆盖。<br>  下面的程序获取两个文件名作为参数，然后把第一个文件复制到第二个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FileCopier &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if(args!=2) &#123;</span><br><span class="line">      System.err.println(&quot;error input&quot;);//输入异常。</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      copy(args[0],args[1]);//调用复制文件的方法</span><br><span class="line">    &#125; catch (IOException e) &#123;System.err.println(e);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void copy (String inFile, String outFile) throws IOException &#123;</span><br><span class="line">    FileInputStream fin = null;</span><br><span class="line">    FileOutputStream fout = null;</span><br><span class="line">    try&#123;</span><br><span class="line">      fin = new FileInputStream(inFile);</span><br><span class="line">      fout = new FileOutputStream(outFile);</span><br><span class="line">      StreamCopier.copy(fin,fout);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (fin != null) fin.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (fout != null) fout.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StreamCopier &#123;</span><br><span class="line">  public static void copy(InputStream in,OutputStream out) throws IOException &#123;</span><br><span class="line">    //Do not allow other threads read from the input or write the output</span><br><span class="line">    synchronized (in) &#123;</span><br><span class="line">      synchronized (out) &#123;</span><br><span class="line">        byte[] buffer = new byte[256];</span><br><span class="line">        while(true) &#123;</span><br><span class="line">          int bytesRead = in.read(buffer);</span><br><span class="line">          if(bytesRead == -1) break;</span><br><span class="line">          out.write(buffer,0,bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="URLS"><a href="#URLS" class="headerlink" title="URLS"></a>URLS</h2><p>java.net.URL类是标准资源定位符。每一个URL明确地指定了因特网上一个资源的位置。URL有四个构造函数，每一个都声明了MalformedURLException</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public URL(String u) throws MalformedURLException</span><br><span class="line">public URL(String protocol, String host, String file) throws MalformedURLException</span><br><span class="line">public URL(String protocol, String host, int port, String file) throws MalformedURLException</span><br><span class="line">public URL(URL context, String u) throws MalformedURLException</span><br></pre></td></tr></table></figure>
<p>  如果构造器没有给定一个URL，MalformedURLException会被抛出。如果给你一个绝对的URL比如”<a target="_blank" rel="noopener" href="http://www.jianshu.com/u/9e21abacd418%22,%E4%BD%A0%E4%BC%9A%E8%BF%99%E6%A0%B7%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAURL%E5%AF%B9%E8%B1%A1">http://www.jianshu.com/u/9e21abacd418&quot;,你会这样构造一个URL对象</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL u = null;</span><br><span class="line">try &#123;</span><br><span class="line">  u = new URL(&quot;http://www.jianshu.com/u/9e21abacd418&quot;);</span><br><span class="line">&#125; catch (MalformedURLException e)　&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  你也可以把协议，host和路径分开传入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL u = null;</span><br><span class="line">try &#123;</span><br><span class="line">  u = new URL(&quot;http&quot;,&quot;www.jianshu.com&quot;,&quot;/u/9e21abacd418&quot;);</span><br><span class="line">&#125; catch (MalformedURLException e)　&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  一般情况下，你不需要特地指定协议的端口，大多数协议有他们默认的端口，比如HTTP的协议的默认端口是80.如果端口改变了，可以使用下面的构造方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u = new URL(&quot;http&quot;,&quot;www.jianshu.com&quot;,8080,&quot;/u/9e21abacd418&quot;);</span><br></pre></td></tr></table></figure>
<p>  一旦URL对象被构造，有两种方式获得它的内容。openStream()方法返回原始的数据流，getContent()方法返回一个对象代表数据。当你调用getContent()方法的时候，JAVA根据它的MIME类型，寻找一个content handler，然后返回一个可用的数据对象。<br>  openStream()方法和URL代表的服务器和端口建立了一个Socket连接，返回一个可以获取数据的InputStream，允许你从服务器上下载数据。所有的头文件，跟数据无关的东西在流打开的时候都被跳过了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final InputStream openStream() throws IOException</span><br></pre></td></tr></table></figure>
<p>  使用reader或者InputStream来获取数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  URL u = new URL(&quot;http://www.amnesty.org/&quot;);</span><br><span class="line">  InputStream in = u.openStream();</span><br><span class="line">  int b;</span><br><span class="line">  while ((b = in.read()) != -1) &#123;</span><br><span class="line">    System.out.write(b);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">catch (MalformedURLException e) &#123;System.err.println(e);&#125;  </span><br><span class="line">catch (IOException e) &#123;System.err.println(e);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UrlConnection"><a href="#UrlConnection" class="headerlink" title="UrlConnection"></a>UrlConnection</h2><p>URL Connection和URL有着密切的联系，就像名字一样。你通过URL的openConnection()方法得到一个URL Connection的引用。<br>在大多数情况下，URL只是对URL Connection对象的一种封装。然而URL提供了更多的控制。</p>
<p>  URL Connection不仅仅提供了让客户端读取服务器上信息的能力，而且提供了OutputStream使得，客户端的文件可以发送向服务器。</p>
<p>  java.net.URLConnection类是一个处理多种不同类型服务器的抽象类，比如FTP服务器和web服务器。<br>  一.从URL Connection中读取数据<br>  1.构造URL对象<br>  2.通过openConnection()方法创建一个URLConnection对象<br>  3.连接的参数和需要的属性已经设置完毕<br>  4.使用connect()方法建立连接，可能是使用socket的网络连接，也可能是文件读入流的本地连接。响应的头部信息从服务器传入。<br>  5.使用InputStream来读取数据，或者使用相应(MIME 类型)content handler的getContent()方法。<br>  举个如下的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        URL url = new URL(&quot;http://www.huawei.com&quot;);</span><br><span class="line">        URLConnection uc = url.openConnection();</span><br><span class="line">        uc.connect();</span><br><span class="line">        InputStream in = uc.getInputStream();</span><br><span class="line">        //...after operation</span><br><span class="line">        //close the stream</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果连接无法被建立，会抛出一个IOException。</p>
<p>  二.向URL中写入数据<br>    1.构造URL对象<br>    2.通过openConnection()方法创建一个URLConnection对象<br>    3.调用setDoOutput(boolean doOutput)方法并传入true表明这个连接会被用于写入数据<br>    4.如果你仍然想从InputStream中读取数据，调用setDoInput(boolean doInput)方法并传入true表明这个连接会被用于读取数据<br>    5.创建你想要写入的数据<br>    6.调用getOutputStream拿到OutputStream对象。把第5步中的数据写入其中<br>    7.关闭输出流</p>
<p>  下面是一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MailClient &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if (args.length == 0) &#123;</span><br><span class="line">      System.err.println(&quot;Usage: java MailClient username@host.com&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      URL u = new URL(&quot;mailto:&quot; + args[0]);</span><br><span class="line">      URLConnection uc = u.openConnection();</span><br><span class="line">      uc.setDoOutput(true);</span><br><span class="line">      uc.connect();</span><br><span class="line">      OutputStream out = uc.getOutputStream();</span><br><span class="line">      StreamCopier.copy(System.in, out);</span><br><span class="line">      out.close();</span><br><span class="line">     &#125;</span><br><span class="line">    catch (IOException e) &#123;System.err.println(e);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><p>在数据在互联网中从一个主机到另一个主机的传递之时，它被分割成大小不同但是有限的数据包中(datagrams)。如果要发送的数据大于了数据包的最大大小，它就会被分割成数个包发送，这样做的好处是，如果其中有一个包丢失，那么只需要重传一个包，而不必把所有的包重传。如果包抵达的顺序不同，也会在接收点重新组转完毕。</p>
<p>这一操作对程序员来说是透明的，我们工作在高层抽象的socket上。socket提供了两个主机之间可靠地连接。这样子，你就不需要考虑数据包的编码， 数据包的分割，数据包的重传或者是数据包的组装。Scoket提供这四种基本操作:</p>
<p>1.远程连接到一个机器<br>2.发送数据<br>3.接收数据<br>4.关闭连接</p>
<p>java.net.socket是一个network socket提供了这四种基本操作。在这四种操作中，没有一个抽象了协议，这个类就是为了网络客户端和服务器的连接设计的。为了创建一个连接，你调用socket构造函数中的一种。每一个socket对象仅仅连接到一个指定的远程主机。如果要连接到不同的主机，你必须创建一个新的socket对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Socket (String host, int port) throws UnknownHostException, IOException</span><br><span class="line">public Socket(InteAddress address, int port) throws IOException</span><br><span class="line">public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException</span><br><span class="line">public Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException</span><br></pre></td></tr></table></figure>

<p>host可以是像“<a target="_blank" rel="noopener" href="http://www.huawei.com"这样子的,或者127.0.9.1这样.这个参数也可以通过java.net.inetaddress传入./">www.huawei.com&quot;这样子的，或者127.0.9.1这样。这个参数也可以通过java.net.InetAddress传入。</a></p>
<p>port参数指的是远程主机要连接的端口，0～65535.每一个服务都有他们指定的端口。许多知名的服务都运行在知名的端口上。比如HTTP运行在80端口中。</p>
<p>通过socket来发送接收数据是通过InputStream和 OuputStream</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public InputStream getInputStream() throws IOException</span><br><span class="line">public OutputStream getOutputStream() throws IOException</span><br></pre></td></tr></table></figure>
<p>同样的，也有关闭socket连接的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void close() throws IOException</span><br></pre></td></tr></table></figure>

<p>如下的代码连接到一个网络服务器然后下载一个特定的URL地址。然而这里使用的是Socket而不是URL Connection，所以头部信息需要我们自己处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class SocketTyper &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length==0) &#123;</span><br><span class="line">            System.err.println(&quot;Usage: java SocketTyper url1 url2..&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">            if(args.length&lt;1) &#123;</span><br><span class="line">                System.out.println(args[i]+&quot;:&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                URL u = new URL(args[i]);</span><br><span class="line">                if(u.getProtocol().equalsIgnoreCase(&quot;http&quot;))&#123;</span><br><span class="line">                    System.err.println(&quot;ONLY support http&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                String host = u.getHost();</span><br><span class="line">                int port = u.getPort();</span><br><span class="line">                String file = u.getFile();</span><br><span class="line">                if(port&lt;=0||port&gt;65535) &#123;</span><br><span class="line">                    port = 80;</span><br><span class="line">                &#125;</span><br><span class="line">                Socket s = new Socket(host,port);</span><br><span class="line">                String request = &quot;GET&quot;+file+&quot;HTTP/1.0\r\n&quot;+&quot;User-Agent:MechaMozilla\r\nAccept:text*\r\n\r\n&quot;;</span><br><span class="line">                byte[] b = request.getBytes();</span><br><span class="line">                OutputStream out = s.getOutputStream();</span><br><span class="line">                InputStream in = s.getInputStream();</span><br><span class="line">                out.write(b);</span><br><span class="line">                out.flush();</span><br><span class="line">                StreamCopier.copy(in,System.out);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                s.close();</span><br><span class="line">            &#125; catch (MalformedURLException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><p>两种连接终端，客户端初始化连接，还有服务端，响应连接。实现一个服务器，你需要书写一个等待其他主机连接的程序。一个ServerSocket连接到本机的一个特定端口，一旦它顺利地绑定到了一个端口上，如果监听到了来自其他主机(客户端)的请求，就会建立连接。</p>
<p>一个端口同时可以连接多个客户端。传递来的数据会根据客户端的ip和端口来区分，ip和端口的组合是唯一的。有且只能有一个客户端监听同一主机上的同一端口。通常情况下，ServerSocket只用来接收连接，而和客户端的通信放在独立的线程里去处理。而把将要建立的连接放在队列里面逐个处理。</p>
<p>java.net.ServerSocket类代表着一个ServerSocket。有如下的构造函数，可以确定监听的端口，队列的长度以及ip地址（默认为本机）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ServerSocket (int port) throws IOException</span><br><span class="line">public ServerSocket (int port, int backlog) throws IOException</span><br><span class="line">public ServerSocket (int port, int backlog, InetAddress bindAddr) throws IOException</span><br></pre></td></tr></table></figure>

<p>通常情况下你指定你想要监听的端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ServerSocket ss = new ServerSocket(99);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时该端口已经被其他程序占用，就会导致BindException。当你拥有了ServerSocket之后，你需要等待连接，通过调用accept方法，这个方法会阻塞，直到一个连接到来，然后返回一个Socket，你可以使用它来和客户端通信，调用close方法会关闭ServerSocket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Socket accept() throws IOException</span><br><span class="line">public void close() throws IOException</span><br></pre></td></tr></table></figure>

<p>下面的例子展示了一个程序，监听端口，当建立连接之时，它返回客户端和自身的ip和端口，然后关闭连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServer &#123;</span><br><span class="line"></span><br><span class="line">    public final static int DEFAULT_PORT = 2345;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int port = DEFAULT_PORT;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            port = Integer.parseInt(args[0]);</span><br><span class="line">        &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">        if(port&lt;=0||port&gt;=65536) &#123;</span><br><span class="line">            port = DEFAULT_PORT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket ss = new ServerSocket(port);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Socket s = ss.accept();</span><br><span class="line">                    String response = s.getInetAddress()+&quot;&quot;+s.getPort()+&quot;\n&quot;;</span><br><span class="line">                    response += s.getLocalAddress()+&quot;&quot;+s.getLocalPort();</span><br><span class="line">                    OutputStream out = s.getOutputStream();</span><br><span class="line">                    out.write(response.getBytes());</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2016/09/08/Andoird%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/08/Andoird%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/" class="post-title-link" itemprop="url">Android避免费内存泄露【翻译】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-08 15:44:36" itemprop="dateCreated datePublished" datetime="2016-09-08T15:44:36+08:00">2016-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文：<a target="_blank" rel="noopener" href="http://android-developers.blogspot.sg/2009/01/avoiding-memory-leaks.html">http://android-developers.blogspot.sg/2009/01/avoiding-memory-leaks.html</a></p>
<p>Android中堆的内存是有限的，你应当使用尽量小的内存。因为Android能在内存中保存越多的应用，对于用户来说，切换应用就会十分的迅速。相当多的内存泄漏的原因是因为：保持了一个对context的长引用(long-lived)。<br>    在Android中，Context可以用来做许多事情，不过大部分是用来加载和获取资源。这就是为什么所有的视图组件在构造方法里面需要context作为参数的原因。有两种Context，Activity和Application，通常使用第一个。比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextView</span> <span class="variable">label</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TextView</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
<p>这代表着views持有一个对于activity的引用。所以，如果你泄漏了Context(你保留了一个对它的引用，在GC的时候保护了它)。如果你不够小心的话，泄漏掉整个Activity是很容易的。<br>    当屏幕的显示方向发生变化时，系统将会(默认)销毁现在的Activity，维护它的一些数据然后新建一个Activity。如果这样做的话，Android 将会重新读取UI。想象一下，你在你的应用里面使用了一个大bitmap，你不想每次旋转的时候都重新加载它。最简单的方法就是把它放在一个静态域里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Protected <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle state)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(state);</span><br><span class="line">    <span class="type">TextView</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextView</span>(<span class="built_in">this</span>);</span><br><span class="line">    label.setText(<span class="string">&quot;Leaks are bad&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sBackground == <span class="literal">null</span>)&#123;</span><br><span class="line">        sBackground = getDrawable(R.drawable.hezhangjian);</span><br><span class="line">    &#125;</span><br><span class="line">    label.setBackgroundDrawable(sBackground);</span><br><span class="line">    setContentView(label);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>


<p>上述代码很快但是是错误的，它泄漏了在第一次屏幕旋转之前的Activity。当一个Drawable连系在view上时，view就像被设置为drawable的回调一样。对于上面的代码，就是说drawable持有了对于textview的引用，而textview又持有了activity的引用。这就把Activity泄漏掉了。当Activity被销毁的时候，把drawable的回调设置为null。<br>    有两种简单的方式去避免内存泄漏。第一个就是避免context超范围的使用。例子上展示的是静态引用但是内部类以及他们持有的对外部类的明确引用也同样危险。第二个解决方法，利用Application context，这个context的存活时间跟你的应用一样久。如果打算保持一个长久的对象，就用 Context.getApplicationContext() 或者 Activity.getApplication()。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2016/09/08/Android%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/08/Android%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/" class="post-title-link" itemprop="url">Android中实现定时任务【翻译】</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-08 09:34:23" itemprop="dateCreated datePublished" datetime="2016-09-08T09:34:23+08:00">2016-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-19 13:21:29" itemprop="dateModified" datetime="2025-10-19T13:21:29+08:00">2025-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://android-developers.blogspot.sg/2007/11/stitch-in-time.html?m=0">http://android-developers.blogspot.sg/2007/11/stitch-in-time.html?m=0</a></p>
<p>1.利用TimerTask实现任务的定时执行 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TextView hezhangjian;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于计数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    hezhangjian = (TextView) findViewById(R.id.hezhangjian);</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();<span class="comment">//新建一个Timer</span></span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">UpdateTimeTask</span>(),<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//通过schedule方法执行一个TimerTask，Timertask是一个抽象类，必须重写它的run方法。</span></span><br><span class="line">    <span class="comment">//task,long a,long b代表的是先等待a毫秒的延迟执行任务，然后每次等待大约b时间执行任务。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateTimeTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                hezhangjian.setText(<span class="string">&quot;这是&quot;</span>+<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.利用Handler实现定时任务的操作</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TextView hezhangjian;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Handler mHandler;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>();<span class="comment">//初始化handler</span></span><br><span class="line">    hezhangjian = (TextView) findViewById(R.id.hezhangjian);</span><br><span class="line">    mHandler.postDelayed(<span class="keyword">new</span> <span class="title class_">UpdateTimeTask</span>(),<span class="number">200</span>);<span class="comment">//延迟200，执行这个任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateTimeTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                hezhangjian.setText(<span class="string">&quot;这是&quot;</span>+<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;次&quot;</span>);<span class="comment">//执行完毕</span></span><br><span class="line">                mHandler.postDelayed(<span class="keyword">new</span> <span class="title class_">UpdateTimeTask</span>(),<span class="number">100</span>);<span class="comment">//延迟100，再执行这个任务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想要取消这个post事件，你可以使用handler的removeCallbacks(TimerTask task)方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhangjian He</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
