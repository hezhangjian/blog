<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hezhangjian.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"normal"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="张俭的博客">
<meta property="og:url" content="https://hezhangjian.com/page/10/index.html">
<meta property="og:site_name" content="张俭的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhangjian He">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hezhangjian.com/page/10/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>张俭的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">张俭的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangjian He</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hezhangjian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/hezhangjian" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/05/13/%E4%B8%9A%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/business-config-center-impl" class="post-title-link post-title-link-external" itemprop="url">业务配置中心的实现<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-13 15:44:23" itemprop="dateCreated datePublished" datetime="2021-05-13T15:44:23+08:00">2021-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在InfoQ的《华为云物联网四年配置中心实践》文章中分享了业务配置中心。</p>
<p>本文讲述业务配置中心（下文简述为配置中心）的关键技术和实现方式。华为云物联网平台按照本文的实现方式实现了一个业务配置中心，该配置中心2020年1月上线，平稳运行至今。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="运维配置"><a href="#运维配置" class="headerlink" title="运维配置"></a>运维配置</h2><p>和用户无关，通常为集群界级别的配置，程序只会进行读取，如数据库配置、邮箱服务器配置、网卡配置、子网地址配置等。</p>
<h2 id="业务配置"><a href="#业务配置" class="headerlink" title="业务配置"></a>业务配置</h2><p>作为SaaS 服务，每个用户在上面都有一些业务配置。如用户的证书配置、用户服务器的流控配置等，这些业务配置相对<strong>运维配置</strong>来说更加复杂，且可能会有唯一性限制，如按用户 id 唯一。这部分配置数据一般由用户操作触发，代码动态写入，并且通知到各个微服务实例。通常，我们希望这些配置能在界面展示，且支持人为修改。上述逻辑如果由各微服务自己实现，会存在大量重复代码，并且质量无法保证。我们希望由一个公共组件来统一实现这个能力。开源或体量较小的项目就不会选择依赖一个配置中心，而是直接通过连接数据库或etcd来解决问题</p>
<h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><p>代表一个部署环境。</p>
<h2 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h2><p>代表环境下的集群。常见于单环境下蓝绿发布，蓝集群、绿集群、金丝雀集群等。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置名称，如用户证书配置、用户流控配置等。</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>配置的唯一键，如用户id。</p>
<h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><p>配置唯一键对应的值。</p>
<h1 id="配置中心设计梗概"><a href="#配置中心设计梗概" class="headerlink" title="配置中心设计梗概"></a>配置中心设计梗概</h1><h2 id="业务配置特点"><a href="#业务配置特点" class="headerlink" title="业务配置特点"></a>业务配置特点</h2><ul>
<li>虽然业务配置写入可能存在并发，但并发量不大，频率较低。</li>
<li>业务配置常常以用户为id，单集群用户量有限，一般不超过5万。</li>
</ul>
<h2 id="配置中心要解决的问题"><a href="#配置中心要解决的问题" class="headerlink" title="配置中心要解决的问题"></a>配置中心要解决的问题</h2><p><img src="/Images/business-config-center-impl1.png" alt="business-config-center-impl1"></p>
<h2 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h2><ul>
<li>单配置要求有配置id，每个id上通过version的乐观并发控制来解决多版本冲突问题</li>
<li>通知不追求可靠，应用程序和配置中心断链无法接收通知的场景下，通过定期同步数据来保证数据的可靠</li>
<li>支持Schema的变更，因Schema变更不频繁，也采用version的乐观并发控制来解决多版本冲突问题</li>
</ul>
<h2 id="通知是否包含消息内容"><a href="#通知是否包含消息内容" class="headerlink" title="通知是否包含消息内容"></a>通知是否包含消息内容</h2><p>我认为应该只通知Key，具体的数值让应用程序再去配置中心查询。仅通知Key实现简洁易懂。同时通知Key&amp;Value需要多考虑定期同步和通知两条通道并发，可能引起的竞态冲突。</p>
<h1 id="配置中心业务流程"><a href="#配置中心业务流程" class="headerlink" title="配置中心业务流程"></a>配置中心业务流程</h1><p>本小节描述业务配置中心的所有业务流程，并试图从交互中抽象出与具体实现无关的接口</p>
<h2 id="配置的增删改查"><a href="#配置的增删改查" class="headerlink" title="配置的增删改查"></a>配置的增删改查</h2><p><img src="/Images/business-config-center-impl2.png" alt="business-config-center-impl2"></p>
<h2 id="配置值的增删改查"><a href="#配置值的增删改查" class="headerlink" title="配置值的增删改查"></a>配置值的增删改查</h2><p><img src="/Images/business-config-center-impl3.png" alt="business-config-center-impl3"></p>
<h2 id="定期同步"><a href="#定期同步" class="headerlink" title="定期同步"></a>定期同步</h2><p>分布式场景下，通知有可能无法送达，如程序陷入网络中断（或长gc），通知消息送达超时，待程序恢复后，数据不再准确。因此需要对数据做定期同步，提高可靠性。</p>
<p><img src="/Images/business-config-center-impl4.png" alt="business-config-center-impl4"></p>
<p>同步过程中，仅仅请求交互id和version，避免传输大量数据。应用程序接收到需要同步的数据后：</p>
<ul>
<li>删除操作，触发删除通知，从本地缓存中移除数据。</li>
<li>添加、修改操作，向配置中心查询最新数据，触发通知并写入本地缓存。</li>
</ul>
<h2 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h2><p>服务启动也可看做是一个同步的流程，只是需要同步大量的数据添加。为了避免向配置中心频繁大量的请求，引入批量操作来减轻压力</p>
<p><img src="/Images/business-config-center-impl5.png" alt="business-config-center-impl5"></p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>该配置中心设计思路依赖客户端可把数据全量放入到内存中，如用户量太大，则不适合采用这种模式。</p>
<p>注：一个节省内存的思路是，内存中只放置全量的id和version，数据只有当用到的时候再去查询。这个思路要求配置中心持久化一些老旧数据以供以下场景的查询使用</p>
<ul>
<li><p>业务流程中，需要使用该配置值的。</p>
</li>
<li><p>回调业务程序修改的时候，需要提供旧值的。</p>
</li>
</ul>
<p>除此之外没有任何区别。</p>
<h1 id="业务配置抽象实现"><a href="#业务配置抽象实现" class="headerlink" title="业务配置抽象实现"></a>业务配置抽象实现</h1><p>从上述描述的业务场景，我们抽象出业务配置中心的交互接口和抽象实现。接口的Swagger Yaml已上传到Github：<a target="_blank" rel="noopener" href="https://gist.github.com/hezhangjian/68c9c2ecae72cc2a125184e95b0a741e">https://gist.github.com/hezhangjian/68c9c2ecae72cc2a125184e95b0a741e</a></p>
<h2 id="配置相关接口"><a href="#配置相关接口" class="headerlink" title="配置相关接口"></a>配置相关接口</h2><ul>
<li>提供env、cluster、配置名称、配置Schema、配置版本号添加配置</li>
<li>提供env、cluster、配置名称删除配置</li>
<li>提供env、cluster、配置名称、新Schema、新Version来修改配置</li>
<li>提供env、cluster、配置名称来查询配置</li>
</ul>
<h2 id="配置值相关接口"><a href="#配置值相关接口" class="headerlink" title="配置值相关接口"></a>配置值相关接口</h2><ul>
<li>提供env、cluster、配置名称、Key、Value来添加配置值</li>
<li>提供env、cluster、Key、ValueVersion（可选）来删除配置值</li>
<li>提供env、cluster、Key、Value、ValueVersion（可选）修改配置值</li>
<li>提供env、cluster、Key查询配置值</li>
<li>根据env、cluster、应用程序当前的配置数据来做定期同步</li>
<li>根据Key列表批量查询配置值</li>
</ul>
<h2 id="通知相关接口"><a href="#通知相关接口" class="headerlink" title="通知相关接口"></a>通知相关接口</h2><ul>
<li>通知某env某cluster下，配置项中的一个Key发生变化，新增、修改或是删除。可选方式有HTTP长链接（Inspired by Apollo）、Mqtt、WebSocket等。</li>
</ul>
<h2 id="配置中心存储层抽象实现"><a href="#配置中心存储层抽象实现" class="headerlink" title="配置中心存储层抽象实现"></a>配置中心存储层抽象实现</h2><p>配置中心存储层需要存储<strong>配置</strong>和<strong>配置值</strong>数据，支持UpdateByVersion，且需要捕捉数据的变化，用来通知到应用程序</p>
<h2 id="服务发现抽象实现"><a href="#服务发现抽象实现" class="headerlink" title="服务发现抽象实现"></a>服务发现抽象实现</h2><p>为了使应用程序连接到配置中心，需要一个发现机制可以让应用程序感知到配置中心的地址。高可用的方式很多，如K8s发现、ZooKeeper、Etcd、ServiceComb、业务环境变量注入ELB地址（ELB后端挂载配置中心的地址）等。</p>
<h2 id="抽象总结"><a href="#抽象总结" class="headerlink" title="抽象总结"></a>抽象总结</h2><p><img src="/Images/business-config-center-impl6.png" alt="business-config-center-impl6"></p>
<p>根据这个抽象，我们可以进行关键技术点选型，来实现业务配置中心。</p>
<h1 id="配置中心实现"><a href="#配置中心实现" class="headerlink" title="配置中心实现"></a>配置中心实现</h1><h2 id="华为云物联网配置中心实现"><a href="#华为云物联网配置中心实现" class="headerlink" title="华为云物联网配置中心实现"></a>华为云物联网配置中心实现</h2><p><img src="/Images/business-config-center-impl7.png" alt="business-config-center-impl7"></p>
<ul>
<li>env+cluster+config组成数据表的名称</li>
<li>一个key、value对应一行数据</li>
</ul>
<h2 id="另一种实现方式"><a href="#另一种实现方式" class="headerlink" title="另一种实现方式"></a>另一种实现方式</h2><p>只要实现上述接口和抽象能力，都可以实现业务配置中心，也可以这么实现</p>
<p><img src="/Images/business-config-center-impl8.png" alt="business-config-center-impl8"></p>
<ul>
<li>env+cluster+config+key 组合成etcd的key</li>
<li>一个key、value对应一个键值对</li>
</ul>
<h2 id="又一种实现方式"><a href="#又一种实现方式" class="headerlink" title="又一种实现方式"></a>又一种实现方式</h2><p>当然也可以</p>
<p><img src="/Images/business-config-center-impl9.png" alt="business-config-center-impl9"></p>
<ul>
<li>env+cluster+config+key 组合成RocksDB的key</li>
<li>一个key、value对应一个键值对</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/05/10/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%BC%98%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7----%E6%8B%B7%E8%B4%9D%E6%97%B6%E6%8C%87%E5%AE%9A%E7%94%A8%E6%88%B7%E5%B1%9E%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/10/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%BC%98%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7----%E6%8B%B7%E8%B4%9D%E6%97%B6%E6%8C%87%E5%AE%9A%E7%94%A8%E6%88%B7%E5%B1%9E%E7%BB%84/" class="post-title-link" itemprop="url">容器镜像优化小技巧----拷贝时指定用户属组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-10 18:24:23" itemprop="dateCreated datePublished" datetime="2021-05-10T18:24:23+08:00">2021-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一句话结论，可以在拷贝镜像文件的时候，通过如下命令指定user来压缩dockerfile的体积，避免把指定的文件在dockerfile中计算两次。</p>
<p>为什么要指定User？</p>
<ul>
<li>往往，我们会因为安全的要求，不允许使用root用户运行程序。</li>
<li>像ElasticSearch这个开源组件要求不能用root用户运行，其实也是出于安全的原因</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=sh:sh <span class="built_in">source</span> /opt/sh</span></span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>先使用dd命令创建1GB的测试文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=testfile bs=1024 count=1048576</span><br></pre></td></tr></table></figure>

<p>测试基础镜像ttbb&#x2F;base:latest，大小439MB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images|grep &#x27;ttbb/base&#x27;|grep latest</span><br><span class="line">ttbb/base                                                 latest                 bacdb9e7b5f4        2 weeks ago         439MB</span><br></pre></td></tr></table></figure>

<h3 id="优化前DockerFile"><a href="#优化前DockerFile" class="headerlink" title="优化前DockerFile"></a>优化前DockerFile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ttbb/base</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> testfile /opt/sh/testfile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R sh:sh /opt/sh/testfile</span></span><br></pre></td></tr></table></figure>

<p>大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1280d315e09d        31 seconds ago      2.59GB</span><br></pre></td></tr></table></figure>

<p>可以看到testfile计算了两次，大小达到了2G多。</p>
<h3 id="优化后DockerFile"><a href="#优化后DockerFile" class="headerlink" title="优化后DockerFile"></a>优化后DockerFile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ttbb/base</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=sh:sh testfile /opt/sh/testfile</span></span><br></pre></td></tr></table></figure>

<p>大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">115b68bc4db8        21 seconds ago       1.51GB</span><br></pre></td></tr></table></figure>

<p>testfile仅计算一次，仅使用1.5G。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/05/07/Raft%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/07/Raft%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Raft论文笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-07 18:24:18" itemprop="dateCreated datePublished" datetime="2021-05-07T18:24:18+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Raft主要使用了重叠的大多数技术来保证算法的安全</p>
<p>Raft首要追求的是可理解性</p>
<h3 id="Raft使用数个技术来提升可理解性。包括"><a href="#Raft使用数个技术来提升可理解性。包括" class="headerlink" title="Raft使用数个技术来提升可理解性。包括"></a>Raft使用数个技术来提升可理解性。包括</h3><ul>
<li>问题分解：主备选举、日志复制、安全性</li>
<li>尽量减少状态空间（相比Paxos，Raft减少了不确定性）</li>
</ul>
<h3 id="Raft新颖的特性"><a href="#Raft新颖的特性" class="headerlink" title="Raft新颖的特性"></a>Raft新颖的特性</h3><h3 id="强leader"><a href="#强leader" class="headerlink" title="强leader"></a>强leader</h3><p>日志文件只单向传输，简化状态</p>
<h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><p>Raft使用随机定时器来选举leader。只添加了很小的机制，却能简单、快速解决冲突</p>
<h3 id="Membership变更"><a href="#Membership变更" class="headerlink" title="Membership变更"></a>Membership变更</h3><p>Raft的Membership变更机制使用<code>joint consensus</code>方法，在变更过程中，两个不同配置的<strong>大多数</strong> 重叠。这使得在集群成员变更时，也能正常处理请求</p>
<h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><h3 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h3><p>保证复制状态机的一致,也就保证了数据的一致</p>
<h2 id="一致性算法拥有如下的典型属性"><a href="#一致性算法拥有如下的典型属性" class="headerlink" title="一致性算法拥有如下的典型属性"></a>一致性算法拥有如下的典型属性</h2><ul>
<li>在非拜占庭场景下，保证了正确性。包括 网络延迟、分区、丢包、乱序等</li>
<li>当大多数节点在线的时候，功能可用</li>
<li>不依赖时间来保证日志的一致性。错误的时钟和极大地消息延时，在最差的场景下，可能会导致一致性问题</li>
<li>在最常见的场景下，当一轮大多数节点反悔的时候，就能完成一个命令。小部分节点响应缓慢并不影响系统的整体性能。</li>
</ul>
<h1 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>新的leader必须在已存在的leader宕机后选出</p>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>leader必须从客户端哪里接收日志请求，复制到整个集群，迫使其他人达成一致</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Raft的安全属性关键。如果任何服务器将一个entry log复制到状态机中，那么其他任意服务器都不能在相同的log index上放置不同的命令。</p>
<h2 id="安全的详细内容"><a href="#安全的详细内容" class="headerlink" title="安全的详细内容"></a>安全的详细内容</h2><h3 id="Election-Safety-选举安全"><a href="#Election-Safety-选举安全" class="headerlink" title="Election Safety 选举安全"></a>Election Safety 选举安全</h3><p>每一个任期内，至多只会有一个leader</p>
<h3 id="Leader仅追加"><a href="#Leader仅追加" class="headerlink" title="Leader仅追加"></a>Leader仅追加</h3><p>leader不会覆写或者删除已存在的entry，只会追加新的entry（todo 待确认，是写入的，还是commit的，从leader可能是一个老的节点来说，这里应该说commit的更为恰当）</p>
<h3 id="Log-Matching-日志匹配"><a href="#Log-Matching-日志匹配" class="headerlink" title="Log Matching 日志匹配"></a>Log Matching 日志匹配</h3><p>如果两个日志具有相同的任期值和相同的index，那么直到这个index之前的日志都是一样的</p>
<h3 id="Leader-Completeness-Leader完整性"><a href="#Leader-Completeness-Leader完整性" class="headerlink" title="Leader Completeness Leader完整性"></a>Leader Completeness Leader完整性</h3><p>如果一个日志在一个给定任期内提交了，那么这个日志会一直存在，存在在任何高任期的Leader之中</p>
<h3 id="State-Machine-Safety-状态机安全"><a href="#State-Machine-Safety-状态机安全" class="headerlink" title="State Machine Safety 状态机安全"></a>State Machine Safety 状态机安全</h3><p>如果服务器已在其状态机上将给定索引的日志条目应用于其状态机，则其他服务器将永远不会对同一索引应用不同的日志条目</p>
<h2 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h2><p>Raft将时间切分成任期时长间隔的任期。Raft保证一个任期内至多只有一个Leader。任期可以称为是Raft中的逻辑时钟。每个服务器之间都会互相传播任期值。</p>
<h2 id="Leader选举-1"><a href="#Leader选举-1" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>Raft使用随机的选举时间来保证分裂投票场景少见并快速解决。将选举超时设定为一个范围。</p>
<p>Raft的作者们考虑过使用不同的Rank值，当分裂投票的时候，Rank值高的优先成为主节点，但在可用性方面有细微的问题。Rank值低的节点需要超时才能成为新的leader，这个时间间隔如果太短，会破坏已有的选举，集群太过敏感）</p>
<p>最终认为随机的措施更明显、更易懂</p>
<h2 id="日志复制-1"><a href="#日志复制-1" class="headerlink" title="日志复制"></a>日志复制</h2><p>Leader来决定何时将日志提交到状态机是安全的，叫做<strong>committed</strong>提交。Raft保证提交过的entry都是持久化的，然后最终会被所有的状态机执行。</p>
<p>只有当前的Leader在任期内，然后将其复制到大多数节点，才算做committed！（这里有和仅仅复制到大多数节点有着重要的区别）然后这里会将之前的日志提交。</p>
<p>Leader每次发送AppendEntries RPC请求时，确认在这之前的日志和从节点完全相同。</p>
<p>Raft可以accept、replicate、应用新的日志记录。在正常场景下，经过一轮大多数RPC调用，就可以复制完成。</p>
<h2 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h2><p>假如，当leader提交数个日志的时候，follower不可用，然后他当选了leader之后，提交的日志把之前提交的日志覆盖了怎么办？</p>
<p>这里在选举当选leader的上面加了个限制，保证了之后的leader包含了之前所有已提交的entry。</p>
<h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>Raft使用投票阶段来防止一个没有之前提交过日志的候选者当选leader。候选者必须联络大多数节点才能当选，这就意味着提交过的entry一定在其中的一个服务器中。</p>
<h3 id="提交之前任期的entry"><a href="#提交之前任期的entry" class="headerlink" title="提交之前任期的entry"></a>提交之前任期的entry</h3><p>leader不能立刻得出结论：之前任期的日志复制到大多数节点就已经算commit了。</p>
<p><img src="/Images/raft.png" alt="image-20210325211802223"></p>
<ul>
<li>a S1是leader，然后部分复制了日志2</li>
<li>b S1宕机，S5接受了S3和S4的投票当选了任期3的leader，在index2接受了不同的entry</li>
<li>c S5宕机，S1重启，当选了leader，继续复制</li>
<li>d S1宕机，S5重启，然后用任期3的日志覆盖了其他节点</li>
<li>e 然而如果S1在宕机前，把日志覆盖到大多数节点，那么S5就不能当选leader了</li>
</ul>
<p>为了避免上图的问题，Raft绝不将复制的数量当作commit 日志的依据。只有当前任期下的entry log通过复制数量来计算。一旦当前任期的entry被提交，那么之前所有的entry都被间接commit了。</p>
<h3 id="安全性保证"><a href="#安全性保证" class="headerlink" title="安全性保证"></a>安全性保证</h3><p>我们用反证法证明一旦<strong>Leader Completeness Property</strong>没有满足，我们就会推断出一个矛盾。假设任期T的Leader提交了一个log entry在任期T，但是这个log entry没有被将来一些任期的Leader拥有。假设有一个没有包含这个entry的最小的任期U的Leader，Leader U没有存储这个entry</p>
<ul>
<li><ol>
<li>在选举的时候，提交的entry必须不在leader U的日志中（leader从不删除或复写日志）</li>
</ol>
</li>
<li><ol start="2">
<li>Leader将这个entry复制到了集群中的大多数节点，并且leader U接收到了集群中大多数节点的投票。至少有一个服务器，即从leader T哪里接受了entry，并且给U投票。这是达成矛盾的关键</li>
<li>voter 必须在接收leaderT的entry之前给U投票。否则它就要拒绝T的写入请求</li>
<li>当voter给U投票的时候，它始终持久化着这个日志，因为每个中间的leader都包含这个entry，leader不会删除这个entry，除非冲突，follower也不会删除这个entry</li>
<li>voter给U投票，所以U的日志必须至少和voter的一样新，这就达成了第一个冲突</li>
<li>首先假设，如果voter和U都有同样的上一次log的任期，U的日志至少和vote一样。矛盾，因为最初假设U没有这个log，而voter有。</li>
<li>否则，leader U的上次log任期比voter的大。此外，它比T大，因为选民的上一个log term至少为T（其中包含来自T的提交entry）。 创建leaderU的最后一个log term的较早的领导者必须在其日志中包含已提交的条目（通过假设）。 然后，通过<strong>Log Matching Property</strong>，leaderU的日志还必须包含已提交的条目，这是矛盾的</li>
<li>这就完成了矛盾的证明。比T任期大的leader一定包含了任期T内提交的entry</li>
</ol>
</li>
</ul>
<h3 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h3><p>Raft可以选举并维持一个稳定的leader，只要系统满足如下的时间限制条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</span><br></pre></td></tr></table></figure>

<p>broadcastTime是进行一个并行rpc到所有服务器来回的平均时间。MTBF是单个服务器故障的平均时间。</p>
<p>广播时间必须比选举时间小一个量级，所以leader放心的发送心跳消息，维护自己的follower。加上随机的选举时延，这个不等式也让选票分裂变得不可能。 如果广播时间和选举时间差不多，选举leader不稳定。</p>
<p>选举超时应该比MTBF小几个数量级，要不然选举的leader就不稳定。<br>broadcast的时间差不多在0.5ms到20ms<br>选举超时应该在100ms到500ms。<br>典型的服务器MTBF时间应该在数月或以上</p>
<h1 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h1><p>成员变更的时候，中途必须没有两个相同任期的leader。不幸的是，任何将服务器们直接从老配置变换到新配置都是不安全的。不可能一次性地原子性地把所有服务器的配置变更，所以中集群在中途可能会分裂为两个多数派。<br>为了保证安全性，集群成员变更必须使用两阶段的方式。有很多种方式实现两阶段提交。例如，一些系统使用第一次提交来禁用旧的配置，使得旧的配置无法接受客户端的请求，然后第二次操作启动新的配置。在Raft中，集群首先切换到一个过度的配置，叫做<code>joint consensus</code>。一旦<code>joint consensus</code>被提交，系统接下来过渡到新的配置。<code>joint consensus</code>结合了新老配置</p>
<ul>
<li>Log entry在两种配置下都会复制。即新机器和老机器都会复制entry</li>
<li>不管是老配置还是新配置，都有可能当选leader</li>
<li>Agreement(协议，包括选举和entry提交)需要老配置和新配置多数派都确认<br>补图 Figure11<br>集群配置通过复制日志中的特殊entry来进行存储、通信。</li>
</ul>
<p>上述流程有三个问题<br>第一个问题是，新的服务器可能初始没有存储任何log entry。如果现在添加到集群中，会花费一些时间来跟上集群的数据，这中间有可能无法commit新的log entry。为了避免可用性的gap。Raft在配置变更之前引入了一个额外的阶段，新的服务器首先<br>第二个问题是，cluster的leader可能不是新配置中的服务器。这个场景，leader的变化发生在新配置提交的时候。<br>第三个问题是，移除的服务器可以打乱整个集群。这些服务器接收不到心跳，这些服务器会超时然后启动新的选举。他们将使用新的任期发送<strong>RequestVote</strong> RPC，会导致当前的leader变为follower。新的leader最终会被选举，但是移除的服务器将会再次超时，重复整个过程，最终导致集群较差的可用性。<br>为了解决这个问题，Server当认为有leader存在的时候，会忽略<strong>RequestVote</strong>请求。如果服务器在选举超时前接收到<strong>RequestVote</strong> RPC请求，它并不会更新它的任期或是给予它的投票。这并不影响正常的选举（每个服务器在选举之前等待最小超时时间）。并且，这有助于避免移除的server破坏选举：如果一个leader可以发送心跳到他负责的集群中的大多数节点，他将不会被更高任期的节点罢免。</p>
<p>成员变更过程中如果发生Failover，老Leader宕机， Cold,new中任意一个节点都可能成为新Leader，如果新 Cold,newLeader上没有 日志，则继续使用Cold ，Follower上如果有 Cold,new 日志会被新Leader截断，回退到 Cold，成员变更失败；如果新Leader上有  Cold,new日志，则继续将未完成的成员变更流程走完。</p>
<p>新成员先加入再同步数据，成员变更可以立即完成，并且因为只要大多数成员同意即可加入，甚至可以加入还不存在的成员，加入后再慢慢同步数据。但在数据同步完成之前新成员无法服务，但新成员的加入可能让多数派集合增大，而新成员暂时又无法服务，此时如果有成员发生Failover，很可能导致无法满足多数成员存活的条件，让服务不可用。因此新成员先加入再同步数据，简化了成员变更，但可能降低服务的可用性。</p>
<p>新成员先同步数据再加入，成员变更需要后台异步进行，先将新成员作为Learner角色加入，只能同步数据，不具有投票权，不会增加多数派集合，等数据同步完成后再让新成员正式加入，正式加入后可立即开始工作，不影响服务可用性。因此新成员先同步数据再加入，不影响服务的可用性，但成员变更流程复杂，并且因为要先给新成员同步数据，不能加入还不存在的成员。</p>
<h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p>每当有新的操作发生的时候，Raft的日志就会增长，然而在实际的系统中，日志并不能无边界地增长。<br>快照是最简单的压缩日志的方式。在快照中，整个系统的状态写入到持久化存储的快照中，然后在这之前的日志都可以丢弃。<br>todo 补图<br>其他方式，像日志清理或lsm树。在数据的一部分子集上面执行，它们均摊了压缩日志的消耗。</p>
<p>Leader创建snapshot，再分发给follower。有如下两个缺点<br>第一，Server必须选择何时进行快照，如果服务器快照进行地太频繁，将会浪费磁盘带宽和磁盘energy。如果快照太不频繁，会浪费磁盘的存储空间，然后增加了重放日志所需的时间。如果阈值设置地大，时间周期长的话，磁盘开销小。<br>第二，写快照会消耗较大的时间，我们不希望这个操作延迟了正常的操作。方案是使用<strong>Copy on write</strong>技术，这样子在不影响snapshot写入的情况下，集群可以接受新的更新。</p>
<h1 id="客户端的交互"><a href="#客户端的交互" class="headerlink" title="客户端的交互"></a>客户端的交互</h1><p>Raft实现了线性化的语义。<strong>Linearizable semantics</strong>。像es那样使用version，是达不到线性化的语义的。<br>在读取数据的时候需要额外的措施来保证线性化的语义。首先，leader必须知道最新有那些entry已经提交。<strong>Leader Completeness Property</strong> 保证了leader有所有的committed entries，但是在任期的开头，可能并不知道那些entry已被提交。（为了确认，可以发空请求来commit数据）<br>通过向大多数节点来发送心跳，来保证读请求的返回的是最新的。这里就依赖了前面所说的时钟。依赖时钟来实现安全。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>todo 补图<br>随机杀死leader，重新选举最短时间刚好是leader选举超时的一半，因为心跳超时时间刚好是选举超时的一半。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="InstallSnapshot-RPC接口"><a href="#InstallSnapshot-RPC接口" class="headerlink" title="InstallSnapshot RPC接口"></a>InstallSnapshot RPC接口</h2><p>由leader调用，发送snapshot的一部分到从节点。Leader总是按顺序发送chunk</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>term leader的任期</li>
<li>leaderId 使得follower可重定向client的请求</li>
<li>lastIncludedIndex snapshot最后包含的index号</li>
<li>lastIncludedTerm snapshot最后包含的最后一个任期号</li>
<li>offset chunk在整个snapshot中的offset</li>
<li>data[] 原始数据</li>
<li>done 如果是last chunk则为true</li>
</ul>
<h3 id="返回体"><a href="#返回体" class="headerlink" title="返回体"></a>返回体</h3><p>term 当前任期，使得leader可以根据这个结果判断是否做操作</p>
<h3 id="接收方的实现"><a href="#接收方的实现" class="headerlink" title="接收方的实现"></a>接收方的实现</h3><ul>
<li>如果接收到的任期小于当前任期，则立刻返回</li>
<li>如果接收到的chunk offset为0，则开始创建快照文件</li>
<li>在给定的offset处写入数据</li>
<li>如果done为false，返回且等待接下来的数据</li>
<li>保存snapshot文件，丢弃之前存在的所有快照文件</li>
<li>如果现有日志条目的索引和术语与快照的最后一个包含的条目相同，请保留其后的日志条目并回复</li>
<li>丢弃整个日志文件</li>
<li>把状态机重设为快照的内容（也使用快照内的集群信息）</li>
</ul>
<h2 id="State-状态"><a href="#State-状态" class="headerlink" title="State 状态"></a>State 状态</h2><h3 id="所有服务器上的持久化状态"><a href="#所有服务器上的持久化状态" class="headerlink" title="所有服务器上的持久化状态"></a>所有服务器上的持久化状态</h3><p>在响应RPC之前更新到持久化存储上</p>
<ul>
<li>当前任期 server见过的最大任期值（初始值是0，单调递增）</li>
<li>votedFor 在当前任期内获得投票的候选人ID（如果没有，则为null）</li>
<li>log[] log entry;每一个包含一个状态机的命令，包含从leader获取的任期（初始index为1）</li>
</ul>
<h3 id="所有服务器上的可变状态"><a href="#所有服务器上的可变状态" class="headerlink" title="所有服务器上的可变状态"></a>所有服务器上的可变状态</h3><ul>
<li>commitIndex 已知要提交的最高日志条目的index（初始值是0，单调递增）</li>
<li>lastApplied 已知要应用到状态机上的最高index（初始值是0，单调递增）</li>
</ul>
<h3 id="leader上的可变状态"><a href="#leader上的可变状态" class="headerlink" title="leader上的可变状态"></a>leader上的可变状态</h3><p>选举后重新初始化</p>
<ul>
<li>nextIndex[] 对每个服务器，将要送给另一个服务器的下一个log entry的index（初始化为leader的lastLogIndex+1）</li>
<li>matchIndex[] 对每个服务器，知道的复制到该服务器的最大的log entry的索引。（初始化为0，单调递增）</li>
</ul>
<h2 id="AppendEntryies-RPC"><a href="#AppendEntryies-RPC" class="headerlink" title="AppendEntryies RPC"></a>AppendEntryies RPC</h2><p>被leader触发，用来复制log entry；也用于心跳。</p>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li>term leader的任期</li>
<li>leaderId 使得follower可重定向client的请求</li>
<li>prevLogIndex 紧接新记录之前的日志条目索引</li>
<li>prevLogTerm 紧接新记录之前的日志条目索引的任期</li>
<li>entries[] 要存储的entries。心跳时为空，批量来提升性能</li>
<li>leaderCommit leader的commit index提交索引</li>
</ul>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><ul>
<li>term 当前任期，使得leader可以根据这个结果判断是否做操作</li>
<li>success 如果follower包含了匹配的prevLogIndex和prevLogTerm，就返回true</li>
</ul>
<h3 id="接收方实现"><a href="#接收方实现" class="headerlink" title="接收方实现"></a>接收方实现</h3><ul>
<li>如果term &lt; current term，返回false</li>
<li>如果不包含匹配的prevLogIndex和prevLogTerm，就返回false</li>
<li>如果有一个存在的entry和新的冲突（相同的index，不同的term），删除哪个entry和在其之后的所有entry</li>
<li>添加没在log里面的所有entry</li>
<li>如果leaderCommit &gt; commitIndex, 设置commitIndex为leaderCommit、lastNewEntry的最小值</li>
</ul>
<h2 id="RequestVote-RPC"><a href="#RequestVote-RPC" class="headerlink" title="RequestVote RPC"></a>RequestVote RPC</h2><p>由candidate调用来收集选票</p>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul>
<li>term 候选者的任期</li>
<li>candidateId 候选者的请求投票</li>
<li>lastLogIndex 候选者的最后log entry的索引</li>
<li>lastLogTerm 候选者的最后log entry的任期</li>
</ul>
<h3 id="返回结果-1"><a href="#返回结果-1" class="headerlink" title="返回结果"></a>返回结果</h3><ul>
<li>term 任期，可以让candidate根据任期做操作</li>
<li>voteGranted true代表候选者收到了选票</li>
</ul>
<h3 id="接收方实现-1"><a href="#接收方实现-1" class="headerlink" title="接收方实现"></a>接收方实现</h3><ul>
<li>如果term &lt; currentTerm返回false</li>
<li>如果votedFor或candidateId是null，并且候选者日志至少比接受者的新，给予自己的投票</li>
</ul>
<h2 id="Server遵守的规则-Rules-for-Servers"><a href="#Server遵守的规则-Rules-for-Servers" class="headerlink" title="Server遵守的规则 Rules for Servers"></a>Server遵守的规则 Rules for Servers</h2><h3 id="所有服务器"><a href="#所有服务器" class="headerlink" title="所有服务器"></a>所有服务器</h3><ul>
<li>如果commitIndex &gt; lastApplied: 增加lastApplied，把log[lastAplied]应用到状态机上</li>
<li>如果rpc请求或响应中，包含的任期T比当前的Term值大，则将当前的任期值设置为T，转换自己为follower</li>
</ul>
<h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h3><ul>
<li>向候选者和leader响应rpc</li>
<li>在选举超时的时间间隔内，没有接收到<strong>AppendEntries</strong> RPC请求或者投票给其他人，那么切换为候选者</li>
</ul>
<h3 id="候选者"><a href="#候选者" class="headerlink" title="候选者"></a>候选者</h3><ul>
<li>一旦转化为候选者，开始选举<ul>
<li>增加任期号</li>
<li>给自己投票</li>
<li>重置选举定时器</li>
<li>向其他服务器发送<strong>RequestVote</strong> RPC请求</li>
</ul>
</li>
<li>如果接收到了大部分节点的投票，成为leader</li>
<li>如果<strong>AppendEntries</strong> RPC从新的leader处返回，变为follower</li>
<li>如果选举超时，启动新的选举流程</li>
</ul>
<h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h3><ul>
<li>选举完成后：发送空的<strong>AppendEntries</strong> RPC请求到每个服务器（心跳），在空闲期间重复此操作避免选举超时</li>
<li>从客户端哪里接收到命令；添加entry到本地的日志中，待把这个entry复制到状态机后响应</li>
<li>如果对一个follower有，last log index &gt;&#x3D; nextIndex，从nextIndex开始发送<strong>AppendEntries</strong> RPC请求<ul>
<li>如果成功：更新follower的nextIndex和matchIndex</li>
<li>如果因为日志不一致的原因失败：降低nextIndex然后重试</li>
</ul>
</li>
<li>如果存在N，且N&gt;commitIndex,大多数节点的matchIndex[i]&gt;&#x3D;N，并且log[N].term &#x3D;&#x3D; cuurentTerm,设置commitIndex&#x3D;N</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/05/06/Pulsar%20broker%E9%87%87%E6%A0%B7%E8%BF%BD%E8%B8%AA%E5%8F%8A%E5%AF%B9%E6%8E%A5skywalking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/06/Pulsar%20broker%E9%87%87%E6%A0%B7%E8%BF%BD%E8%B8%AA%E5%8F%8A%E5%AF%B9%E6%8E%A5skywalking/" class="post-title-link" itemprop="url">Pulsar broker采样追踪及对接skywalking</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-06 22:14:31" itemprop="dateCreated datePublished" datetime="2021-05-06T22:14:31+08:00">2021-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="为什么要采样追踪对接SkyWalking"><a href="#为什么要采样追踪对接SkyWalking" class="headerlink" title="为什么要采样追踪对接SkyWalking"></a>为什么要采样追踪对接SkyWalking</h3><p>为了提升Pulsar的可维护性，我们希望能深入<code>pulsar</code>和<code>bookkeeper</code>的底层，做性能剖析，识别中间延时高的环节，然后很方便地进行定位分析。</p>
<p>为什么Pulsar原生的普罗监控无法满足</p>
<ul>
<li>部门基础设施方面，所有环境都集成了ELK，大部分环境都没有普罗，且部门正在引入SkyWalking。</li>
<li>普罗的监控无法和用户的一条消息对应，较难处理单个客户保障。</li>
</ul>
<p>幸运的是，这两个问题都可以通过采样跟踪来解决。并且在合理的采样跟踪配置下，测试环境可以达成百分百采样追踪，对于我们定位测试环境问题非常方便。</p>
<p>我们就想到了使用经典的采样追踪模式来对数据进行采样，将数据输出到SkyWalking进行下一步的分析、告警。并且在没有对接SkyWalking的环境，通过日志输出来进行下一步的分析、告警</p>
<h3 id="Sample-Tracing-Basic"><a href="#Sample-Tracing-Basic" class="headerlink" title="Sample Tracing Basic"></a>Sample Tracing Basic</h3><p><img src="/Images/pulsar-skywalking1.png" alt="image-20210424091405442"></p>
<ul>
<li>通过<code>traceId</code>和<code>spanId</code>结合，识别一条链路。</li>
<li>每个<code>spanId</code>中间计算耗时</li>
<li>为了性能，不会每个<code>spanId</code>和<code>traceId</code>都收集分析，会进行采样（收集部分消息、收集时延较大的消息）</li>
</ul>
<p>注：SkyWalking采用STAM来进行拓扑分析，并且引入了Segment等概念来表达进程内、进程外等含义，但大致原理相同。</p>
<h3 id="SkyWalking-Architecture"><a href="#SkyWalking-Architecture" class="headerlink" title="SkyWalking Architecture"></a>SkyWalking Architecture</h3><p><img src="/Images/pulsar-skywalking2.jpeg" alt="Image"></p>
<h3 id="Trace-Internal-In-Pulsar"><a href="#Trace-Internal-In-Pulsar" class="headerlink" title="Trace Internal In Pulsar"></a>Trace Internal In Pulsar</h3><p>目前，我们将追踪的头部消息放在<code>BrokerMetadata</code>处，以下为追踪数据流向</p>
<h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p><img src="/Images/pulsar-skywalking3.png" alt="image-20210506200048088"></p>
<h4 id="batch-message"><a href="#batch-message" class="headerlink" title="batch message"></a>batch message</h4><p><img src="/Images/pulsar-skywalking4.png" alt="image-20210506200035405"></p>
<h3 id="Two-ways-output"><a href="#Two-ways-output" class="headerlink" title="Two ways output"></a>Two ways output</h3><h4 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h4><p>可在ELK上展示，搜索时延大的消息。（注：如搜索4位数的消息）。</p>
<h4 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h4><p>可依赖SkyWalking进行分析，告警。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th></th>
<th>Logging</th>
<th>SkyWalking</th>
</tr>
</thead>
<tbody><tr>
<td>采样方式</td>
<td>SkyWalking Way</td>
<td>SkyWalking Way</td>
</tr>
<tr>
<td>输出格式</td>
<td>Logging</td>
<td>SkyWalking protocol through kafka</td>
</tr>
<tr>
<td>追踪数据传播方式</td>
<td>protobuf、Broker Metadata</td>
<td>protobuf、Broker Metadata</td>
</tr>
</tbody></table>
<h3 id="Beyond-SkyWalking"><a href="#Beyond-SkyWalking" class="headerlink" title="Beyond SkyWalking"></a>Beyond SkyWalking</h3><p>在SkyWalking的采样算法之上，支持对时延大的消息再进行采样，输出到日志，进行分析、告警。</p>
<p>采样规则</p>
<ul>
<li>全局一秒最多xx条，单topic一秒最多xx条</li>
<li>采样时延大于xx的消息</li>
</ul>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up"></a>Follow-up</h3><ul>
<li>将Pulsar和Bookkeeper的metric信息上报到SkyWalking，使得在SkyWalking分析、告警更多信息。</li>
<li>使用agent方式实现，避免和SkyWalking协议过度耦合</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/26/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8Fps%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mysql-ps-password" class="post-title-link post-title-link-external" itemprop="url">Mysql是如何隐藏ps命令行中的密码的<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-26 19:35:38" itemprop="dateCreated datePublished" datetime="2021-04-26T19:35:38+08:00">2021-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://northernmost.org/blog/how-does-mysql-hide-the-command-line-password-in-ps/index.html">http://northernmost.org/blog/how-does-mysql-hide-the-command-line-password-in-ps/index.html</a></li>
</ul>
<p>之前就在环境上<code>ps -ef</code>看到过<code>xxxxxx</code>的密码，一直没搞明白怎么回事，今天整理了一下，核心内容均来自于上述连接，作了一些额外的测试和查阅资料。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="运行Mysql实例"><a href="#运行Mysql实例" class="headerlink" title="运行Mysql实例"></a>运行Mysql实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己做的Mysql8的镜像</span></span><br><span class="line">docker run ttbb/mysql:stand-alone</span><br></pre></td></tr></table></figure>

<h3 id="使用密码连接Mysql服务器"><a href="#使用密码连接Mysql服务器" class="headerlink" title="使用密码连接Mysql服务器"></a>使用密码连接Mysql服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u hzj -p Mysql@123 -e <span class="string">&quot;select 1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ps-ef查看"><a href="#ps-ef查看" class="headerlink" title="ps -ef查看"></a>ps -ef查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@91bcbd15a82e mysql]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 07:34 ?        00:00:00 /usr/local/bin/dumb-init bash -vx /opt/sh/mysql/hzj/scripts/start.sh</span><br><span class="line">root         8     1  0 07:34 ?        00:00:00 bash -vx /opt/sh/mysql/hzj/scripts/start.sh</span><br><span class="line">root        17     1  0 07:34 ?        00:00:00 mysqld --daemonize --user=root</span><br><span class="line">root        62     8  0 07:34 ?        00:00:00 tail -f /dev/null</span><br><span class="line">root        63     0  0 07:34 pts/0    00:00:00 bash</span><br><span class="line">root        98    63  0 07:37 pts/0    00:00:00 mysql -h 127.0.0.1 -u hzj -px xxxxxxx</span><br><span class="line">root        99     0  1 07:37 pts/1    00:00:00 bash</span><br><span class="line">root       122    99  0 07:37 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h2 id="Mysql隐藏密码原理"><a href="#Mysql隐藏密码原理" class="headerlink" title="Mysql隐藏密码原理"></a>Mysql隐藏密码原理</h2><p>改写了<code>args</code>系统参数，demo如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 张俭 on 2021/4/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> mypid = getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d and arguments are:\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Replacing first argument with x:es... Now open another terminal and run: ps p %d\n&quot;</span>, (<span class="type">int</span>)mypid);</span><br><span class="line">    <span class="built_in">memset</span>(argv[<span class="number">1</span>], <span class="string">&#x27;x&#x27;</span>, <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    getc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc password_hide.c</span><br><span class="line">[root@c77dc365cd1a sh]# ./a.out abcd</span><br><span class="line">argc = 2 and arguments are:</span><br><span class="line">0 = ./a.out</span><br><span class="line">1 = abcd</span><br><span class="line">Replacing first argument with x:es... Now open another terminal and run: ps p 55</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>观测结果，开始看的确有明文密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@c77dc365cd1a sh]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 07:49 pts/0    00:00:00 bash</span><br><span class="line">root        32     0  0 07:51 pts/1    00:00:00 bash</span><br><span class="line">root        64     1  0 07:56 pts/0    00:00:00 ./a.out abcd</span><br><span class="line">root        66    32  0 07:56 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>
<p>经过30秒后，已经被复写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@c77dc365cd1a sh]# ps p 55</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">   55 pts/0    S+     0:00 ./a.out xxxx</span><br></pre></td></tr></table></figure>
<h2 id="Mysql源码地址"><a href="#Mysql源码地址" class="headerlink" title="Mysql源码地址"></a>Mysql源码地址</h2><p>mysql-server&#x2F;client&#x2F;mysql.cc line 2054</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (argument) &#123;</span><br><span class="line">  char *start = argument;</span><br><span class="line">  my_free(opt_password);</span><br><span class="line">  opt_password = my_strdup(PSI_NOT_INSTRUMENTED, argument, MYF(MY_FAE));</span><br><span class="line">  while (*argument) *argument++ = &#x27;x&#x27;;  // Destroy argument</span><br><span class="line">  if (*start) start[1] = 0;</span><br><span class="line">  tty_password = false;</span><br><span class="line">&#125; else</span><br><span class="line">  tty_password = true;</span><br></pre></td></tr></table></figure>

<p>PS: 后面，我还在OSX上用go程序尝试修改参数，估摸go程序的args传入是值拷贝，修改完成之后args没有生效，看来这个黑科技只有c程序能使用呀。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/20/%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AF%E5%85%AC%E6%9C%89%E4%BA%91%E7%9A%84%E4%BE%9B%E5%BA%94%E5%95%86%EF%BC%8C%E8%83%BD%E6%8F%90%E4%BE%9B%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84Pulsar%E6%9C%8D%E5%8A%A1%E4%BD%93%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pulsar-third-vendor" class="post-title-link post-title-link-external" itemprop="url">如果不是公有云的供应商，能提供什么样的Pulsar服务体验<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-20 20:45:22" itemprop="dateCreated datePublished" datetime="2021-04-20T20:45:22+08:00">2021-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="需要了解的概念"><a href="#需要了解的概念" class="headerlink" title="需要了解的概念"></a>需要了解的概念</h1><ul>
<li>VPC：用户的私有网段</li>
<li>peering：多个VPC之间打通的方式，可跨用户</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天微信推送Pulsar社区有个Hackathon比赛, 开始想的idea就是，实现<code>pulsar</code>在华为云上提供服务。因为是社区的比赛，是以一个三方系统的方式在华为云上提供服务，而非是以华为云的名义提供服务。分析了下可行性和能达到的效果，对比了<code>StreamNative</code>的官网上提供的<code>pulsar</code>服务在阿里云托管的能力，能提供的能力差不多，最多只不过是实现了在华为云托管的能力，没有从0到1的突破。</p>
<p>现在，在公有云上买<code>redis</code>和<code>kafka</code>这类组件已经变得非常普遍，由公有云供应商提供的中间件往往能给你带来良好的体验，相比三方厂家在云上进行托管，我个人认为云厂商的优势主要在以下三点</p>
<h2 id="网络打通容易"><a href="#网络打通容易" class="headerlink" title="网络打通容易"></a>网络打通容易</h2><p>下文说一下不是公有云的供应商能以什么样的方式暴露自己的服务。云厂商可以把中间件的ip地址申请在你的vpc内，对任何应用程序来说，连接都是最方便的。无论是容器化部署、虚拟机部署、和其他vpc peering打通的场景，都可以通信。</p>
<h2 id="低廉的成本"><a href="#低廉的成本" class="headerlink" title="低廉的成本"></a>低廉的成本</h2><p>不考虑人力成本，云厂商自运营的价格要低于三方厂家。</p>
<h2 id="监控系统对接"><a href="#监控系统对接" class="headerlink" title="监控系统对接"></a>监控系统对接</h2><p>方便地和云厂商的告警、统计系统对接，接收告警通知和报表等。</p>
<p>其中<strong>网络打通</strong>和<strong>成本</strong>尤为重要，三方厂家好好做监控统计系统，也能给用户较为良好的体验。</p>
<h1 id="三方厂家能提供什么样的Pulsar接入"><a href="#三方厂家能提供什么样的Pulsar接入" class="headerlink" title="三方厂家能提供什么样的Pulsar接入"></a>三方厂家能提供什么样的Pulsar接入</h1><h2 id="统一接入"><a href="#统一接入" class="headerlink" title="统一接入"></a>统一接入</h2><p>三方厂家自己作为公有云上一个用户，无论这个Region上有多少个租户，都用这一个用户提供服务，这也就意味着无法与每个用户进行私网通信。如果在华为云，利用华为云推出的<strong>VPCEP</strong>服务（此处应有链接），倒是可以给每个用户提供私网通信，不过这个是做了DNAT地址转换的，跟做了DNAT转换的中间件连接，是非常麻烦的。（懂的自然懂。如果有人想详细了解，可以留言，我可以写一个文章介绍里面的坑）</p>
<p>如果使用公网，又想避免扩容的时候动态申请EIP，动态申请EIP并不复杂，问题是EIP是有配额限制的，这才是关键。那么就需要一个统一的接入点，就需要部署pulsar proxy。到这一步，是每个用户申请一个EIP的，如果还想继续节省EIP，那么可以统一域名接入，后端通过SNI的方式转发，个别流量大的客户，单独把域名指向单独的集群。</p>
<p><img src="/Images/pulsar-third-vendor1.png" alt="pulsar-third-vendor1"></p>
<h2 id="Peering打通"><a href="#Peering打通" class="headerlink" title="Peering打通"></a>Peering打通</h2><p>Peering打通可以给用户不错的私网体验，需要用户预留一个网段，网段不需要太大，能容纳pulsar所在的vm就行。采用peering打通一般绝不会选择容器化部署，想要两个容器化的集群互通，对网设的要求很高，暂且忽略Service的存在，这要求用户的vpc网段和pod网段和三方厂商的vpc网段和pod网段都不重叠！而且peering打通，给用户私有，再搭建一个k8s集群，对成本影响比较大。主要有如下两个问题</p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>和客户peering打通，需要较大的权限，如何自动化，最大程度的减少需要的权限。</p>
<h3 id="客户网段和其他网段又做了peering"><a href="#客户网段和其他网段又做了peering" class="headerlink" title="客户网段和其他网段又做了peering"></a>客户网段和其他网段又做了peering</h3><p><img src="/Images/pulsar-third-vendor2.png" alt="pulsar-third-vendor2"></p>
<p>这个问题其实还好，就是路由规则配置麻烦</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Peering打通对用户来说已经比较方便了，相信做到自动化也没有太大的技术难度，只是时间和人力投入的问题。统一接入因为网络打通的原因，不好使用<code>kop</code>、<code>mop</code>这些高级特性，此外还有不小的公网带宽成本，羊毛出在羊身上，比较大量的用户也会倾向于Peering打通的模式吧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/14/%E5%8D%8E%E4%B8%BA%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%9B%E5%B9%B4%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/config-center" class="post-title-link post-title-link-external" itemprop="url">华为云物联网四年配置中心实践<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-14 08:11:47" itemprop="dateCreated datePublished" datetime="2021-04-14T08:11:47+08:00">2021-04-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  自17年入职华为之后，一直在使用配置中心，4年期间经历了自研配置中心到<code>Apollo</code>再到自研配置中心和<code>Apollo</code>并存的场景。总结了一下这几年的配置中心演进流程，想把我们在配置中心上的一些实践分享给大家，实现共同进步。<code>Apollo</code>是一款非常优秀的开源软件，是国人的骄傲。如果对<code>Apollo</code>存在理解错误，还望大家不吝赐教，谢谢。</p>
<h2 id="使用到的配置分类"><a href="#使用到的配置分类" class="headerlink" title="使用到的配置分类"></a>使用到的配置分类</h2><h3 id="从场景分类"><a href="#从场景分类" class="headerlink" title="从场景分类"></a>从场景分类</h3><h4 id="运维配置，即程序只读的配置"><a href="#运维配置，即程序只读的配置" class="headerlink" title="运维配置，即程序只读的配置"></a>运维配置，即程序只读的配置</h4><p>人工配置。通过人工在配置中心界面进行配置，而程序只进行读取，如数据库配置、邮箱服务器配置、网卡配置、子网地址配置等。这部分配置数据不要求代码动态写入。</p>
<h4 id="业务配置，即程序可写的配置"><a href="#业务配置，即程序可写的配置" class="headerlink" title="业务配置，即程序可写的配置"></a>业务配置，即程序可写的配置</h4><p>我们是一个SaaS服务，每个用户在上面都有一些业务配置。如用户的证书配置、用户服务器的流控配置等，这些业务配置相对<strong>运维配置</strong>来说更加复杂，且可能会有唯一性限制，如按用户id唯一。这部分配置数据一般由用户操作触发，代码动态写入，并且通知到各个微服务实例。通常，我们希望这些配置能在界面展示，且支持人为修改。上述逻辑如果由各微服务自己实现，会存在大量重复代码，并且质量无法保证。我们希望由一个公共组件来统一实现这个能力。</p>
<h3 id="从配置是否会有列表可分为单值配置或多值配置"><a href="#从配置是否会有列表可分为单值配置或多值配置" class="headerlink" title="从配置是否会有列表可分为单值配置或多值配置"></a>从配置是否会有列表可分为单值配置或多值配置</h3><h4 id="单值配置"><a href="#单值配置" class="headerlink" title="单值配置"></a>单值配置</h4><p>整个配置下只是多对key、value。value不是很复杂的格式，往往是整数或字符串。</p>
<p><img src="/Images/config-center1.png" alt="image-20210330171658154"></p>
<h4 id="多值配置"><a href="#多值配置" class="headerlink" title="多值配置"></a>多值配置</h4><p>多值配置更加复杂，往往是<strong>单值配置</strong>在不同的key下，有不同的值。比如下面的配置，用户一和用户二的线程池大小和队列不同</p>
<p><img src="/Images/config-center2.jpg" alt="img"></p>
<h2 id="第一阶段-自研配置中心"><a href="#第一阶段-自研配置中心" class="headerlink" title="第一阶段 自研配置中心"></a>第一阶段 自研配置中心</h2><p>在做云服务之前，我们的配置中心层级数较少。我们以软件的形式交付给客户，软件运行时分为管理面和业务面，配置中心管理着管理面和业务面的配置，最为复杂的场景是多套业务面，这个时候需要保证不同集群、不同微服务下的配置不冲突，配置层级为 集群、微服务、配置。</p>
<p><img src="/Images/config-center3.png" alt="image-20210324204231586"></p>
<p>此时的配置中心是完全自研的，不包含蓝绿、灰度配置这些功能，它独具特色的地方有以下两点：</p>
<h3 id="单配置单表"><a href="#单配置单表" class="headerlink" title="单配置单表"></a>单配置单表</h3><ul>
<li>在存储模型上，每个配置对应一张数据表。</li>
<li>对多值配置比较友好，尤其是复杂业务配置，可以支持各种主键约束。对单值配置，稍微重型了一些。</li>
<li>配置的强Schema限制。这些限制包括类型、大小、长度、是否敏感等限制。这种限制既能为界面修改配置提供良好的体验（如：不同格式不同的输入框、敏感字段，前台输入明文，后台入库加密等），也能在通过接口写入配置时做充分的校验。</li>
</ul>
<h3 id="通过回调方式来确保配置的可靠"><a href="#通过回调方式来确保配置的可靠" class="headerlink" title="通过回调方式来确保配置的可靠"></a>通过回调方式来确保配置的可靠</h3><p>举个例子，添加一个配置的流程是这样的</p>
<p><img src="/Images/config-center4.png" alt="image-20210324205828998"></p>
<p>可能这里，有读者想要问了，这个流程能确保什么可靠呢。这个流程通过调用微服务接口来校验配置是否可靠，如IP地址是否合法、对端地址是否可达、配置数量是否超过规格等等，来保证配置基本可用。</p>
<p>总的来说，这个自研的配置中心在当时综合体验还是不错的。但是也有一些问题有待改进，比如单配置下配置项数量过多时，因为底层有部分接口单配置下所有数据都通过一个http请求来承载，会导致响应超时等问题。</p>
<h2 id="第二阶段-Apollo"><a href="#第二阶段-Apollo" class="headerlink" title="第二阶段 Apollo"></a>第二阶段 Apollo</h2><p>开始第二阶段实践的原因主要是，我们进行了组织切换，业务重心转向做云服务，同时团队进行DevOps转型。原先的老配置中心是由另一个团队维护的，组织切换完之后，如果还要使用，就要我们自己维护。所以我们需要在继续维护老配置中心和引入开源<code>Apollo</code>中间进行选择。除了上文中提到的运维配置和业务配置，这个时候我们的需求还有改变：</p>
<ul>
<li>配置的层级愈发丰富了</li>
<li>要构建灰度发布微服务的能力</li>
</ul>
<p>老配置中心一方面由于组织切换原因不提供维护了，另一方面不能支撑丰富的配置层级，也不具备灰度发布的能力。这个时候，<code>Apollo</code>的一些特性吸引了我们，这些特性正是老配置中心所缺乏的，例如（部分引用自<code>Apollo</code>github主页）</p>
<ul>
<li>丰富的层级，从<code>app_id</code>到<code>cluster</code>,<code>namespace</code>,<code>key-value</code>的层级能满足我们region、集群、微服务的层级诉求</li>
<li>支持配置的灰度发布，比如点了发布后，只对部分应用实例生效，等观察一段时间没问题后再推给所有应用实例。</li>
<li>所有的配置发布都有版本概念，从而可以方便的支持配置的回滚。</li>
<li>应用和配置的管理都有完善的权限管理机制，对配置的管理还分为了编辑和发布两个环节，从而减少人为的错误。</li>
<li>所有的操作都有审计日志，可以方便的追踪问题。</li>
</ul>
<p>因此我们选型引入了<code>Apollo</code>，我和我的主管，还有一个其他同事参与了这项工作。我们在Apollo开源代码的基础上做了比较大的改动，主要原因有以下几点</p>
<ul>
<li>节约成本，将注册中心、数据库替换成我们当前正在使用的组件，因为这两个依赖不是<code>Apollo</code>的核心依赖</li>
<li>继承老配置中心强<code>Schema</code>的优点。</li>
<li>保留回调确认配置的流程，提前拦截错误的配置，降低代码处理异常配置的复杂度</li>
<li>通过spi或环境变量的方式兼容存量老局点使用老配置中心的场景</li>
</ul>
<p>结合上述原因，我们最终是这么实践的</p>
<ul>
<li><p>数据库切换为<code>postgre</code>数据库、注册中心切换到<code>servicecomb</code></p>
</li>
<li><p>在namespace上实现了<code>Schema</code>，每个namespace都可以注册对应的<code>Schema</code>，<code>Schema</code>要求数据必须是json格式，且json内对应的value必须满足Schema定义的规范（如ip地址、小数、整数等）</p>
<p>Schema举例</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;string&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;age&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;int&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max&quot;</span><span class="punctuation">:</span><span class="number">120</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;ip&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;ipv4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p> 那么数据应该是这样的</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;hezhangjian&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span><span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在添加或修改配置的时候，实现了回调功能，由回调业务服务确认配置能否添加或修改</li>
<li>配置分层：云服务对应<code>Apollo</code>的<code>app_id</code>，把内部的环境对应到<code>Apollo</code>上的集群，然后将微服务名+配置名拼接成配置名称。</li>
</ul>
<p>下图展示了业务概念和<code>Apollo</code>概念的对应关系，有些配置是单值配置，有些是多值配置，所以配置项这一层级是可选的。</p>
<p><img src="/Images/config-center5.png" alt="配置分层示意图"></p>
<p>在这段时间的实践中，我们也发现如下问题</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>其中最致命的就是并发问题，首先<code>Apollo</code>所有配置都存在一张表中，其次由于<code>Apollo</code>设计之初主要考虑的是运维人员手动在界面上操作，代码无并发语义（或者说没给客户端并发语义），使得我们通过代码写入配置时难以解决并发问题。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>打开<code>namespace</code>列表页面，需要显示这个<code>app_id</code>下的所有<code>namespace</code>,因为我们单<code>app_id</code>会存放单个云服务的所有配置，这个量很大，且界面不支持分页，导致页面加载缓慢</p>
<h3 id="体验问题"><a href="#体验问题" class="headerlink" title="体验问题"></a>体验问题</h3><p><code>Apollo</code>的<code>namespace</code>界面未提供搜索功能（可能Apollo设计之初也没想支持这么多），想要从<code>namespace</code>中定位到我们想要查看或修改的namespace，只能借助浏览器的搜索能力。</p>
<h2 id="第三阶段-Apollo与自研配置中心并存"><a href="#第三阶段-Apollo与自研配置中心并存" class="headerlink" title="第三阶段 Apollo与自研配置中心并存"></a>第三阶段 Apollo与自研配置中心并存</h2><p>除了上述几个问题，还有一些原因使得我们开始了第三阶段的实践</p>
<ul>
<li>原来自上而下的配置分层模型，微服务间配置没隔离，不仅不易进行权限管理，而且不适合<code>DevOps</code> 单微服务自治的发布理念。</li>
<li>第二阶段对<code>Apollo</code>改动太多，组织结构变动，没有足够的人力维护</li>
<li>随着集群越来越多，回调功能需要网络的双向打通，网络维护不太方便</li>
<li>我们对<code>Apollo</code>界面以及接口基于业务做的改动较多，导致其他兄弟部门难以共用<code>Apollo</code></li>
</ul>
<p>当时大家对是否保留<strong>Schema</strong>、<strong>回调检查</strong>、<strong>代码写配置</strong>这三个功能点有较大的争议。我个人最希望保留<strong>Schema</strong>、<strong>回调检查</strong>，因为它们优点显著，而且接口是兼容的，可以与其他部门共用，但是增加了<strong>Schema</strong>这个概念和<strong>回调检查</strong>这个流程，会增加学习成本。而代码写配置，由于要解决并发问题，代码改动量较大，我不建议保留。</p>
<p>大家经过激烈的讨论，最终还是废弃了<strong>Schema</strong>、<strong>回调检查</strong>、<strong>代码写配置</strong>这三个功能点，仅仅把运维配置放在<code>Apollo</code>。</p>
<p>然后，我们把业务配置，放在了一个自研的强Schema的配置中心上，这个配置中心，仅负责单集群的配置，每个集群部署一套，满足了我们的业务需求。自研强Schema配置中心的核心要点有，单配置单表、通过注册中心回调来检测配置是否合法、借助mqtt协议来实现长链接推送，无单点瓶颈。</p>
<p>而我们的运维配置中心<code>Apollo</code>回归到了开源的版本，重整了配置的结构，</p>
<p><img src="/Images/config-center6.png" alt="image-20210405224010878"></p>
<p>对运维配置而言好处有</p>
<ul>
<li>配置模型适合单微服务发布</li>
<li>配置按微服务组织，一个页面上的namespace不会很多</li>
</ul>
<p>缺点</p>
<ul>
<li>Schema缺失后，不会对操作人员在界面的配置进行校验，即使配置格式或者内容错误也能配置成功。界面上配置密码不支持明文（Apollo无法感知是否为敏感字段），必须提前使用其他工具将明文转换为密文，然后再进行配置。</li>
<li>回调检查功能去掉后，有些配置，如网卡网段配错，操作人员不能即时得到响应</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>业务配置经过我们的实践，确实不适合使用开源的<code>Apollo</code>。运维配置使用原生的<code>Apollo</code>，但是现在还不具备<strong>回调检查</strong>和<strong>Schema</strong>的功能，希望<code>Apollo</code>能在后续版本中支持<strong>Schema</strong>，或者弱化的<strong>json</strong>格式检查功能。下面是我们在如下场景下的最佳实践</p>
<h3 id="SRE在界面上的运维配置"><a href="#SRE在界面上的运维配置" class="headerlink" title="SRE在界面上的运维配置"></a>SRE在界面上的运维配置</h3><p>通过<code>Apollo</code>来实现功能，至于配置如何组织，根据大家的组织结构、技术架构来对应<code>Apollo</code>上的概念，可按照<code>微服务-&gt;部署环境</code>或<code>部署环境 -&gt; 微服务</code>的层级来组织配置</p>
<h3 id="复杂的参数校验"><a href="#复杂的参数校验" class="headerlink" title="复杂的参数校验"></a>复杂的参数校验</h3><p>建议在<code>Apollo</code>上面自建portal包裹一层，后端服务可先进行一层处理，这一层处理可以做比较复杂的格式化校验甚至<strong>回调检查</strong>，再调用<code>Apollo OpenApi</code>将配置写入<code>Apollo</code>。</p>
<h3 id="业务配置的技术选型"><a href="#业务配置的技术选型" class="headerlink" title="业务配置的技术选型"></a>业务配置的技术选型</h3><p>最大的挑战是业务配置由用户触发，请求的并发不易处理。思路有两个，一个是在<code>Apollo</code>原生代码的基础上，通过数据库分布式锁来解决并发问题。第二个是借鉴我们的思路，通过单配置单表、mqtt协议实现通知等核心技术点，自研业务配置中心。</p>
<h3 id="业务配置的部署"><a href="#业务配置的部署" class="headerlink" title="业务配置的部署"></a>业务配置的部署</h3><p>需要根据业务配置的数量来考虑是否合设业务配置中心。单集群场景下，毫无疑问只需要一个业务配置中心，甚至如果使用<code>Apollo</code>实现，可以考虑和运维配置中心合设。多集群场景下，部署一个业务配置中心，还是多个业务配置中心，我们自己的实践中，一个集群往往要支撑数万用户，我们采取了每个业务集群部署一套业务配置中心的策略。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/13/Kubernetes%20pod%E5%86%85%E8%B0%83%E7%94%A8API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/kubernetes-pod-api" class="post-title-link post-title-link-external" itemprop="url">Kubernetes pod内调用API<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-13 21:17:20" itemprop="dateCreated datePublished" datetime="2021-04-13T21:17:20+08:00">2021-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Kubernetes pod内调用API的流程总体分为以下步骤</p>
<ul>
<li>创建role</li>
<li>创建serviceaccount</li>
<li>绑定role到serviceaccount</li>
<li>指定pod使用serviceaccount</li>
</ul>
<p>我们以查pod为例，演示一下整个流程</p>
<h2 id="创建role"><a href="#创建role" class="headerlink" title="创建role"></a>创建role</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># role.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-hzj</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f role.yaml</span><br></pre></td></tr></table></figure>

<h2 id="创建serviceaccount"><a href="#创建serviceaccount" class="headerlink" title="创建serviceaccount"></a>创建serviceaccount</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># serviceaccount.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceaccount-hzj</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f serviceaccount.yaml</span><br></pre></td></tr></table></figure>

<h2 id="绑定role"><a href="#绑定role" class="headerlink" title="绑定role"></a>绑定role</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rolebinding.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">rolebinding-hzj</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">serviceaccount-hzj</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-hzj</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f rolebinding.yaml</span><br></pre></td></tr></table></figure>

<h2 id="部署pod进行测试"><a href="#部署pod进行测试" class="headerlink" title="部署pod进行测试"></a>部署pod进行测试</h2><h3 id="部署一个zookeeper进行测试"><a href="#部署一个zookeeper进行测试" class="headerlink" title="部署一个zookeeper进行测试"></a>部署一个zookeeper进行测试</h3><p>手上刚好有zookeeper的模板文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zookeeper</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ttbb/zookeeper:stand-alone</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2G</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2G</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PS1</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&#x27;[\u@zookeeper@\W]\$ &#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Point to the internal API server hostname</span></span><br><span class="line">APISERVER=https://kubernetes.default.svc</span><br><span class="line"><span class="comment"># Path to ServiceAccount token</span></span><br><span class="line">SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line"><span class="comment"># Read this Pod&#x27;s namespace</span></span><br><span class="line">NAMESPACE=$(<span class="built_in">cat</span> <span class="variable">$&#123;SERVICEACCOUNT&#125;</span>/namespace)</span><br><span class="line"><span class="comment"># Read the ServiceAccount bearer token</span></span><br><span class="line">TOKEN=$(<span class="built_in">cat</span> <span class="variable">$&#123;SERVICEACCOUNT&#125;</span>/token)</span><br><span class="line"><span class="comment"># Reference the internal certificate authority (CA)</span></span><br><span class="line">CACERT=<span class="variable">$&#123;SERVICEACCOUNT&#125;</span>/ca.crt</span><br><span class="line"><span class="comment"># Explore the API with TOKEN</span></span><br><span class="line">curl --cacert <span class="variable">$&#123;CACERT&#125;</span> --header <span class="string">&quot;Authorization: Bearer <span class="variable">$&#123;TOKEN&#125;</span>&quot;</span> -X GET <span class="variable">$&#123;APISERVER&#125;</span>/api</span><br><span class="line">curl --cacert <span class="variable">$&#123;CACERT&#125;</span> --header <span class="string">&quot;Authorization: Bearer <span class="variable">$&#123;TOKEN&#125;</span>&quot;</span> -X GET <span class="variable">$&#123;APISERVER&#125;</span>/api/v1/namespaces/default/pods</span><br></pre></td></tr></table></figure>

<p><img src="/Images/kubernetes-pod-api1.png" alt="kubernetes-pod-api1"></p>
<p>发现这里，调用后面的api，403错误。第一个api不报错，是因为该接口不需要鉴权。</p>
<h3 id="修改pod对应的serviceaccount"><a href="#修改pod对应的serviceaccount" class="headerlink" title="修改pod对应的serviceaccount"></a>修改pod对应的serviceaccount</h3><p>让我们修改部署模板对应的ServiceAccountName，注入权限。在pod的spec下，设置serviceAccountName</p>
<p><img src="/Images/kubernetes-pod-api2.png" alt="kubernetes-pod-api2"></p>
<h3 id="修改部署模板重启后调用api正常"><a href="#修改部署模板重启后调用api正常" class="headerlink" title="修改部署模板重启后调用api正常"></a>修改部署模板重启后调用api正常</h3><p>再次尝试上述命令，api结果返回正常</p>
<p><img src="/Images/kubernetes-pod-api3.png" alt="kubernetes-pod-api3"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/13/UCloud%E6%90%AD%E5%BB%BAkubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/13/UCloud%E6%90%AD%E5%BB%BAkubernetes/" class="post-title-link" itemprop="url">UCloud搭建kubernetes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-13 20:41:56" itemprop="dateCreated datePublished" datetime="2021-04-13T20:41:56+08:00">2021-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近因为业务的需求，在学习etcd，想了解一下<code>kubernetes</code>是如何使用etcd集群的，不如动手搭建一个<code>kubernetes</code>集群，也顺手体验一下友商UCloud。后面有时间仔细分析一下kubeadm搭建的时候都做了哪些事情</p>
<p>选择香港Region进行搭建，下载国外的镜像比较方便。</p>
<h2 id="购买三台ECS"><a href="#购买三台ECS" class="headerlink" title="购买三台ECS"></a>购买三台ECS</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>三台4U16G，基础镜像选择Centos8版本</p>
<h2 id="ApiServer创建ELB"><a href="#ApiServer创建ELB" class="headerlink" title="ApiServer创建ELB"></a>ApiServer创建ELB</h2><h3 id="创建LB实例"><a href="#创建LB实例" class="headerlink" title="创建LB实例"></a>创建LB实例</h3><p><img src="/Images/ucloud-kubernetes1.png" alt="image-20210413104514588"></p>
<h3 id="添加一个6443端口的Vserver"><a href="#添加一个6443端口的Vserver" class="headerlink" title="添加一个6443端口的Vserver"></a>添加一个6443端口的Vserver</h3><p><img src="/Images/ucloud-kubernetes2.png" alt="image-20210413104700767"></p>
<p>这里Vserver和LVS上的Virtual Service的概念相同。</p>
<h3 id="向6443端口添加Rs"><a href="#向6443端口添加Rs" class="headerlink" title="向6443端口添加Rs"></a>向6443端口添加Rs</h3><p>把三台虚拟机的6643端口都添加到负载均衡上</p>
<p>现在6443端口显示异常不要紧，后面安装过程中，各个节点的6443端口才会逐渐可用，让各个节点访问。</p>
<h2 id="初始化Master集群"><a href="#初始化Master集群" class="headerlink" title="初始化Master集群"></a>初始化Master集群</h2><h3 id="虚拟机上安装必须组件"><a href="#虚拟机上安装必须组件" class="headerlink" title="虚拟机上安装必须组件"></a>虚拟机上安装必须组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum remove -y runc</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kubelet kubeadm kubectl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set SELinux in permissive mode (effectively disabling it)</span></span><br><span class="line"><span class="built_in">sudo</span> setenforce 0</span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line">kubeadm config images pull</span><br></pre></td></tr></table></figure>

<h3 id="初始化master-001节点"><a href="#初始化master-001节点" class="headerlink" title="初始化master-001节点"></a>初始化master-001节点</h3><p>这里这个IP地址填负载均衡的地址，这样子才能搭建出高可用集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --control-plane-endpoint &quot;10.7.157.12:6443&quot; --upload-certs</span><br></pre></td></tr></table></figure>

<p>初始化成功，返回以下提示信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of the control-plane node running the following command on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 10.7.157.12:6443 --token bj4vpt.o999hbp96p1bvw5q \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:8560fa9211dbfdb55609d22ef0f0b428c6cb73b6e85a70c7a9e13d88b0b8400c \</span><br><span class="line">	--control-plane --certificate-key 85c86678b3d54b6017ac3fab2f2a92337f332c7172dfaf4b5a18ee1da679cd7d</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use</span><br><span class="line">&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.7.157.12:6443 --token bj4vpt.o999hbp96p1bvw5q \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:8560fa9211dbfdb55609d22ef0f0b428c6cb73b6e85a70c7a9e13d88b0b8400c</span><br></pre></td></tr></table></figure>

<p>其他节点上执行kubeadm join</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 10.7.157.12:6443 --token bj4vpt.o999hbp96p1bvw5q \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:8560fa9211dbfdb55609d22ef0f0b428c6cb73b6e85a70c7a9e13d88b0b8400c \</span><br><span class="line">--control-plane --certificate-key 85c86678b3d54b6017ac3fab2f2a92337f332c7172dfaf4b5a18ee1da679cd7d</span><br></pre></td></tr></table></figure>

<p>调整kubectl命令行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">	sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">	sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
<h3 id="安装cni插件"><a href="#安装cni插件" class="headerlink" title="安装cni插件"></a>安装cni插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="string">&quot;https://cloud.weave.works/k8s/net?k8s-version=<span class="subst">$(kubectl version | base64 | tr -d &#x27;\n&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>至此，kubernetes搭建完成。</p>
<p><img src="/Images/ucloud-kubernetes3.png" alt="image-20210413162451762"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/10/Apache%20ZooKeeper%E5%9C%A8%E5%8D%8E%E4%B8%BA%E4%BA%91IoT%E6%9C%8D%E5%8A%A1%E4%BA%A7%E5%93%81%E9%83%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zookeeper-huaweicloud-usage" class="post-title-link post-title-link-external" itemprop="url">Apache ZooKeeper在华为云IoT服务产品部的使用<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-10 19:25:22" itemprop="dateCreated datePublished" datetime="2021-04-10T19:25:22+08:00">2021-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>华为云IoT服务产品部致力于提供极简接入、智能化、安全可信等全栈全场景服务和开发、集成、托管、运营等一站式工具服务，助力合作伙伴&#x2F;客户轻松、快速地构建5G、AI万物互联的场景化物联网解决方案。</p>
<p>架构方面，华为云IoT服务产品部采用云原生微服务架构，ZooKeeper组件在华为云IoT服务产品部的架构中扮演着重要的角色，本文将介绍华为云IoT服务产品部在ZooKeeper的使用。</p>
<h2 id="Apache-ZooKeeper-简介"><a href="#Apache-ZooKeeper-简介" class="headerlink" title="Apache ZooKeeper 简介"></a>Apache ZooKeeper 简介</h2><p>Apache ZooKeeper是一个分布式、开源的分布式协调服务，由Apache Hadoop的子项目发展而来。作为一个分布式原语的基石服务，几乎所有分布式功能都可以借助ZooKeeper来实现，例如：应用的主备选举，分布式锁，分布式任务分配，缓存通知，甚至是消息队列、配置中心等。</p>
<p>抛开应用场景，讨论某个组件是否适合，并没有绝对正确的答案。尽管Apache ZooKeeper作为消息队列、配置中心时，性能不用想就知道很差。但是，倘若系统里面只有ZooKeeper，应用场景性能要求又不高，那使用ZooKeeper不失为一个好的选择。但ZooKeeper 客户端的编码难度较高，对开发人员的技术水平要求较高，尽量使用一些成熟开源的ZooKeeper客户端、框架，如：Curator、Spring Cloud ZooKeeper等。</p>
<h2 id="Apache-ZooKeeper-核心概念"><a href="#Apache-ZooKeeper-核心概念" class="headerlink" title="Apache ZooKeeper 核心概念"></a>Apache ZooKeeper 核心概念</h2><h3 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h3><p>ZNode是ZooKeeper的数据节点，ZooKeeper的数据模型是树形结构，每个ZNode都可以存储数据，同时可以有多个子节点，每个ZNode都有一个路径标识，类似于文件系统的路径，例如：&#x2F;iot-service&#x2F;iot-device&#x2F;iot-device-1。</p>
<h1 id="Apache-ZooKeeper在华为云IoT服务产品部的使用"><a href="#Apache-ZooKeeper在华为云IoT服务产品部的使用" class="headerlink" title="Apache ZooKeeper在华为云IoT服务产品部的使用"></a>Apache ZooKeeper在华为云IoT服务产品部的使用</h1><p><img src="/Images/zookeeper-huaweicloud-usage.png" alt="zookeeper-huaweicloud-usage"></p>
<h2 id="支撑系统内关键组件"><a href="#支撑系统内关键组件" class="headerlink" title="支撑系统内关键组件"></a>支撑系统内关键组件</h2><p>很多开源组件都依赖ZooKeeper，如<code>Flink</code>、<code>Ignite</code>、<code>Pulsar</code>等，通过自建和优化ZooKeeper环境，我们能够为这些高级组件提供更加可靠和高效的服务支持，确保服务的平稳运行。</p>
<h2 id="严格分布式锁"><a href="#严格分布式锁" class="headerlink" title="严格分布式锁"></a>严格分布式锁</h2><p>分布式锁是非常常见的需求，相比集群Redis、主备Mysql等，ZooKeeper更容易实现理论上的严格分布式锁。</p>
<h2 id="分布式缓存通知"><a href="#分布式缓存通知" class="headerlink" title="分布式缓存通知"></a>分布式缓存通知</h2><p>ZooKeeper的分布式缓存通知能够帮助我们实现分布式缓存的一致性，例如：我们可以在ZooKeeper上注册一个节点，然后在其他节点上监听这个节点，当这个节点发生变化时，其他节点就能够收到通知，然后更新本地缓存。</p>
<p>这种方式的缺点是，ZooKeeper的性能不高，不适合频繁变更的场景，但是，对于一些不经常变更的配置，这种方式是非常适合的。如果系统中存在消息队列，那么可以使用消息队列来实现分布式缓存通知，这种方式的性能会更好、扩展性更强。</p>
<h2 id="分布式Id生成器"><a href="#分布式Id生成器" class="headerlink" title="分布式Id生成器"></a>分布式Id生成器</h2><h3 id="直接使用ZooKeeper的有序节点"><a href="#直接使用ZooKeeper的有序节点" class="headerlink" title="直接使用ZooKeeper的有序节点"></a>直接使用ZooKeeper的有序节点</h3><p>应用程序可以直接使用ZooKeeper的有序节点来生成分布式Id，但是，这种方式的缺点是，ZooKeeper的性能不高，不适合频繁生成的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDirectIdGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/zk-direct-id&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PATH_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;/id-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDirectIdGenerator</span><span class="params">(String connectionString, <span class="type">int</span> sessionTimeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectionString, sessionTimeout, event -&gt; &#123;&#125;);</span><br><span class="line">        initializePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initializePath</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zooKeeper.exists(path, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="literal">null</span>) &#123;</span><br><span class="line">            zooKeeper.create(path, <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullPath</span> <span class="operator">=</span> zooKeeper.create(path + PATH_PREFIX, <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">            <span class="keyword">return</span> Optional.of(extractId(fullPath));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;create znode failed, exception is &quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">extractId</span><span class="params">(String fullPath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fullPath.substring(fullPath.lastIndexOf(PATH_PREFIX) + PATH_PREFIX.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用ZooKeeper生成机器号"><a href="#使用ZooKeeper生成机器号" class="headerlink" title="使用ZooKeeper生成机器号"></a>使用ZooKeeper生成机器号</h3><p>应用程序可以使用ZooKeeper生成机器号，然后使用机器号+时间戳+序列号来生成分布式Id。来解决ZooKeeper有序节点性能不高的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkIdGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/zk-id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; machinePrefix = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] AUX_ARRAY = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;00&quot;</span>, <span class="string">&quot;000&quot;</span>, <span class="string">&quot;0000&quot;</span>, <span class="string">&quot;00000&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过zk获取不一样的机器号，机器号取有序节点最后三位</span></span><br><span class="line"><span class="comment">     * id格式：</span></span><br><span class="line"><span class="comment">     * 机器号 + 日期 + 小时 + 分钟 + 秒 + 5位递增号码</span></span><br><span class="line"><span class="comment">     * 一秒可分近10w个id</span></span><br><span class="line"><span class="comment">     * 需要对齐可以在每一位补零</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">genId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (machinePrefix.get().isEmpty()) &#123;</span><br><span class="line">            acquireMachinePrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machinePrefix.get().isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// get id failed</span></span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">aux</span> <span class="operator">=</span> atomicInteger.getAndAccumulate(<span class="number">1</span>, ((left, right) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> left + right;</span><br><span class="line">            <span class="keyword">return</span> val &gt; <span class="number">99999</span> ? <span class="number">1</span> : val;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> conv2Str(now.getDayOfYear(), <span class="number">3</span>) + conv2Str(now.getHour(), <span class="number">2</span>) + conv2Str(now.getMinute(), <span class="number">2</span>) + conv2Str(now.getSecond(), <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> conv2Str(aux, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> Optional.of(machinePrefix.get() + time + suffix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">acquireMachinePrefix</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!machinePrefix.get().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(ZooKeeperConstant.SERVERS, <span class="number">30_000</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> zooKeeper.create(path, <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">            <span class="keyword">if</span> (s.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                machinePrefix.compareAndSet(<span class="string">&quot;&quot;</span>, s.substring(s.length() - <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;connect to zookeeper failed, exception is &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">conv2Str</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;length should be less than 5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(value);</span><br><span class="line">        <span class="keyword">return</span> AUX_ARRAY[length - str.length()] + str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="微服务注册中心"><a href="#微服务注册中心" class="headerlink" title="微服务注册中心"></a>微服务注册中心</h2><p>相比其他微服务引擎，如阿里云的<code>MSE</code>、<code>Nacos</code>等，已有的Zookeeper集群作为微服务的注册中心，既能满足微服务数量较少时的功能需求，并且更加节约成本</p>
<h2 id="数据库连接均衡"><a href="#数据库连接均衡" class="headerlink" title="数据库连接均衡"></a>数据库连接均衡</h2><p>在此前的架构中，我们采用了一种随机策略来分配微服务与数据库的连接地址。下图展示了这种随机分配可能导致的场景。考虑两个微服务：微服务B和微服务C。尽管微服务C的实例较多，但其对数据库的操作相对较少。相比之下，微服务B在运行期间对数据库的操作更为频繁。这种连接方式可能导致数据库Data2节点的连接数和CPU使用率持续居高，从而成为系统的瓶颈。</p>
<p><img src="/Images/zookeeper-database-before.png" alt="zookeeper-database-before.png"></p>
<p>启发于<strong>Kafka</strong>中的<code>partition</code>分配算法，我们提出了一种新的连接策略。例如，如果微服务B1连接到了Data1和Data2节点，那么微服务B2将连接到Data3和Data4节点。如果存在B3实例，它将再次连接到Data1和Data2节点。对于微服务C1，其连接将从Data1和Data2节点开始。然而，由于微服务的数量与数据库实例数量的两倍（每个微服务建立两个连接）并非总是能整除，这可能导致Data1和Data2节点的负载不均衡。</p>
<p>为了解决这一问题，我们进一步优化了策略：第一个微服务实例在选择数据库节点时，将从一个随机起点开始。这种方法旨在确保Data1和Data2节点的负载均衡。具体的分配策略如下图所示。</p>
<p><img src="/Images/zookeeper-database-after.png" alt="zookeeper-database-after.png"></p>
<h1 id="Apache-ZooKeeper在华为云IoT产品部的部署-运维"><a href="#Apache-ZooKeeper在华为云IoT产品部的部署-运维" class="headerlink" title="Apache ZooKeeper在华为云IoT产品部的部署&#x2F;运维"></a>Apache ZooKeeper在华为云IoT产品部的部署&#x2F;运维</h1><h2 id="服务端部署方式"><a href="#服务端部署方式" class="headerlink" title="服务端部署方式"></a>服务端部署方式</h2><p>我们所有微服务和中间件均采用容器化部署，选择3节点（没有learner）规格。使用<strong>statefulset</strong>和<strong>PVC</strong>的模式部署。为什么使用<strong>statefulset</strong>进行部署？<strong>statefulset</strong>非常适合用于像<code>Zookeeper</code>这样有持久化存储需求的服务，每个Pod可以和对应的存储资源绑定，保证数据的持久化，同时也简化了部署，如果想使用<strong>deploy</strong>的部署模式，需要规划、固定每个pod的虚拟机部署。</p>
<p><code>Zookeeper</code>本身对云硬盘的要求并不高，普通IO，几十G存储就已经能够支撑<code>Zookeeper</code>平稳运行了。<code>Zookeeper</code>本身运行的资源，使用量不是很大，在我们的场景，规格主要取决于Pulsar的topic数量，如果<code>Pulsar</code>的topic不多，那么0.5核、2G内存已经能保证<code>Zookeeper</code>平稳运行了。</p>
<h2 id="客户端连接方式"><a href="#客户端连接方式" class="headerlink" title="客户端连接方式"></a>客户端连接方式</h2><p>借助coredns，客户端使用域名的方式连接<code>Zookeeper</code>，这样可以避免<code>Zookeeper</code>的IP地址变更导致客户端连接失败的问题，如zookeeper-0.zookeeper:2181,zookeeper-1.zookeeper:2181,zookeeper-2.zookeeper:2181</p>
<h2 id="重要监控指标"><a href="#重要监控指标" class="headerlink" title="重要监控指标"></a>重要监控指标</h2><ul>
<li><p>readlantency、updatelantency</p>
<p>zk的读写延迟</p>
</li>
<li><p>approximate_data_size</p>
<p>zk中数据的平均大小估计</p>
</li>
<li><p>outstanding_requests</p>
<p>等待<code>Zookeeper</code>处理的请求数</p>
</li>
<li><p>znode_count</p>
<p><code>Zookeeper</code>当前的<code>znode</code>总数</p>
</li>
<li><p>num_alive_connections</p>
<p><code>Zookeeper</code>当前活跃的连接数</p>
</li>
</ul>
<h1 id="Apache-ZooKeeper在华为云IoT产品部的问题"><a href="#Apache-ZooKeeper在华为云IoT产品部的问题" class="headerlink" title="Apache ZooKeeper在华为云IoT产品部的问题"></a>Apache ZooKeeper在华为云IoT产品部的问题</h1><h2 id="readiness合理设置"><a href="#readiness合理设置" class="headerlink" title="readiness合理设置"></a>readiness合理设置</h2><p>这是碰到的最有趣的问题，<strong>readiness</strong>接口是<strong>k8s</strong>判断pod是否正常的依据，那么对于<strong>Zookeeper</strong>集群来说，最合理的就是，当这个<strong>Zookeeper</strong>节点加入集群，获得了属于自己的<strong>Leader</strong>或<strong>Follower</strong>状态，就算pod正常。可是，当初次部署的时候，只有一个节点可用，该节点一个实例无法完成选举流程，导致无法部署。</p>
<p>综上，我们把<strong>readiness</strong>的策略修改为：</p>
<p><img src="/Images/zookeeper-readiness-strategy.png" alt="zookeeper-readiness-strategy.png"></p>
<p>PS：为了让<strong>readiness</strong>检查不通过时，<strong>Zookeeper</strong>集群也能选主成功，需要配置<strong>publishNotReadyAddresses</strong>为true，示例如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">publishNotReadyAddresses:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">2888</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">peer</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">3888</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">leader</span></span><br></pre></td></tr></table></figure>

<h2 id="jute-maxbuffer超过上限"><a href="#jute-maxbuffer超过上限" class="headerlink" title="jute.maxbuffer超过上限"></a>jute.maxbuffer超过上限</h2><p>jute.maxbuffer，这个是znode中存储数据大小的上限，在客户端和服务端都需要配置，根据自己在znode上存储的数据合理配置</p>
<h2 id="zookeeper的Prometheus全0监听"><a href="#zookeeper的Prometheus全0监听" class="headerlink" title="zookeeper的Prometheus全0监听"></a>zookeeper的Prometheus全0监听</h2><p>不满足网络监听最小可见原则。修改策略，添加一个可配置参数来配置监听的IP <code>metricsProvider.httpHost</code>，PR已合入，见 <a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper/pull/1574/files">https://github.com/apache/zookeeper/pull/1574/files</a></p>
<h2 id="客户端版本号过低，域名无法及时刷新"><a href="#客户端版本号过低，域名无法及时刷新" class="headerlink" title="客户端版本号过低，域名无法及时刷新"></a>客户端版本号过低，域名无法及时刷新</h2><p>客户端使用域名进行连接，但在客户端版本号过低的情况下，客户端并不会刷新新的ip，还是会用旧的ip尝试连接。升级客户端版本号到curator-4.3.0以上、zookeeper-3.6.2以上版本后解决。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了华为云IoT服务产品部如何使用Apache ZooKeeper来优化其云原生微服务架构。ZooKeeper作为分布式协调服务，在华为云IoT服务中发挥了重要作用，用于主备选举、分布式锁、任务分配和缓存通知等。文中还讨论了ZooKeeper在分布式ID生成、微服务注册中心、数据库连接均衡等方面的应用。此外，文章还覆盖了ZooKeeper在华为云IoT产品部的部署、运维策略和所遇到的挑战，包括容器化部署、监控指标和配置问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhangjian He</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
