<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hezhangjian.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"normal"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="张俭的博客">
<meta property="og:url" content="https://hezhangjian.com/page/11/index.html">
<meta property="og:site_name" content="张俭的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhangjian He">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hezhangjian.com/page/11/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>张俭的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">张俭的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangjian He</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hezhangjian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/hezhangjian" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/04/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E6%A3%80%E8%A7%86%E4%B9%8BSocket%20flush%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E6%A3%80%E8%A7%86%E4%B9%8BSocket%20flush%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">记一次代码检视之Socket flush的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-02 12:24:09" itemprop="dateCreated datePublished" datetime="2021-04-02T12:24:09+08:00">2021-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记一次代码检视中领悟到的知识，和大家一起交流</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>提交上来的代码大概是这个样子的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, port);</span><br><span class="line"><span class="keyword">final</span> <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">dataOutputStream.write(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line">dataOutputStream.flush();</span><br></pre></td></tr></table></figure>

<p>这次主要是添加<code>shutdownOutput</code>的调用，及时关闭tcp会话，防止TW过多。</p>
<p>经过大家的讨论，主要的矛盾点在<code>shutdownOutput</code>和<code>flush</code>的顺序。首先想到的是 flush方法放在了output后面，这样还能起作用吗？但是提交代码之前是经过测试的，这样子是可以正常工作的。然后的想法就是，傻逼了，想错了，shutdown应该自带flush效果，os都发fin了，之前的buffer肯定出去了。</p>
<p>我做个实验，来探究下是不是这样子的，我从python开启了一个http server来开启实验</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure>

<p>java测试类代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.hezhangjian.demo.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hezhangjian</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSocketSend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSocketSend</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, port);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        dataOutputStream.write(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        dataOutputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随后我在25行和26行打了断点</p>
<p>当运行到25行的时候，python server并没有收到数据</p>
<p><img src="/Images/code-socket-flush1.png" alt="image-20210402121759024"></p>
<p>还没运行26行的时候，数据就已经发送到python服务器了</p>
<p><img src="/Images/code-socket-flush2.png" alt="image-20210402121818000"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个时候证明我们的推测是正确的，<code>shutdownOutput</code>方法自带了<code>flush</code>效果。<br>我也尝试了配置<code>tcpNoDeplay</code>参数，配不配置tcpNoDelay，都是一样的效果。看起来jvm都有缓冲<br>那么已经调用了<code>shutdownOutput</code>方法之后，<code>flush</code>方法还有没有必要调用呢，从<code>clean code</code>的角度，<code>flush</code>方法的调用已经是没有任何必要的了，建议删除。一般场景下可能不会有问题，但是如果极端场景，比如在25行到26行之间，程序陷入了长gc，这行就有可能抛出IOException，影响原来的逻辑。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/22/%E4%BC%98%E9%9B%85%E5%90%AF%E5%81%9CVS%E9%87%8D%E8%AF%95%EF%BC%8C%E8%B0%81%E8%83%BD%E6%9B%B4%E5%A5%BD%E5%9C%B0%E4%BF%9D%E8%AF%81RPC%E6%97%A0%E6%8D%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/rpc-lossless" class="post-title-link post-title-link-external" itemprop="url">优雅启停VS重试，谁能更好地保证RPC无损<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-22 18:57:18" itemprop="dateCreated datePublished" datetime="2021-03-22T18:57:18+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们的业务有些时候总是在升级期间<code>rpc</code>业务有一些呼损，想总结一下让<code>rpc</code>调用零呼损的两种方式：重试和优雅启停。我先介绍这两种方式，再描述一下这两种方式的优缺点</p>
<p><img src="/Images/rpc-lossless.png" alt="rpc-lossless"></p>
<p>A是一个微服务</p>
<p>B也是一个微服务</p>
<p>蓝色的是常见的注册中心，有<code>zookeeper</code>、<code>eureka</code>等实现。</p>
<h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>重试，在发生可重试错误的时候，重试一次。什么是可重试错误呢？就是重试一次，可能会成功。比如400 BadRequest，那出现这种错误，基本上重试也没有用，就不要浪费我们宝贵的服务器资源了。常见的如<code>servicecomb</code>框架就有重试几次、重试间隔这样的参数。值得一提的是，如果你指望通过重试让升级零呼损，那么你的重试次数，要比你的并行升级实例数大才行。</p>
<p>这也很容易理解，比如A服务调用B服务，B服务有5个实例,B1~B5。这个时候，同时升级B1和B2，A第一次调用了B1，接下来重试，如果运气不好，恰好重试到了B2节点，那么业务还是会失败的。如果防异常故障，就得重试三次才行。</p>
<p>如果是防止单数据中心宕机，重试次数大于同时宕机节点数，这个规则可能就没那么靠谱了。现在，企业部署十几个乃至二十几个微服务实例，已经不是什么新闻了，假设分3数据中心部署，总不能重试接近10次吧，这种时候，最好重试策略和数据中心相关，重试的时候，选择另一个az的实例。目前<code>servicecomb</code>还不支持这种功能。</p>
<h2 id="优雅启停"><a href="#优雅启停" class="headerlink" title="优雅启停"></a>优雅启停</h2><h3 id="优雅停止"><a href="#优雅停止" class="headerlink" title="优雅停止"></a>优雅停止</h3><p>优雅停止，就是说当微服务快要宕机的时候，先从注册中心进行去注册，然后把发送给微服务的消息，处理完毕后，再彻底关闭。这个方式，可以有效地防止升级期间，发送到老节点的呼损。</p>
<h3 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h3><p>优雅启动，当微服务实例，能够处理<code>rpc</code>请求的时候，再将实例自己注册到注册中心。避免请求发进来，实例却无法处理。</p>
<p>这里有一个要求，就是调用方发现被调用方（即A发现B）的注册中心，要和B注册、去注册的注册中心是一个注册中心。有案例是，发现采用k8s发现，注册、去注册却使用微服务引擎，导致呼损。</p>
<h1 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h1><h2 id="可预知节点升级的场景"><a href="#可预知节点升级的场景" class="headerlink" title="可预知节点升级的场景"></a>可预知节点升级的场景</h2><p>重试相对于优雅启停，在预知节点升级的场景没那么优雅，重试次数可能还要和并行升级的节点挂钩，非常的不优雅，且难以维护</p>
<h2 id="不可预知节点升级的场景"><a href="#不可预知节点升级的场景" class="headerlink" title="不可预知节点升级的场景"></a>不可预知节点升级的场景</h2><p>优雅启停无法对不可预知节点升级的场景生效。只有重试能在这个场景发挥作用</p>
<h2 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h2><p>重试可以很好地处理网络闪断、长链接中断等场景</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>想要实现<code>rpc</code>调用零呼损，重试和优雅启停都不可或缺，都需要实现。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/21/Dapper%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/21/Dapper%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Dapper论文笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-21 22:12:13" itemprop="dateCreated datePublished" datetime="2021-03-21T22:12:13+08:00">2021-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Dapper出现的背景"><a href="#Dapper出现的背景" class="headerlink" title="Dapper出现的背景"></a>Dapper出现的背景</h2><p>分布式系统不容易观测。有些问题靠日志和统计根本无法挖掘。<br>有些无法重现或极难重现的场景。</p>
<h2 id="Dapper设计的原则"><a href="#Dapper设计的原则" class="headerlink" title="Dapper设计的原则"></a>Dapper设计的原则</h2><h3 id="低时延"><a href="#低时延" class="headerlink" title="低时延"></a>低时延</h3><p>微不足道的性能影响，使应用程序团队愿意迁移。</p>
<h3 id="应用透明"><a href="#应用透明" class="headerlink" title="应用透明"></a>应用透明</h3><p>应用尽量少做侵入式修改</p>
<h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>随着应用程序的规模扩展</p>
<h2 id="Dapper概念"><a href="#Dapper概念" class="headerlink" title="Dapper概念"></a>Dapper概念</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img src="/Images/dapper1.png" alt="image-20210321221020253"></p>
<p><img src="/Images/dapper2.png" alt="image-20210321214734150"></p>
<p>通过引入parent id和span id等来将调用链串起来</p>
<h3 id="trace-id"><a href="#trace-id" class="headerlink" title="trace id"></a>trace id</h3><p>特定的模式是trace id</p>
<h3 id="span-id"><a href="#span-id" class="headerlink" title="span id"></a>span id</h3><p>span，包括日志，起始、终止时间，也包括key、value。还区分了网络和非网络时延。</p>
<h3 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h3><p>应用程序根据自己的需要可以打上annotation，不仅仅是key、value，还可以有时间戳等，有助于分析方法级别的耗时</p>
<p><img src="/Images/dapper3.png" alt="image-20210321221204695"></p>
<h2 id="Dapper原理"><a href="#Dapper原理" class="headerlink" title="Dapper原理"></a>Dapper原理</h2><ul>
<li>每当一个线程处理一个采样的控制线路时。Dapper在其中放置一个trace context在thread-local中。trace<br>context是一个小型、容易拷贝的对象，包含trace id和span id</li>
<li>异步或者callback的时候，用统一的library封装传递</li>
<li>RPC自动继承</li>
<li>不行，就通过api的方式接入</li>
</ul>
<h2 id="Dapper的流程"><a href="#Dapper的流程" class="headerlink" title="Dapper的流程"></a>Dapper的流程</h2><p><img src="/Images/dapper4.png" alt="image-20210321215159560"></p>
<p>写入流程分为三步。1、写入本地日志文件 2、被Dapper daemon获取 3、写入Bigtable</p>
<p>端到端的中位数时延在15秒。百分之75的数据的98时延在2分钟以内，但百分之25的数据的98时延可能会到几小时</p>
<h2 id="为什么不在RPC接口中顺手收集信息"><a href="#为什么不在RPC接口中顺手收集信息" class="headerlink" title="为什么不在RPC接口中顺手收集信息"></a>为什么不在RPC接口中顺手收集信息</h2><ul>
<li>trace信息可能比rpc本身的报文要大</li>
<li>对于异步流程，无法收集</li>
</ul>
<h2 id="Trace消耗的性能"><a href="#Trace消耗的性能" class="headerlink" title="Trace消耗的性能"></a>Trace消耗的性能</h2><h3 id="在应用程序侧"><a href="#在应用程序侧" class="headerlink" title="在应用程序侧"></a>在应用程序侧</h3><p>创建root span耗时约204纳秒，非root span耗时176纳秒</p>
<p>日志文件的消耗，可并行批量</p>
<p><img src="/Images/dapper5.png" alt="image-20210321215727742"></p>
<h3 id="Trace收集"><a href="#Trace收集" class="headerlink" title="Trace收集"></a>Trace收集</h3><p>每个trace数据约426byte</p>
<p>仅占用千分之一的Google生产带宽</p>
<h3 id="自适应采样"><a href="#自适应采样" class="headerlink" title="自适应采样"></a>自适应采样</h3><p>测试环境或低量请求多采样。请求量大小采样</p>
<h3 id="远端采样"><a href="#远端采样" class="headerlink" title="远端采样"></a>远端采样</h3><p>远端采样，降低服务端风险。</p>
<h2 id="Dapper索引选择"><a href="#Dapper索引选择" class="headerlink" title="Dapper索引选择"></a>Dapper索引选择</h2><p>基于服务、机器、时间</p>
<h2 id="Dapper的典型使用流程"><a href="#Dapper的典型使用流程" class="headerlink" title="Dapper的典型使用流程"></a>Dapper的典型使用流程</h2><ul>
<li>1用户选择服务、时间、期望看到的指标值（如时延）</li>
<li>2展示出满足这个条件的所有pattern，（trace pattern）</li>
<li>3展示这个pattern的调用链图，</li>
<li>4右侧是全部的采样</li>
<li>5展示出详细的时间戳分布</li>
</ul>
<h2 id="Dapper实际作用"><a href="#Dapper实际作用" class="headerlink" title="Dapper实际作用"></a>Dapper实际作用</h2><ul>
<li>发现无意义的调用</li>
<li>是否有必要访问主库，而不是从库</li>
<li>理解黑盒系统的依赖</li>
<li>测试。如果你不能观测，就不能优化</li>
<li>推断依赖</li>
<li>判断点到点网络故障，根据请求的大小，进一步推断，谁到谁引发了网络故障。</li>
<li>在底层share系统之上，外围按用户或其他维度统计调用</li>
<li>Dapper daemon的实时信息，可用来救火</li>
</ul>
<h2 id="Dapper现在做不到的"><a href="#Dapper现在做不到的" class="headerlink" title="Dapper现在做不到的"></a>Dapper现在做不到的</h2><ul>
<li>合并、批量处理，无法拆开识别</li>
<li>针对批系统，能力有限</li>
<li>根因分析，需要联合分析，比如在annotation中携带线程池队列大小，进行多个请求的联合分析等</li>
<li>如何和Linux内核关联，如何将错误和内核联系起来</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/19/LVS%20persistent%20timeout%E5%92%8Cconnection%20timeout%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lvs-timeout-analyze" class="post-title-link post-title-link-external" itemprop="url">LVS persistent timeout和connection timeout解析<i class="fa fa-external-link-alt"></i></a>
          
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-19 18:56:54" itemprop="dateCreated datePublished" datetime="2021-03-19T18:56:54+08:00">2021-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="两个超时的注释"><a href="#两个超时的注释" class="headerlink" title="两个超时的注释"></a>两个超时的注释</h1><p>首先看一下一下<code>ipvsadm -h</code>对这两个参数的注释</p>
<h2 id="persistent-timeout"><a href="#persistent-timeout" class="headerlink" title="persistent timeout"></a>persistent timeout</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--persistent  -p [timeout]     persistent service</span><br><span class="line">Specify that a virtual service is persistent. If this option is specified, multiple requests from a client are redirected to the same real server selected for the first request. Optionally, the timeout of persistent sessions may be specified given in seconds, otherwise the default of 300 seconds will be used. This option may be used in conjunction with protocols such as SSL or FTP where it is important that clients consistently connect with the same real server.</span><br></pre></td></tr></table></figure>

<p>说明这个VS是否是持久的。如果配置了这个选项，来自同一个客户端的链接（这里注意：这里的同一个客户端指的是同一个IP）会转发向相同的服务器。注释中特意提到了FTP协议。我查阅了一下资料，可能像FTP协议这种，客户端通过21端口打开控制连接，再通过20端口打开数据连接，这种协议，要求来自同一个客户端ip，不同端口的请求也送向同一个服务器，估计是这个参数存在的核心原因。如果是现在的系统，比如k8s使用ipvs，这个参数是完全没必要配置的</p>
<h2 id="connection-timeout"><a href="#connection-timeout" class="headerlink" title="connection timeout"></a>connection timeout</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--set tcp tcpfin udp</span><br><span class="line">Change the timeout values used for IPVS connections. This command always takes 3 parameters, representing the timeout values (in seconds) for TCP sessions, TCP sessions after receiving a FIN packet, and UDP packets, respectively. A timeout value 0 means that the current timeout value of the corresponding entry is preserved.</span><br></pre></td></tr></table></figure>

<p>更改用于ipvs连接的超时值。此命令始终使用3个参数，分别表示tcp会话，接收到FIN包的TCP会话和UDP包的超时值。单位为秒。设置为0并不代表将超时值设置为0，而是保持原有不变。顺便来说，<code>timeout</code>的默认值是900、120、300.</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>一个以客户端ip为维度，一个以客户端ip+port为维度</p>
<h2 id="联系："><a href="#联系：" class="headerlink" title="联系："></a>联系：</h2><ul>
<li>persistent值大于等于set时，persistent timeout以persistent的设置为准。</li>
<li>persistent值小于set时，当set超时，但persistent超时后，会将persistent再次设置为60。只到set超时为止。所以这个时候，真实生效的persistent timeout是<code>(s/60)*60 + p%60 + 60</code></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/14/Gorilla%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/Gorilla%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Gorilla论文笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 12:47:23" itemprop="dateCreated datePublished" datetime="2021-03-14T12:47:23+08:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>用了几个小时读完了Gorilla这篇经典的 <a target="_blank" rel="noopener" href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf">时序数据库论文</a><br>，prometheus的时序数据库在很多地方都参考了这篇论文。以此文总结一下读后感，非论文翻译。截图基本都出自于论文。本论文可以解答如下的普罗问题</p>
<h3 id="为什么普罗不支持字符串类型，只支持double作为监控值"><a href="#为什么普罗不支持字符串类型，只支持double作为监控值" class="headerlink" title="为什么普罗不支持字符串类型，只支持double作为监控值"></a>为什么普罗不支持字符串类型，只支持double作为监控值</h3><p>为了压缩数据，普罗使用了高效的用于double的压缩算法。</p>
<h3 id="为什么普罗的默认的落盘间隔是2个小时"><a href="#为什么普罗的默认的落盘间隔是2个小时" class="headerlink" title="为什么普罗的默认的落盘间隔是2个小时"></a>为什么普罗的默认的落盘间隔是2个小时</h3><p>根据这篇论文，2个小时或以上的block的压缩比更小</p>
<h3 id="普罗data盘里的文件都是用来干啥的？"><a href="#普罗data盘里的文件都是用来干啥的？" class="headerlink" title="普罗data盘里的文件都是用来干啥的？"></a>普罗data盘里的文件都是用来干啥的？</h3><p>有索引文件、数据文件、恢复日志等</p>
<p>顺带一提，Gorilla是大猩猩的意思，也是银魂中近藤勋的绰号。</p>
<p>Facebook因为从HBase读取时间序列太慢，再加上扩展性已经无法满足需求。Facebook对时延迟要求如此之低，Facebook否决了所有依赖磁盘做数据存储查询的方案，希望数据查询从内存返回。最终从论文看来，查询比HBase快了300多倍。</p>
<h2 id="数据的编码方式"><a href="#数据的编码方式" class="headerlink" title="数据的编码方式"></a>数据的编码方式</h2><p>Facebook想要把数据都放到内存中，prometheus号称单机可处理数百万序列，如果按照业务代码的模式书写，三百万序列在1个小时内要占用多少内存呢？时间戳long值4byte，字符串名称加维度20byte，值算double类型，8byte，总共是32byte，两个小时，假设1分钟一个点，共有120个点。共1.2G内存。仅仅纯数据就占用了1.2G内存。Facebook基于如下两个监控数据的特点，对数据进行了高效压缩，缩小12倍原数据的大小</p>
<ul>
<li>大多数监控数据往往相差固定的时间间隔，而其他监控数据，虽然不是严格固定间隔，也基本接近固定的时间间隔。这个比例在Facebook的监控数据是24：1，即百分之96的数据都是固定间隔上报的</li>
<li>大多数监控数据监控的值变化缓慢</li>
</ul>
<p>基于这两点假设，它们对时间戳和值提出了两种压缩算法</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>对时间戳的差值的差值进行存储，压缩空间大小。</p>
<p><img src="/Images/gorilla1.png" alt="image-20210313174810933"></p>
<p>先存储这一块的起始时间<code>2015 02:00:00</code>，对于第一个数值<code>2015 02:01:02</code>记录差值62，对下一个值<code>2015 02:02:02</code>，其的差值是60，差值的差值是<br><code>60-62=-2</code>，只存储-2即可，这样子大大节约了存储时间戳的空间</p>
<h3 id="监控值"><a href="#监控值" class="headerlink" title="监控值"></a>监控值</h3><p>监控值采用异或的手法进行压缩，会得到0很多的二进制串，再通过合理的编码，降低总字节数。根据论文，有超过一半的数据相较上一个值没什么变化，使用一个字节即可存储</p>
<p><img src="/Images/gorilla2.png" alt="image-20210313175320885"></p>
<p>那么这样一个<code>block</code>里面应该存储多久的数据呢？这是一个权衡，如果存储很久的数据，则每次查询都需要查询出很large的值，才能获得结果，如果存储数据较短，则难以达到很高的压缩比。最终他们选择了两小时。</p>
<p><img src="/Images/gorilla3.png" alt="block时长和压缩比的关系"></p>
<p>对于普罗里的指标名称及维度，在普罗里，一个指标名称加上一组维度称为一个时间序列，Gorilla论文并没有提及维度的概念，仅仅使用名称。这块普罗实际和Gorilla都通过码表的方式，通过将字符串映射为一个longId，来大大降低存储的字节数。</p>
<p>对于普罗的查询流程，是 指标名称+维度&#x3D;》一组时间序列，然后分别查询其中的值。Gorilla自身没有包装这一个流程，需要客户端组网自己想要查询的时间序列列表。</p>
<p>基于时序监控系统里的，新数据比旧数据关键，Gorilla也会将旧数据落盘。</p>
<h2 id="Gorilla的高可用"><a href="#Gorilla的高可用" class="headerlink" title="Gorilla的高可用"></a>Gorilla的高可用</h2><h3 id="单机可靠性"><a href="#单机可靠性" class="headerlink" title="单机可靠性"></a>单机可靠性</h3><p>Facebook调查了自己之前的监控系统，发现百分之85以上请求都只查询了26个小时以内的数据。在Gorilla的第一版中，他们决定只支持26个小时数据的查询，将2小时的数据放在内存中。超过2小时的数据，会存储在高可用磁盘上，如GlusterFs、HDFS等。2小时以内的数据，有一个log用来做重启时恢复数据来保证可靠性。这样就保证了单机重启的可靠性<br>注：这个日志不保证能恢复所有的数据，允许异常场景下有数据丢失</p>
<h3 id="Region宕机的可靠性"><a href="#Region宕机的可靠性" class="headerlink" title="Region宕机的可靠性"></a>Region宕机的可靠性</h3><p>对于每一个Gorilla，都会主备部署一个对等的位于不同Region的实例，这两个实例都会存储数据，但数据并不完全一致。对于用户来说，他们接入距离他们最近的Gorilla实例。一旦其中一个Gorilla宕机，另一个Gorilla将会接管它的工作。为了保证数据的准确，待其恢复后26小时（拥有了它该拥有的全量数据），才可以接受业务请求。</p>
<h2 id="Gorilla的扩展"><a href="#Gorilla的扩展" class="headerlink" title="Gorilla的扩展"></a>Gorilla的扩展</h2><p>Gorilla选择了水平扩展的方式，根据指标名做分区，分区到不同的主备<code>Gorilla</code></p>
<p>论文还提到了一些其他有用的信息</p>
<h2 id="监控时序数据的特点"><a href="#监控时序数据的特点" class="headerlink" title="监控时序数据的特点"></a>监控时序数据的特点</h2><h3 id="写请求占大多数"><a href="#写请求占大多数" class="headerlink" title="写请求占大多数"></a>写请求占大多数</h3><p>读请求很少，人工读取，或者一些自动化告警系统</p>
<h3 id="注重状态的变化"><a href="#注重状态的变化" class="headerlink" title="注重状态的变化"></a>注重状态的变化</h3><p>内存突然上升，乃至于一个指标值的导数突然上升等</p>
<h2 id="监控系统的目标"><a href="#监控系统的目标" class="headerlink" title="监控系统的目标"></a>监控系统的目标</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>出现问题的时候，监控系统和业务系统同时宕机是什么体验？是一把黑的体验。</p>
<h3 id="低延迟"><a href="#低延迟" class="headerlink" title="低延迟"></a>低延迟</h3><h3 id="可容错"><a href="#可容错" class="headerlink" title="可容错"></a>可容错</h3><p>容忍单点故障灯</p>
<h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>随着业务系统的扩展，监控系统也需要扩展</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/12/Rum%E5%AE%9A%E7%90%86%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/12/Rum%E5%AE%9A%E7%90%86%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">RUM定理论文笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-12 18:58:51" itemprop="dateCreated datePublished" datetime="2021-03-12T18:58:51+08:00">2021-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="RUM定理的背景"><a href="#RUM定理的背景" class="headerlink" title="RUM定理的背景"></a>RUM定理的背景</h2><p>现在的基础设备复杂，多种多样。数据的保存和查询也多种多样，很多时候会为了很小的差异重新设计数据结构。这篇论文主要是指出了无论如何设计数据结构，都不可能在Read（读取）、Update(更新)、Memory(存储)三个方向上都做到最优，也希望指导接下来其他数据结构的设计，更希望能有一种自适应的系统，可以根据数据的查询、数据的写入、配置的硬件、人工的配置在Read、Update、Memory之间权衡。</p>
<h2 id="RUM开销介绍"><a href="#RUM开销介绍" class="headerlink" title="RUM开销介绍"></a>RUM开销介绍</h2><p>我们将存储在数据中心的数据称作基础数据。那些用来辅助写入，辅助查询的数据成为辅助数据</p>
<h3 id="读开销-RO"><a href="#读开销-RO" class="headerlink" title="读开销 RO"></a>读开销 RO</h3><p>也称作读放大，通过读取到的辅助数据加上基础数据除以基础数据来计算。举个例子，在mysql中查询数据，中间经过的B树层级就是读放大</p>
<h3 id="更新开销-UO"><a href="#更新开销-UO" class="headerlink" title="更新开销 UO"></a>更新开销 UO</h3><p>也叫做写放大，实例物理上写入磁盘的大小除以逻辑上需要更新的大小。</p>
<h3 id="内存开销-MO"><a href="#内存开销-MO" class="headerlink" title="内存开销 MO"></a>内存开销 MO</h3><p>也叫做空间放大，全部的基础数据加上全部的辅助数据除以基础数据。</p>
<h2 id="RUM不可能达成举例"><a href="#RUM不可能达成举例" class="headerlink" title="RUM不可能达成举例"></a>RUM不可能达成举例</h2><p>我们选择一个有代表性的基础数据：一个整数数组。我们将这个数据集合组织到N个块中的固定大小的元素，每一个持有一个数值。每一个块可以用一个单调递增的ID来指示。工作负载使用数据的方式有 点查询、点更新、插入和删除。</p>
<h3 id="最小化RO"><a href="#最小化RO" class="headerlink" title="最小化RO"></a>最小化RO</h3><p>那我们就把bk的Id当做我们数据结构数组的下标，举例子，{1, 17}是两个元素的id，我们就开辟大小为17的数组array，然后通过array[i]来得到i的数据。现在已经达成了RO最小，但我们的索引非常稀疏，理论上我们的数组是无限大的。更新需要操作两次，将旧的数组元素置空，然后将新的数据存放在新的block中。</p>
<p>RO: 1  UO: 2 MO: 无穷大</p>
<h3 id="最小化UO"><a href="#最小化UO" class="headerlink" title="最小化UO"></a>最小化UO</h3><p>为了最小化UO，我们将每次更新的数据直接插入到日志的最尾端，就算更新完成。查询需要遍历原来的数据和整个log文件。</p>
<p>UO: 1 RO: 无穷大 MO: 无穷大</p>
<h3 id="最小化MO"><a href="#最小化MO" class="headerlink" title="最小化MO"></a>最小化MO</h3><p>最小化MO时，不存储辅助数据，而将基础数据密集地存储起来。 读取需要进行全表扫描，如果任意更新，也需要进行全表扫描</p>
<p>MO: 1 RO: N UO: 1</p>
<h2 id="数据结构的RUM"><a href="#数据结构的RUM" class="headerlink" title="数据结构的RUM"></a>数据结构的RUM</h2><p><img src="/Images/rum1.png" alt="image-20210314164113082"></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>N</th>
<th>m</th>
<th>B</th>
<th>P</th>
<th>T</th>
<th>MEM</th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>数据集大小</td>
<td>查询结果大小</td>
<td>块大小</td>
<td>分区大小</td>
<td>LSM级别比例</td>
<td>内存</td>
</tr>
<tr>
<td>单位</td>
<td>元组</td>
<td>元组</td>
<td></td>
<td></td>
<td></td>
<td>页</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>批量创建</th>
<th>索引大小</th>
<th>点查询</th>
<th>范围查询(大小m)</th>
<th>查询&#x2F;更新&#x2F;删除</th>
</tr>
</thead>
<tbody><tr>
<td>读取方式</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>B+树</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>完美哈希索引</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZoneMaps</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>层级LSM树</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>排序列</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>未排序列</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="/Images/rum2.png" alt="image-20210314164933209"></p>
<h2 id="论文作者对将来系统的设想"><a href="#论文作者对将来系统的设想" class="headerlink" title="论文作者对将来系统的设想"></a>论文作者对将来系统的设想</h2><p>作者认为，将来的系统应该是RUM可调的，来满足大多数场景的需要。通过一套可以轻松适应不同优化目标的访问方法来展望未来的数据系统。例如：</p>
<p>• 具有动态调整参数（包括树高，节点大小和拆分条件）的B +树，以便在运行时调整树大小，读取成本和更新成本。</p>
<p>• Approximate (tree) indexing that supports updates with low read performance overhead, by absorbing them in updatable probabilistic data structures (like quotient filters).</p>
<p>• Morphingaccessmethods,combiningmultipleshapesatonce. Adding structure to data gradually with incoming queries, and building supporting index structures when further data reorganization becomes infeasible.</p>
<p>• Update-friendly bitmap indexes, where updates are absorbed using additional, highly compressible, bitvectors which are gradually merged.</p>
<p>• Accessmethodswithiterativelogsenhancedbyprobabilistic data structures that allows for more efficient reads and up- dates by avoiding accessing unnecessary data at the expense of additional space.</p>
<h2 id="论文中其他有意思的点"><a href="#论文中其他有意思的点" class="headerlink" title="论文中其他有意思的点"></a>论文中其他有意思的点</h2><ul>
<li>现代数据系统，通常在压缩的数据上运行，并尽可能晚地解压缩</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/12/iptables%E3%80%81ipvs%E8%A7%84%E6%A0%BC%E5%86%B2%E7%AA%81%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/12/iptables%E3%80%81ipvs%E8%A7%84%E6%A0%BC%E5%86%B2%E7%AA%81%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">iptables、ipvs规格冲突现象分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-12 17:03:39" itemprop="dateCreated datePublished" datetime="2021-03-12T17:03:39+08:00">2021-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iptables和ipvs都是常见的转发工具，可以进行报文的转发，比如从 <code>IPa,Port1</code>的消息，经过转发机器发向<code>IPb,Port2</code>,不管是在iptables，抑或是ipvs，进行过一次转发之后，就会留下一条转发记录，iptables是在nf_conntrack，ipvs是在ipvs自己的会话管理里，后面的来自<code>IPa,Port1</code>的消息，就会直接发向<code>IPb,Port2</code>。这个时候，假如强行有一个报文，试图把<code>IPc,Port1</code>的消息，转发到<code>IPb,Port2</code>该怎么办？在四元组冲突的情况下，该转发给谁？返程的报文是什么走向。是这篇文章试图分析的问题</p>
<p>本文基于Linux内核版本<code>5.4.0</code></p>
<h2 id="出场网元介绍"><a href="#出场网元介绍" class="headerlink" title="出场网元介绍"></a>出场网元介绍</h2><p><img src="/Images/iptables-ipvs-conflict1.png" alt="image-20210311221120239"></p>
<ul>
<li><p>S: 缩写服务的意思</p>
</li>
<li><p>G: 缩写Gateway的意思</p>
</li>
</ul>
<h2 id="Iptables和Iptables冲突"><a href="#Iptables和Iptables冲突" class="headerlink" title="Iptables和Iptables冲突"></a>Iptables和Iptables冲突</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>假设S1和S2都需要经过G使用33333端口发送消息到V的33333端口，我们先配置G的iptables规则:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">iptables -t nat -I POSTROUTING -p udp -s <span class="variable">$&#123;S的子网&#125;</span> -o eth0 --sport 33333 -j SNAT  --to-source <span class="variable">$&#123;G的IP&#125;</span>:33333</span><br></pre></td></tr></table></figure>

<p>接下来在两台S上，把发往V的报文的默认路由指向V</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add <span class="variable">$&#123;V的IP&#125;</span>/32 via <span class="variable">$&#123;G的IP&#125;</span></span><br></pre></td></tr></table></figure>

<p>实验前先执行如下命令，收集输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# conntrack -S</span><br><span class="line">cpu=n found=0 invalid=0 ignore=0 insert=0 insert_failed=0 drop=0 early_drop=0 error=0 search_restart=0</span><br></pre></td></tr></table></figure>

<p>这个命令的输出跟您的cpu相关，有几个cpu就会输出几行。接下来在V上开启抓包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -port 33333 -ann</span><br></pre></td></tr></table></figure>

<p>然后在两台S上执行命令发送报文，这里有个小技巧就是使用不一样长度的内容，这样tcpdump会打印报文的长度，一眼就可以看出来送达的报文是谁的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span>| nc -4u -p 33333 V的IP 33333</span><br></pre></td></tr></table></figure>

<p>你会观察到，只有先发送的报文抵达了V。随后再执行<code>conntrack -S</code>，收集输出的时候，会发现<code>insert_failed</code>和<code>drop</code>都增加了1。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>iptables和iptables冲突的场景，先发送的先生效，后生效的没有发送（这一点你可以通过在G上抓包证实）。观察点就是命令<code>conntrack -S</code>的输出，<code>insert_failed</code>和<code>drop</code>都有所增加。</p>
<h3 id="Iptables流程图"><a href="#Iptables流程图" class="headerlink" title="Iptables流程图"></a>Iptables流程图</h3><p>我在做这个实验的时候，顺手打开了iptables的trace功能，记录一下报文的流程</p>
<p><img src="/Images/iptables-ipvs-conflict2.png" alt="image-20210311222756033"></p>
<p>发送失败的也会走完这个流程，然后在插入iptables规则的时候失败。</p>
<h2 id="Iptables和Ipvs冲突"><a href="#Iptables和Ipvs冲突" class="headerlink" title="Iptables和Ipvs冲突"></a>Iptables和Ipvs冲突</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>因为ipvs不会和ipvs冲突，所以我们尝试构造一下ipvs和iptables冲突的场景，让我们添加上允许V经过G发送报文到S1，让我们在G上配置ipvs所需的转发规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A -u $&#123;G的IP&#125;:33333 -s rr</span><br><span class="line">ipvsadm -a -u $&#123;G的IP&#125;:33333 -r $&#123;S1的IP&#125;:33333 -m</span><br></pre></td></tr></table></figure>

<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><p>从V发送报文转发到S1,然后S2通过SNAT发送报文到V，观察情况</p>
<p>实施前的准备观察项</p>
<ul>
<li><p>ipvsadm -lnc观察会话</p>
</li>
<li><p>ipvsadm -ln –stats 观察报文统计</p>
</li>
<li><p>conntrack -L|grep 33333 观察会话</p>
</li>
<li><p>当V发送报文到S1后，</p>
</li>
</ul>
<p>Ipvsadm -ln -stats统计值增加了，只有ipvs的会话表里有内容，iptables会话表里没有内容。</p>
<ul>
<li>然后S2通过SNAT发送报文到V后，</li>
</ul>
<p>ipvsadm -ln -stats统计值没有变化，iptables会话表出现内容。（这里我试过S1先返回报文做几次交互，但是是一样的结果）</p>
<p>但是在ipvs有效期间，通过S1不断发送报文，还是可以发送到V节点的。这个时候，会出现S1和S2同时都能发送报文到V。</p>
<ul>
<li>让我们看看报文返程（即V发送到G的报文）会发送给谁？是S1还是S2。答案是S2。</li>
</ul>
<p>返程的报文优先匹配了会话表，发送给了S2。如果conntrack老化，那么才会发送给S1</p>
<h3 id="V上来的流程"><a href="#V上来的流程" class="headerlink" title="V上来的流程"></a>V上来的流程</h3><p><img src="/Images/iptables-ipvs-conflict3.png" alt="image-20210311224826893"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/11/%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AALinux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/11/%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AALinux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">书写一个Linux内核模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 19:34:52" itemprop="dateCreated datePublished" datetime="2021-03-11T19:34:52+08:00">2021-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.sourcerer.io/writing-a-simple-linux-kernel-module-d9dc3762c234">https://blog.sourcerer.io/writing-a-simple-linux-kernel-module-d9dc3762c234</a></p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="C文件书写"><a href="#C文件书写" class="headerlink" title="C文件书写"></a>C文件书写</h2><p>首先，先书写一个C文件，命名为<code>kernel_first.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Robert W. Oliver II&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple example Linux module.&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load时候触发的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">example_init(<span class="type">void</span>) &#123;</span><br><span class="line">    printk(KERN_INFO</span><br><span class="line">    <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unload时候触发的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">example_exit(<span class="type">void</span>) &#123;</span><br><span class="line">    printk(KERN_INFO</span><br><span class="line">    <span class="string">&quot;Goodbye, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_init);</span><br><span class="line">module_exit(example_exit);</span><br></pre></td></tr></table></figure>

<ul>
<li>请注意使用printk而不是printf。 另外，printk与printf共享的参数不同。 例如，KERN_INFO是一个标志，用于声明应为此行设置日志记录的优先级，并且不带逗号。<br>内核在printk函数中对此进行了分类，以节省堆栈内存。</li>
<li>在文件末尾，我们调用module_init和module_exit告诉内核哪些函数是在load时候执行，那些在unload的时候执行</li>
</ul>
<h2 id="Makefile书写"><a href="#Makefile书写" class="headerlink" title="Makefile书写"></a>Makefile书写</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m += kernel_first.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>注 make前面应该是Tab键</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行如下命令加载模块到内核<code>sudo insmod kernel_first.ko</code>执行<code>dmesg|grep -i hello</code>,将会看到Hello world的输出。接下来卸载内核模块<br><code>sudo rmmod kernel_first</code>,接下来运行<code>dmesg</code>，你将会看到Goodbye world的输出</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/07/Quorum%E7%9C%9F%E7%9A%84%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/07/Quorum%E7%9C%9F%E7%9A%84%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%E5%90%97/" class="post-title-link" itemprop="url">Quorum真的万无一失吗？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-07 10:33:47" itemprop="dateCreated datePublished" datetime="2021-03-07T10:33:47+08:00">2021-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>数据密集型系统</li>
</ul>
<h2 id="Quorum介绍"><a href="#Quorum介绍" class="headerlink" title="Quorum介绍"></a>Quorum介绍</h2><p>Quorum模式常用于分布式场景，保证数据的一致性。其中有两个核心参数</p>
<ul>
<li>Qw 代表数据写入(包括更新、删除)需要的节点数</li>
<li>Qr 代表数据读取需要的节点数</li>
</ul>
<p>如果你总共有N个节点，那么很容易得出只要 W+R&gt;N，那么你的读请求和写请求一定有重叠的节点，这就保证了一致性，你总是能找到最新的那个写入请求</p>
<h2 id="Quorum的不一致场景"><a href="#Quorum的不一致场景" class="headerlink" title="Quorum的不一致场景"></a>Quorum的不一致场景</h2><p>但Quorum模式并不一定是万无一失的，他在如下场景会导致不一致</p>
<ul>
<li>如果两个写操作同时发生，则无法明确先后顺序，最终需要额外的修复手段</li>
<li>如果写操作和读操作同时发生，写操作可能仅在一部分副本上完成。此时，读取时返回旧值还是新值存在不确定性</li>
<li>如果某些副本上已经写入成功，而其他一些副本发生写入失败（如磁盘已满），且总的成功副本数少于w，那些已成功的副本上不会做回滚。这意味着尽管这样的写操作被视为失败，后续的读操作仍可能返回新值</li>
</ul>
<h2 id="还有两个更加边界的场景"><a href="#还有两个更加边界的场景" class="headerlink" title="还有两个更加边界的场景"></a>还有两个更加边界的场景</h2><h3 id="Sloppy-Quorum"><a href="#Sloppy-Quorum" class="headerlink" title="Sloppy Quorum"></a>Sloppy Quorum</h3><p>也叫做宽松的Quorum模式，就是说当N不够的情况下，可以把集群的其他节点当作Qw节点。如果采用了sloppy<br>quorum，写操作的w节点和读取的r节点可能完全不同，因此无法保证读写请求一定存在重叠的节点</p>
<h2 id="数据的恢复场景"><a href="#数据的恢复场景" class="headerlink" title="数据的恢复场景"></a>数据的恢复场景</h2><p>进行数据的恢复在所难免，如cassandra就有读修复等，如果具有新值的节点后来发生失效，但恢复数据来自某个旧值，则总的新值副本数会低于w，这就打破了之前的判定条件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2021/03/06/ipvs%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95%E5%9C%A8UDP%E7%9A%84%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/06/ipvs%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95%E5%9C%A8UDP%E7%9A%84%E5%9D%91/" class="post-title-link" itemprop="url">ipvs负载均衡最小连接算法在UDP的坑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-06 13:02:40" itemprop="dateCreated datePublished" datetime="2021-03-06T13:02:40+08:00">2021-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 19:32:27" itemprop="dateModified" datetime="2025-10-21T19:32:27+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在ipvs中，最小连接算法是一种负载均衡算法，常见的还有轮询算法，加权轮询算法等。让我们先做个基本的假设，每个<strong>UDP</strong>会话连接上的请求量大概一致。让<strong>LB</strong>无需观测后端服务的状态，仅仅根据会话信息，做出转发到哪个后端<strong>Service</strong>的判断，事实上，lvs也目前不能根据后端服务的cpu、内存或者是其他信息做出判断。直观上来说，最小连接数很符合大家的直观感受，保证了每个工作负载上承受的业务连接数是最少的。</p>
<p><img src="/Images/ipvs-lb-udp.png" alt="ipvs-lb-udp"></p>
<p>但是，在LVS保留会话时间稍微较长的情况下，最小连接算法在扩容、升级（升级前后IP改变）、重启（重启前后IP改变）会有一些问题。</p>
<p>简而言之，就是<strong>LVS</strong>向后端转发<strong>UDP</strong>消息的时候，后端服务没有很好的拒绝手段，在<strong>LC</strong>模式下，导致<strong>LVS</strong>可能转发给后端服务，超过它处理能力的消息数，等到这些会话老化之后，<strong>LVS</strong>又开始转发给后端服务，超过它处理能力的消息数，如此反复，始终造成大量消息呼损，极难自愈</p>
<h2 id="详细数据推导"><a href="#详细数据推导" class="headerlink" title="详细数据推导"></a>详细数据推导</h2><p>以扩容为例，设</p>
<ul>
<li>每秒消息量 m</li>
<li>保活时间  t</li>
<li>旧的节点数 a</li>
<li>新增节点数 b</li>
<li>使用新IP的请求占比 c (0&lt;c&lt;1)</li>
<li>在一段保活时间内的IP总数 d</li>
<li>单节点处理能力为x</li>
</ul>
<p>那么，扩容时刻，老的节点上的会话数是<strong>d&#x2F;a</strong></p>
<p>扩容的时候，由于老的节点存在<strong>mt&#x2F;a</strong>的会话，那么新IP上来的请求都会转发向新节点，直到把新节点的连接数冲到<strong>mt&#x2F;a</strong>为止，</p>
<p>新节点接收请求的速率: <strong>(m * c)&#x2F;b</strong><br>新节点连接数和老节点持平的时间点: **(d * b)&#x2F;(m * c <em>a)</em>*</p>
<p>如果<strong>新节点连接数和老节点持平的时间点</strong>远远小于<strong>保活时间</strong>,这就会有问题。其他节点上的会话都是相对离散的，所以在保活时间t内，一直不断有消息进来，但新的节点一瞬间接收到了大量请求，又会在同一时间老化。在下一个周期t，又接收到大量请求，如此反复，极难自愈。这也因为lvs的udp转发不关心后端服务器是否成功处理报文，只要转发过去就算了。就是lvs无视后端的状态转发，相比tcp，至少还有是否接收tck连接，后端主动拆链等手段。</p>
<p>虽然<strong>LVS</strong>能限制后端服务器的连接数，但连接数限制在这个场景是不起作用的。如果您的服务满足上述的这个模式，还是建议您修改为rr算法更为适合。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhangjian He</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
