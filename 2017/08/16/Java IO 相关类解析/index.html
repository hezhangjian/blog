<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hezhangjian.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"normal"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="OutputStreamJava.io.OutputStream类声明了三个基本方法用来把byte数据写入到流中。当然也有用于关闭和刷新的流 12345public abstract void write(int b) throws IOExceptionpublic void write(byte[] data) throws IOExceptionpublic void write(byte[">
<meta property="og:type" content="article">
<meta property="og:title" content="Java IO 相关类解析">
<meta property="og:url" content="https://hezhangjian.com/2017/08/16/Java%20IO%20%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="张俭的博客">
<meta property="og:description" content="OutputStreamJava.io.OutputStream类声明了三个基本方法用来把byte数据写入到流中。当然也有用于关闭和刷新的流 12345public abstract void write(int b) throws IOExceptionpublic void write(byte[] data) throws IOExceptionpublic void write(byte[">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-08-16T13:57:58.000Z">
<meta property="article:modified_time" content="2025-10-21T12:55:02.637Z">
<meta property="article:author" content="Zhangjian He">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hezhangjian.com/2017/08/16/Java%20IO%20%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E6%9E%90/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hezhangjian.com/2017/08/16/Java%20IO%20%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E6%9E%90/","path":"2017/08/16/Java IO 相关类解析/","title":"Java IO 相关类解析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java IO 相关类解析 | 张俭的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">张俭的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OutputStream"><span class="nav-number">1.</span> <span class="nav-text">OutputStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputStream"><span class="nav-number">2.</span> <span class="nav-text">InputStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FileInputStream"><span class="nav-number">3.</span> <span class="nav-text">FileInputStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">4.</span> <span class="nav-text">FileOutputStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URLS"><span class="nav-number">5.</span> <span class="nav-text">URLS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UrlConnection"><span class="nav-number">6.</span> <span class="nav-text">UrlConnection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sockets"><span class="nav-number">7.</span> <span class="nav-text">Sockets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServerSocket"><span class="nav-number">8.</span> <span class="nav-text">ServerSocket</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangjian He</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hezhangjian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/hezhangjian" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;hezhangjian" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hezhangjian.com/2017/08/16/Java%20IO%20%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangjian He">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张俭的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java IO 相关类解析 | 张俭的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java IO 相关类解析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-16 21:57:58" itemprop="dateCreated datePublished" datetime="2017-08-16T21:57:58+08:00">2017-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 20:55:02" itemprop="dateModified" datetime="2025-10-21T20:55:02+08:00">2025-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>Java.io.OutputStream类声明了三个基本方法用来把byte数据写入到流中。当然也有用于关闭和刷新的流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>OutputStreams是一个抽象类，子类提供方法的实现。大多数情况下，你只需要知道你处理的对象是一个OutputStream就足够了。<br>OutputStream中最基本的方法是write()</p>
<p>  public abstract void write(int b) throws IOException<br>这个方法书写了一个无符号byte（0-255），如果你传入了大于255或者小于0的数值，会对256取模直到得到一个合适的值。<br>通常来说，对大量的数据，用byte来传递会更快一些。这正是两个write方法的用途<br>第一个写入整个byte数组。第二个只写入数组的一部分，从offset开始写入length长度的数据。<br>相反地，如果你尝试一次性写入太多的数据，性能上就会出现问题。文件最好一次一次地写入小的块，典型地数值像512，1024，2048.网络连接通常只需要更小的块，128或者256.<br>输出流缓冲区用来提高性能。比起把每一个字节送到它想去的终点，字节们先在内存缓冲区中集合。当缓冲区被填满，数据被传送出去。flush方法强迫缓冲区没有满的时候输出。<br>如果你只使用流很短的时间，你不需要明确地调用flush方法。它应该在流关闭的时候被flush。一旦你关闭了流，你就不能再向其中写入数据，如果你尝试这么做，就会引起IOException.</p>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>Java.io.InputStream类声明了三个基本方法用来把byte数据写入到流中。当然也有用于关闭和刷新的流,查看还有多少数据可以读，略过一些输入，在流中标记一个位置然后重置到那个位置，还有决定标记和重设是否是支持的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract int read() throws IOException</span><br><span class="line">public int read(byte[] data) throws IOException</span><br><span class="line">public int read(byte[] data, int offset, int length) throws IOException</span><br><span class="line">public long skip(long n) throws IOException</span><br><span class="line">public int available() throws IOException</span><br><span class="line">public void close() throws IOException</span><br><span class="line">public synchronized void mark(int readLimit)</span><br><span class="line">public synchronized void reset() throws IOException</span><br><span class="line">public boolean markSupported()</span><br></pre></td></tr></table></figure>
<p>  InputStream中最基本的方法是read,这个方法读入一个无符号的byte类型，然后返回它的整型值。就像大多数的IO方法一样，read方法也会有异常抛出，如果read中无数据可读，你不会受到异常，而是返回-1。用这个作为流结尾的标志。如下的代码展示了如何catch IOException和查看是否为结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    int[] data = new int[10];</span><br><span class="line">    for(int i=0;i&lt;data.length;i++) &#123;</span><br><span class="line">        int datum = System.in.read();</span><br><span class="line">        if (datum == -1) break;</span><br><span class="line">        data[i] = datum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e ) &#123;</span><br><span class="line">    System.err.println(&quot;Couldn&#x27;t read from System.in!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  read方法等待或者阻塞直到byte数据可用而且准备就绪。Input和Output可能会很慢，所以如果你的程序在执行其他重要的事情。你应该把IO操作放在它们自己的线程当中。下面这个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class StreamPrinter &#123;</span><br><span class="line">  InputStream theInput;</span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    StreamPrinter sr = new StreamPrinter(System.in);</span><br><span class="line">    sr.print();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamPrinter(InputStream in) &#123;</span><br><span class="line">    theInput = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void print() &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      while(true) &#123;</span><br><span class="line">        int datum = theInput.read();</span><br><span class="line">        if (datum == -1) break;</span><br><span class="line">        System.out.println(datum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      System.err.println(&quot;couldn&#x27;t read from system in&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第一个read方法读入一批连续数据到byte数组中，第二个尝试读入一定长度的data从offset开始到byte数组。它们两个都不保证读入任意数量的byte。<br>  如果你打算从System.in读入10byte的数据，如下的代码可以完成操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = new byte[10];</span><br><span class="line">System.in.read(b);</span><br></pre></td></tr></table></figure>
<p>  但是，并不是每次read都可以拿到你想要的那么多数据。但是这行代码也不能阻止你试图往read中写入超过容量的数据，如果你这么做了，就会导致ArrayIndexOutOfBoundsException.<br>  如下的代码利用循环，确保尽可能多得获得数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = new byte[100];</span><br><span class="line">int offset = 0;</span><br><span class="line">while(offset &lt;b.length) &#123;</span><br><span class="line">  int bytesRead = System.in.read(b, offset,b.length-offset);</span><br><span class="line">  if(bytesRead==-1) break;</span><br><span class="line">  offset+=bytesRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  尽管上述的代码可以尽可能多得获取数据，但是并不能规避异常的发生。所以，如果在你尝试读它们之前，你可以知道有多少数据将要被读，这将会非常方便。InputStream中的available方法可以告诉你答案<br>  你可以手动操作代码来忽略掉一部分的数据，但JAVA还是提供了skip方法用来跳过给定byte数的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public long skip(long bytesToSkip) throws IOException</span><br></pre></td></tr></table></figure>
<p>  返回值是实际略去的byte数。如果返回-1，则证明剩下的部分都被忽略了。通常来说skip方法比自己手动忽略要快。<br>  并不是所有的流都需要被关闭，比如System.in。但是跟文件或者网络相关的连接还是需要被关闭的。</p>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>java.io.FileInputStream是InputStream的具体实现，提供具体文件的输入流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStream extends InputStream</span><br></pre></td></tr></table></figure>
<p>  FileInputStream 实现了InputStream的常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int read() throws IOException</span><br><span class="line">public int read(byte[] data) throws IOException</span><br><span class="line">public int read(byte[] data, int offset, int length) throws IOException</span><br><span class="line">public native long skip(long n) throws IOException</span><br><span class="line">public native int available() throws IOException</span><br><span class="line">public native void close() throws IOException</span><br></pre></td></tr></table></figure>
<p>  这些方法都是Java Native Code，除了read方法，但这些方法还是把参数传给了native方法。所以实际上，这些方法都是Native方法。<br>  FileInputStream有三种构造方法，区别在于文件是如何指定的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public FileInputStream(String fileName) throws IOException</span><br><span class="line">public FileInputStream(File file) throws FileNotFoundException</span><br><span class="line">public FileInputStream(FileDescriptor fdObj)</span><br></pre></td></tr></table></figure>
<p>  第一个构造函数使用文件的名称，文件的名称跟平台相关，所以硬编码文件名不是一个好的方案，相比之下，后两个就要好很多。<br>  读取文件，我们只需要把文件名称传递给构造函数。然后像平常那样调用read方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = new FileInputStream(&quot;README.TXT&quot;);</span><br><span class="line">int n;</span><br><span class="line">while ((n=fis.available())&gt;0) &#123;</span><br><span class="line">  byte[] b = new byte[n];</span><br><span class="line">  int result = fis.read(b);</span><br><span class="line">  if( result == -1) break;</span><br><span class="line">  String s = new String(b);</span><br><span class="line">  System.out.print(s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>  Java在当前的工作路径寻找文件，通常来说，就是你键入java programName时的路径。在FileInputStream的构造函数中传入相对路径和绝对路径都是可行的。<br>  如果你试图打开一个并不存在的文件，就会抛出FileNotFoundException。如果因为其他原因无法写入（比如权限不足）其他类型的异常会被抛出。下面是一个通过控制台获取文件名，然后把文件打印到控制台的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FileTyper &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if(args.length==0) &#123;</span><br><span class="line">      System.err.println(&quot;no file is determined&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">      try&#123;</span><br><span class="line">        typeFile(args[i]);</span><br><span class="line">        if(i+1&lt;args.length) &#123;</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.println(&quot;--------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125; catch (IOException e) &#123;System.err.println(e);&#125; </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void typeFile(String filename) throws IOException &#123;</span><br><span class="line">    FileInputStream fin = new FileInputStream(filename);</span><br><span class="line">    StreamCopier.copy(fin,System.out);</span><br><span class="line">    fin.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果需要的话，你也可以对同一个文件同时打开多个流。每一个流维护一个单独的指针，指向文件中的当前位置。读取文件并不会更改文件，如果是写文件的话，那就是另一回事了。</p>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>  java.io.FileOutputStream是java.io.OutputStream的具体实现,提供连接到文件的输出流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FileOutputStream extends OutputStream</span><br></pre></td></tr></table></figure>
<p>  类中实现了OutputStream的所有常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native void write(int b) throws IOException</span><br><span class="line">public void write(byte[] data) throws IOException</span><br><span class="line">public void write(byte[] data, int offset, int length) throws IOException</span><br><span class="line">public native void close() throws IOException</span><br></pre></td></tr></table></figure>
<p>  跟之前的FileInputStream相同，FileOutputStream的四个方法也都是实际上的native方法。如下的三种构造器，区别在于文件是如何指定的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public FileOutputStream(String filename) throws IOException</span><br><span class="line">public FileOutputStream(File file) throws IOException</span><br><span class="line">public FileOutputStream(FileDescriptor fd)</span><br></pre></td></tr></table></figure>
<p>  和FileInputStream不同的是，如果指定的文件不存在，那么FileOutputStream会创建它，如果文件存在，FileOutputStream会覆盖它。这个特性让我们使用的时候有些不太方便，有的时候，往往我们需要往一个文件里面添加一些数据，比如向日志文件里面存储记录。这时候，第四个构造函数就体现了它的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public FileOutputStream(String name, boolean append) throws IOException</span><br></pre></td></tr></table></figure>
<p>  如果append设置为true，那么如果文件存在，FileOutputStream会向文件的末尾追加数据，而不是覆盖。<br>  下面的程序获取两个文件名作为参数，然后把第一个文件复制到第二个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FileCopier &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if(args!=2) &#123;</span><br><span class="line">      System.err.println(&quot;error input&quot;);//输入异常。</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      copy(args[0],args[1]);//调用复制文件的方法</span><br><span class="line">    &#125; catch (IOException e) &#123;System.err.println(e);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void copy (String inFile, String outFile) throws IOException &#123;</span><br><span class="line">    FileInputStream fin = null;</span><br><span class="line">    FileOutputStream fout = null;</span><br><span class="line">    try&#123;</span><br><span class="line">      fin = new FileInputStream(inFile);</span><br><span class="line">      fout = new FileOutputStream(outFile);</span><br><span class="line">      StreamCopier.copy(fin,fout);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (fin != null) fin.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (fout != null) fout.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StreamCopier &#123;</span><br><span class="line">  public static void copy(InputStream in,OutputStream out) throws IOException &#123;</span><br><span class="line">    //Do not allow other threads read from the input or write the output</span><br><span class="line">    synchronized (in) &#123;</span><br><span class="line">      synchronized (out) &#123;</span><br><span class="line">        byte[] buffer = new byte[256];</span><br><span class="line">        while(true) &#123;</span><br><span class="line">          int bytesRead = in.read(buffer);</span><br><span class="line">          if(bytesRead == -1) break;</span><br><span class="line">          out.write(buffer,0,bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="URLS"><a href="#URLS" class="headerlink" title="URLS"></a>URLS</h2><p>java.net.URL类是标准资源定位符。每一个URL明确地指定了因特网上一个资源的位置。URL有四个构造函数，每一个都声明了MalformedURLException</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public URL(String u) throws MalformedURLException</span><br><span class="line">public URL(String protocol, String host, String file) throws MalformedURLException</span><br><span class="line">public URL(String protocol, String host, int port, String file) throws MalformedURLException</span><br><span class="line">public URL(URL context, String u) throws MalformedURLException</span><br></pre></td></tr></table></figure>
<p>  如果构造器没有给定一个URL，MalformedURLException会被抛出。如果给你一个绝对的URL比如”<a target="_blank" rel="noopener" href="http://www.jianshu.com/u/9e21abacd418%22,%E4%BD%A0%E4%BC%9A%E8%BF%99%E6%A0%B7%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAURL%E5%AF%B9%E8%B1%A1">http://www.jianshu.com/u/9e21abacd418&quot;,你会这样构造一个URL对象</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL u = null;</span><br><span class="line">try &#123;</span><br><span class="line">  u = new URL(&quot;http://www.jianshu.com/u/9e21abacd418&quot;);</span><br><span class="line">&#125; catch (MalformedURLException e)　&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  你也可以把协议，host和路径分开传入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL u = null;</span><br><span class="line">try &#123;</span><br><span class="line">  u = new URL(&quot;http&quot;,&quot;www.jianshu.com&quot;,&quot;/u/9e21abacd418&quot;);</span><br><span class="line">&#125; catch (MalformedURLException e)　&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  一般情况下，你不需要特地指定协议的端口，大多数协议有他们默认的端口，比如HTTP的协议的默认端口是80.如果端口改变了，可以使用下面的构造方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u = new URL(&quot;http&quot;,&quot;www.jianshu.com&quot;,8080,&quot;/u/9e21abacd418&quot;);</span><br></pre></td></tr></table></figure>
<p>  一旦URL对象被构造，有两种方式获得它的内容。openStream()方法返回原始的数据流，getContent()方法返回一个对象代表数据。当你调用getContent()方法的时候，JAVA根据它的MIME类型，寻找一个content handler，然后返回一个可用的数据对象。<br>  openStream()方法和URL代表的服务器和端口建立了一个Socket连接，返回一个可以获取数据的InputStream，允许你从服务器上下载数据。所有的头文件，跟数据无关的东西在流打开的时候都被跳过了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final InputStream openStream() throws IOException</span><br></pre></td></tr></table></figure>
<p>  使用reader或者InputStream来获取数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  URL u = new URL(&quot;http://www.amnesty.org/&quot;);</span><br><span class="line">  InputStream in = u.openStream();</span><br><span class="line">  int b;</span><br><span class="line">  while ((b = in.read()) != -1) &#123;</span><br><span class="line">    System.out.write(b);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">catch (MalformedURLException e) &#123;System.err.println(e);&#125;  </span><br><span class="line">catch (IOException e) &#123;System.err.println(e);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UrlConnection"><a href="#UrlConnection" class="headerlink" title="UrlConnection"></a>UrlConnection</h2><p>URL Connection和URL有着密切的联系，就像名字一样。你通过URL的openConnection()方法得到一个URL Connection的引用。<br>在大多数情况下，URL只是对URL Connection对象的一种封装。然而URL提供了更多的控制。</p>
<p>  URL Connection不仅仅提供了让客户端读取服务器上信息的能力，而且提供了OutputStream使得，客户端的文件可以发送向服务器。</p>
<p>  java.net.URLConnection类是一个处理多种不同类型服务器的抽象类，比如FTP服务器和web服务器。<br>  一.从URL Connection中读取数据<br>  1.构造URL对象<br>  2.通过openConnection()方法创建一个URLConnection对象<br>  3.连接的参数和需要的属性已经设置完毕<br>  4.使用connect()方法建立连接，可能是使用socket的网络连接，也可能是文件读入流的本地连接。响应的头部信息从服务器传入。<br>  5.使用InputStream来读取数据，或者使用相应(MIME 类型)content handler的getContent()方法。<br>  举个如下的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        URL url = new URL(&quot;http://www.huawei.com&quot;);</span><br><span class="line">        URLConnection uc = url.openConnection();</span><br><span class="line">        uc.connect();</span><br><span class="line">        InputStream in = uc.getInputStream();</span><br><span class="line">        //...after operation</span><br><span class="line">        //close the stream</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果连接无法被建立，会抛出一个IOException。</p>
<p>  二.向URL中写入数据<br>    1.构造URL对象<br>    2.通过openConnection()方法创建一个URLConnection对象<br>    3.调用setDoOutput(boolean doOutput)方法并传入true表明这个连接会被用于写入数据<br>    4.如果你仍然想从InputStream中读取数据，调用setDoInput(boolean doInput)方法并传入true表明这个连接会被用于读取数据<br>    5.创建你想要写入的数据<br>    6.调用getOutputStream拿到OutputStream对象。把第5步中的数据写入其中<br>    7.关闭输出流</p>
<p>  下面是一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MailClient &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if (args.length == 0) &#123;</span><br><span class="line">      System.err.println(&quot;Usage: java MailClient username@host.com&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      URL u = new URL(&quot;mailto:&quot; + args[0]);</span><br><span class="line">      URLConnection uc = u.openConnection();</span><br><span class="line">      uc.setDoOutput(true);</span><br><span class="line">      uc.connect();</span><br><span class="line">      OutputStream out = uc.getOutputStream();</span><br><span class="line">      StreamCopier.copy(System.in, out);</span><br><span class="line">      out.close();</span><br><span class="line">     &#125;</span><br><span class="line">    catch (IOException e) &#123;System.err.println(e);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><p>在数据在互联网中从一个主机到另一个主机的传递之时，它被分割成大小不同但是有限的数据包中(datagrams)。如果要发送的数据大于了数据包的最大大小，它就会被分割成数个包发送，这样做的好处是，如果其中有一个包丢失，那么只需要重传一个包，而不必把所有的包重传。如果包抵达的顺序不同，也会在接收点重新组转完毕。</p>
<p>这一操作对程序员来说是透明的，我们工作在高层抽象的socket上。socket提供了两个主机之间可靠地连接。这样子，你就不需要考虑数据包的编码， 数据包的分割，数据包的重传或者是数据包的组装。Scoket提供这四种基本操作:</p>
<p>1.远程连接到一个机器<br>2.发送数据<br>3.接收数据<br>4.关闭连接</p>
<p>java.net.socket是一个network socket提供了这四种基本操作。在这四种操作中，没有一个抽象了协议，这个类就是为了网络客户端和服务器的连接设计的。为了创建一个连接，你调用socket构造函数中的一种。每一个socket对象仅仅连接到一个指定的远程主机。如果要连接到不同的主机，你必须创建一个新的socket对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Socket (String host, int port) throws UnknownHostException, IOException</span><br><span class="line">public Socket(InteAddress address, int port) throws IOException</span><br><span class="line">public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException</span><br><span class="line">public Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException</span><br></pre></td></tr></table></figure>

<p>host可以是像“<a target="_blank" rel="noopener" href="http://www.huawei.com"这样子的,或者127.0.9.1这样.这个参数也可以通过java.net.inetaddress传入./">www.huawei.com&quot;这样子的，或者127.0.9.1这样。这个参数也可以通过java.net.InetAddress传入。</a></p>
<p>port参数指的是远程主机要连接的端口，0～65535.每一个服务都有他们指定的端口。许多知名的服务都运行在知名的端口上。比如HTTP运行在80端口中。</p>
<p>通过socket来发送接收数据是通过InputStream和 OuputStream</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public InputStream getInputStream() throws IOException</span><br><span class="line">public OutputStream getOutputStream() throws IOException</span><br></pre></td></tr></table></figure>
<p>同样的，也有关闭socket连接的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void close() throws IOException</span><br></pre></td></tr></table></figure>

<p>如下的代码连接到一个网络服务器然后下载一个特定的URL地址。然而这里使用的是Socket而不是URL Connection，所以头部信息需要我们自己处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class SocketTyper &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length==0) &#123;</span><br><span class="line">            System.err.println(&quot;Usage: java SocketTyper url1 url2..&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">            if(args.length&lt;1) &#123;</span><br><span class="line">                System.out.println(args[i]+&quot;:&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                URL u = new URL(args[i]);</span><br><span class="line">                if(u.getProtocol().equalsIgnoreCase(&quot;http&quot;))&#123;</span><br><span class="line">                    System.err.println(&quot;ONLY support http&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                String host = u.getHost();</span><br><span class="line">                int port = u.getPort();</span><br><span class="line">                String file = u.getFile();</span><br><span class="line">                if(port&lt;=0||port&gt;65535) &#123;</span><br><span class="line">                    port = 80;</span><br><span class="line">                &#125;</span><br><span class="line">                Socket s = new Socket(host,port);</span><br><span class="line">                String request = &quot;GET&quot;+file+&quot;HTTP/1.0\r\n&quot;+&quot;User-Agent:MechaMozilla\r\nAccept:text*\r\n\r\n&quot;;</span><br><span class="line">                byte[] b = request.getBytes();</span><br><span class="line">                OutputStream out = s.getOutputStream();</span><br><span class="line">                InputStream in = s.getInputStream();</span><br><span class="line">                out.write(b);</span><br><span class="line">                out.flush();</span><br><span class="line">                StreamCopier.copy(in,System.out);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                s.close();</span><br><span class="line">            &#125; catch (MalformedURLException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><p>两种连接终端，客户端初始化连接，还有服务端，响应连接。实现一个服务器，你需要书写一个等待其他主机连接的程序。一个ServerSocket连接到本机的一个特定端口，一旦它顺利地绑定到了一个端口上，如果监听到了来自其他主机(客户端)的请求，就会建立连接。</p>
<p>一个端口同时可以连接多个客户端。传递来的数据会根据客户端的ip和端口来区分，ip和端口的组合是唯一的。有且只能有一个客户端监听同一主机上的同一端口。通常情况下，ServerSocket只用来接收连接，而和客户端的通信放在独立的线程里去处理。而把将要建立的连接放在队列里面逐个处理。</p>
<p>java.net.ServerSocket类代表着一个ServerSocket。有如下的构造函数，可以确定监听的端口，队列的长度以及ip地址（默认为本机）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ServerSocket (int port) throws IOException</span><br><span class="line">public ServerSocket (int port, int backlog) throws IOException</span><br><span class="line">public ServerSocket (int port, int backlog, InetAddress bindAddr) throws IOException</span><br></pre></td></tr></table></figure>

<p>通常情况下你指定你想要监听的端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ServerSocket ss = new ServerSocket(99);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时该端口已经被其他程序占用，就会导致BindException。当你拥有了ServerSocket之后，你需要等待连接，通过调用accept方法，这个方法会阻塞，直到一个连接到来，然后返回一个Socket，你可以使用它来和客户端通信，调用close方法会关闭ServerSocket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Socket accept() throws IOException</span><br><span class="line">public void close() throws IOException</span><br></pre></td></tr></table></figure>

<p>下面的例子展示了一个程序，监听端口，当建立连接之时，它返回客户端和自身的ip和端口，然后关闭连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServer &#123;</span><br><span class="line"></span><br><span class="line">    public final static int DEFAULT_PORT = 2345;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int port = DEFAULT_PORT;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            port = Integer.parseInt(args[0]);</span><br><span class="line">        &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">        if(port&lt;=0||port&gt;=65536) &#123;</span><br><span class="line">            port = DEFAULT_PORT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket ss = new ServerSocket(port);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Socket s = ss.accept();</span><br><span class="line">                    String response = s.getInetAddress()+&quot;&quot;+s.getPort()+&quot;\n&quot;;</span><br><span class="line">                    response += s.getLocalAddress()+&quot;&quot;+s.getLocalPort();</span><br><span class="line">                    OutputStream out = s.getOutputStream();</span><br><span class="line">                    out.write(response.getBytes());</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/09/08/Andoird%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/" rel="prev" title="Android避免费内存泄露【翻译】">
                  <i class="fa fa-angle-left"></i> Android避免费内存泄露【翻译】
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/08/18/Java%20NIO%20%E8%A7%A3%E6%9E%90/" rel="next" title="Java NIO 解析">
                  Java NIO 解析 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhangjian He</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
